---
title: "BCPP Updated Analysis"
author: "Melody Owen"
date: "2025-08-01"
output:
  pdf_document:
    toc: true
    toc_depth: 3
    latex_engine: pdflatex  # or xelatex/lualatex if you're using those
    includes:
      in_header: preamble.tex
geometry: margin=0.5in
---

\newpage

# OVERVIEW

## The Botswana Combination Prevention Project (BCPP)

### Motivation

- \underline{Goal}: The primary goal of BCPP was to determine whether implementation of combination prevention package (CP) can significantly reduce population-level, cumulative HIV incidence

- \underline{Population}: Individuals in Botswana aged 16-64 years

- \underline{Timeline}: Study length was approximately 3 years

- \underline{Design}: 30 communities were selected and matched into pairs based on community characteristics thought to be associated with HIV incidence

### Treatment in BCPP

The Combination Prevention (CP) prevention package included the following four components:

1. \underline{VMMC}: Voluntary Medical Male Circumcision (only for HIV-negative males)

2. \underline{HTC}: HIV Testing and Counseling (only for HIV-negative individuals)

3. \underline{ART}: Antiretroviral Therapy (only for HIV-positive individuals)

4. \underline{PMTCT}: Prevention of mother-to-child transmission (only for pregnant HIV-positive females)

Clusters (30 communities) were randomized to either:

- \underline{Treatment}: CP Package

- \underline{Control}: Standard of Care

Our analysis examines the impact of CP for HIV-negative individuals, so we consider the "entire" package components 1 and 2 only.

\newpage

## Terminology

\underline{Individual Effects}: Refers to an effect of one's own input on their own outcome

\underline{Spillover Effects}: Refers to an effect of others' inputs on one's outcome; "within-cluster spillover" refers to spillover between individuals in the same cluster

\underline{Direct Effects}: Refers to an effect pathway that links directly from an input to an output with nothing else on the pathway

\underline{Indirect Effects}: Refers to an effect pathway that links indirectly from an input to an output through a node (mediator) on the pathway \newline

With these, we can define the following:

\underline{Individual Effects}

  - **Individual Direct Effect**: Path from one's own input to their own outcome with no other nodes on the pathway
  - **Individual Indirect Effect**: Path from one's own input to their own outcome through a node (mediator) on the pathway
  - **Total Individual Effect**: Total effect of one's input on their outcome through all pathways (Individual Direct + Individual Indirect)

\underline{Spillover Effects}

  - **Spillover Direct Effect**: Path from others' inputs to one's outcome with no other nodes on the pathway
  - **Spillover Indirect Effect**: Path from others' inputs to one's outcome through a node (mediator) on the pathway
  - **Total Spillover Effect**: Total effect of other's inputs on one's outcome through all pathways (Spillover Direct + Spillover Indirect)

\underline{Overall Effects}
  
  - **Overall Effect**: Total Individual Effect + Total Spillover Effect

## Questions of Interest

1. What is the direct individual effect of the CP intervention on HIV incidence?

2. To what extent is the total individual effect mediated by Voluntary Male Medical Circumcision (VMMC)?

3. What is the direct spillover effect of the CP intervention on HIV incidence?

4. To what extent is the total spillover effect mediated by VMMC? 

5. What is the overall effect of CP on HIV incidence? ("overall" includes both spillover and individual totals)

6. To what extent is the overall effect mediated by VMMC? 

\newpage

# NOTATION

$K$ is the total number of villages in the study, indexed as $k = 1,...,K$

$m_k$ is the total number of individuals in cluster $k$, indexed as $i = 1,...,m_k$

- $m_k^{(\text{male})}$ are the total number of males in cluster $k$
- $m_k^{(\text{female})}$ are the total number of females in cluster $k$
    
$Y_{ik}$ is the outcome of subject $i$ in cluster $k$, and is binary

- In BCPP, $Y_{ik} = 1$ if a subject seroconverted by the end of the study, $Y_{ik} = 0$ otherwise

$T_k$ is the cluster-level binary treatment assignment

- In BCPP, $T_k = 1$ if a cluster has been assigned to receive CP, and $T_k = 0$ otherwise

$X_{ik}^{(1)}$, $X_{ik}^{(2)}$ denotes each of the two components of the treatment, $T_k$. 

- In BCPP, the Combination Prevention (CP) package included the following:

    1. MC: Male Circumcision (available only for HIV-negative males)
    2. HTC: HIV Testing and Counseling (available only for HIV-negative individuals)
    3. ART: Antiretroviral Therapy (available only for HIV-positive individuals)
    4. PMTCT: Prevention of Mother-to-Child Transmission (available only for HIV-positive females)
    
- We are only considering the first two components as the entire treatment package, since the last two apply to HIV-positive individuals only.
- $X_{ik}^{(1)}$ denotes any type of male circumcision (MC); $X_{ik}^{(1)} = \text{"Yes"}$ if individual $i$ in cluster $k$ was circumcised before or during the study, $X_{ik}^{(1)} = \text{"No"}$ if they are male and not circumcised, and $X_{ik}^{(1)} = \text{"Female"}$ if they are female (three levels are included as to not exclude females)
- $X_{ik}^{(1, \text{VMMC})}$ denotes voluntary medical male circumcision (VMMC); $X_{ik}^{(1)} = \text{"Yes"}$ if individual $i$ in cluster $k$ was circumcised, $X_{ik}^{(1)} = \text{"No"}$ if they are male and not circumcised or circumcised before the study, and $X_{ik}^{(1)} = \text{"Female"}$ if they are female (three levels are included as to not exclude females)
- $X_{ik}^{(2)} = 1$ if individual $i$ in cluster $k$ received HTC at enrollment or thereafter, and $X_{ik}^{(2)} = 0$ otherwise

$X_{ik}^{(12)}$ denotes whether individual $i$ in cluster $k$ received the entire treatment

- For males in BCPP, $X_{ik}^{(12)} = X_{ik}^{(1)} \times X_{ik}^{(2)} = 1$ if they received both MC and HTC, $X_{ik}^{(12)} = 0$ otherwise
- For females in BCPP, $X_{ik}^{(12)} = X_{ik}^{(2)} = 1$ if they received HTC, $X_{ik}^{(12)} = 0$ otherwise

$Z_k^{(1)}$, $Z_k^{(2)}$ is the proportion of individuals in village $k$ who received the first component and second component of the treatment, respectively

- For males in BCPP, $Z_k^{(1)} = \sum_{i=1}^{m_k^{(\text{male})}} \frac{X_{ik}^{(1)}}{m_k^{(\text{male})}}$ is the proportion of males in village $k$ who are circumcised before or during the study

- For males in BCPP, $Z_k^{(1, \text{VMMC})} = \sum_{i=1}^{m_k^{(\text{male})}} \frac{X_{ik}^{(1, \text{VMMC})}}{m_k^{(\text{male})}}$ is the proportion of males in village $k$ who have received VMMC during the study

- For all individuals in BCPP, $Z_k^{(2)} = \sum_{i=1}^{m_k} \frac{X_{ik}^{(2)}}{m_k}$ is the proportion of all individuals in village $k$ who received HTC

$Z_{ik}^{(12)}$ is the proportion of individuals who received the full treatment

- For males in BCPP, $Z_{ik}^{(12)} = \sum_{i=1}^{m_k^{(\text{male})}} \frac{X_{ik}^{(1)} \times X_{ik}^{(2)}}{m_k^{(\text{male})}}$ is the proportion of males who are both circumcised and received HTC
- For females in BCPP, $Z_{ik}^{(12)} = Z_{ik}^{(2)} = \sum_{i=1}^{m_k^{(\text{female})}} \frac{X_{ik}^{(2)}}{m_k^{(\text{female})}}$ is the proprtion of females who received HTC

$\mathbf{C}_{ik} = (C_{1k}^{(1)}, ..., C_{m_k k}^{(1)}, C_{1k}^{(2)}, ..., C_{m_k k}^{(2)})$ are the individual level covariates

$\mathbf{V}_k = (V_k^{(1)}, ..., V_k^{(v)})$ are the cluster-level covariates

\newpage

```{r setup, include = FALSE}
# Package names
packages <- c("tidyverse", "lme4", "MASS", "Matrix", "matrixcalc", "latex2exp",
              "ICC", "nlme", "bindata", "gee", "crt2power", "mosaic", "haven",
              "tmvtnorm", "ggplot2", "latex2exp", "reshape2", "gridExtra",
              "table1", "broom", "xtable", "logistf", "kableExtra", "geepack",
              "elrm", "broom", "dplyr", "tibble", "lme4", "broom.mixed",
              "performance", "mice", "glmnet", "rms")

# Install packages not yet installed
installed_packages <- packages %in% rownames(installed.packages())
if (any(installed_packages == FALSE)) {
  install.packages(packages[!installed_packages])
}

# Packages loading
invisible(lapply(packages, library, character.only = TRUE))
```


```{r load_data, include = FALSE}
# Loading in original datasets
dat1 <- read_sas("~/Desktop/3. Causal Inference Mediation/BCPP data/BCPP data/longyr1_20samp_open.sas7bdat")
dat2 <- read_sas("~/Desktop/3. Causal Inference Mediation/BCPP data/BCPP data/longyr2_20samp_open.sas7bdat")
dat3 <- read_sas("~/Desktop/3. Causal Inference Mediation/BCPP data/BCPP data/longyr3_20samp_open.sas7bdat")
```


```{r column_names, include = FALSE}
# Create a dataframe for each set of column names
names1 <- tibble(colname = sort(colnames(dat1)), dataset = "dat1")
names2 <- tibble(colname = sort(colnames(dat2)), dataset = "dat2")
names3 <- tibble(colname = sort(colnames(dat3)), dataset = "dat3")

# Bind and pivot to wide
all_names <- bind_rows(names1, names2, names3) %>%
  mutate(present = colname) %>%
  pivot_wider(names_from = dataset, values_from = present) %>%
  arrange(colname)

all_names_filtered <- bind_rows(names1, names2, names3) %>%
  mutate(present = colname) %>%
  pivot_wider(names_from = dataset, values_from = present) %>%
  arrange(colname) %>%
  dplyr::filter(colname %in% c("de_subj_idC", # Subject identifier
                               "community", # Community identifier
                               
                               "random_arm", # Randomization arm (Treatment Assignment)
                               "gender", # Gender
                               
                               # At start of study? Unclear
                               "hiv_status_current", # Current HIV status
                               "circumcised", # Male circumcision
                               
                               # "Coverage Endpoint"
                               "endpoint_coverage_htc", # Coverage endpoint: HIV-tested or diagnosed HIV+
                               "endpoint_coverage_mc", # Coverage endpoint: male circumcision
                               
                               
                               # Outcome
                               "endpoint_seroconvert") # Incidence endpoint: seroconverted by study completion
  )

# Keeping subject ID the same name so I can match the data
dat1_renamed <- dat1 %>% rename_with(~ paste0(., "_dat1"), -de_subj_idC)
dat2_renamed <- dat2 %>% rename_with(~ paste0(., "_dat2"), -de_subj_idC)
dat3_renamed <- dat3 %>% rename_with(~ paste0(., "_dat3"), -de_subj_idC)
```

```{r echo = FALSE}
combinedDat <- full_join(dat1_renamed, dat2_renamed, by = "de_subj_idC") %>%
  full_join(dat3_renamed, by = "de_subj_idC") %>%
  dplyr::select(de_subj_idC, starts_with("random_arm_dat"), 
                contains("community_dat"),
                starts_with("Gender_dat"), hiv_status_current_dat1,
                starts_with("circumcised_dat"), starts_with("circumcision_days"),
                contains("endpoint_coverage_mc"),
                contains("endpoint_coverage_htc"), contains("seroconvert")) 
```


```{r merging_datasets, include = FALSE}
# Circumcision in all three datasets
combinedDat <- full_join(dat1_renamed, dat2_renamed, by = "de_subj_idC") %>%
  full_join(dat3_renamed, by = "de_subj_idC") %>%
  dplyr::select(de_subj_idC, starts_with("random_arm_dat"), 
                contains("community_dat"),
                starts_with("Gender_dat"), hiv_status_current_dat1,
                starts_with("circumcised_dat"), starts_with("circumcision_days"), 
                contains("endpoint_coverage_mc"),
                contains("endpoint_coverage_htc"), contains("seroconvert")) %>%
  mutate(random_arm = ifelse(!is.na(random_arm_dat1), random_arm_dat1,
                             ifelse(!is.na(random_arm_dat2), random_arm_dat2,
                                    random_arm_dat3))) %>%
  mutate(gender = ifelse(!is.na(gender_dat1), gender_dat1,
                         ifelse(!is.na(gender_dat2), gender_dat2,
                                gender_dat3))) %>%
  mutate(community = ifelse(!is.na(community_dat1), community_dat1,
                            ifelse(!is.na(community_dat2), community_dat2,
                                   community_dat3))) %>%
  dplyr::select(subject_ID = de_subj_idC, community, gender,
                random_arm, hiv_status_current = hiv_status_current_dat1,
                starts_with("circumcised"), starts_with("circumcision_days"),
                contains("endpoint_coverage_mc"), 
                contains("endpoint_coverage_htc"),
                contains("seroconvert")) %>%
  mutate(gender = case_when(gender == "F" ~ "Female",
                            gender == "M" ~ "Male",
                            TRUE ~ NA_character_
  )) %>%
  mutate(circumcised_dat1 = ifelse(gender == "Female",
                                   "Female", circumcised_dat1),
         circumcised_dat2 = ifelse(gender == "Female",
                                   "Female", circumcised_dat2),
         circumcised_dat3 = ifelse(gender == "Female",
                                   "Female", circumcised_dat3)) %>%
  mutate(circumcised_dat2 = ifelse(circumcised_dat1 == "Yes", "Yes",
                                   circumcised_dat2)) %>%
  mutate(circumcised_dat3 = ifelse(circumcised_dat2 == "Yes", "Yes",
                                   ifelse(circumcised_dat1 == "Yes", "Yes",
                                          circumcised_dat3))) %>%
  mutate(across(where(~ !is.numeric(.)), ~ na_if(., ""))) %>%
  mutate(across(where(is.character), str_trim)) %>%
  mutate(endpoint_coverage_mc_dat1 = ifelse(gender == "Female", "Female", endpoint_coverage_mc_dat1),
         endpoint_coverage_mc_dat2 = ifelse(gender == "Female", "Female", endpoint_coverage_mc_dat2),
         endpoint_coverage_mc_dat3 = ifelse(gender == "Female", "Female", endpoint_coverage_mc_dat3)) %>%
  mutate(endpoint_coverage_mc = ifelse(circumcised_dat1 == "Yes" & circumcision_days_dat1 < 0,
                                       "Began study circumcised", ifelse(circumcised_dat1 == "Yes" & (circumcision_days_dat1 >= 0 | is.na(circumcision_days_dat1)), "Yes", NA))) %>%
  # mutate(endpoint_coverage_mc = ifelse(circumcised_dat1 == "Yes",
  #                                      "Began study circumcised", NA)) %>%
  mutate(endpoint_coverage_mc = ifelse(gender == "Female", "Female",
                                       endpoint_coverage_mc)) %>%
  mutate(endpoint_coverage_mc = ifelse(is.na(endpoint_coverage_mc) & endpoint_coverage_mc_dat3 == "Yes",
                                       "Yes", endpoint_coverage_mc)) %>%
  mutate(endpoint_coverage_mc = ifelse(is.na(endpoint_coverage_mc) & endpoint_coverage_mc_dat2 == "Yes",
                                       "Yes", endpoint_coverage_mc)) %>%
  mutate(endpoint_coverage_mc = ifelse(is.na(endpoint_coverage_mc) & endpoint_coverage_mc_dat1 == "Yes",
                                       "Yes", endpoint_coverage_mc)) %>%
  mutate(endpoint_coverage_mc = ifelse(is.na(endpoint_coverage_mc) & circumcised_dat3 == "Yes",
                                       "Yes", endpoint_coverage_mc)) %>%
  mutate(endpoint_coverage_mc = ifelse(is.na(endpoint_coverage_mc) & circumcised_dat2 == "Yes",
                                       "Yes", endpoint_coverage_mc)) %>%
  mutate(endpoint_coverage_mc = ifelse(is.na(endpoint_coverage_mc) &
                                         rowSums(across(contains("dat"), ~ replace_na(. == "No", FALSE))) > 0 &
                                         rowSums(across(contains("dat"), ~ replace_na(. == "Yes", FALSE))) == 0,
                                       "No", endpoint_coverage_mc))
```


```{r cleaning_data, include = FALSE}
# This dataset is a cleaned version of the original dataset with NO ONE EXCLUDED YET
cleanDat <- combinedDat %>%
  dplyr::select(original_subject_id = subject_ID, 
                original_glmmter_id = community, 
                random_arm, gender, 
                hiv_status_current,
                endpoint_coverage_htc = endpoint_coverage_htc_dat1, 
                endpoint_coverage_mc, 
                endpoint_seroconvert = endpoint_seroconvert_dat1) %>%
  mutate(endpoint_coverage_full = ifelse(gender == "Male" & (endpoint_coverage_mc == "Yes" | endpoint_coverage_mc == "Began study circumcised") & endpoint_coverage_htc == "Yes", "Yes", 
                         ifelse(gender == "Female" & endpoint_coverage_htc == "Yes", "Yes", "No"))) %>%
  arrange(original_glmmter_id, original_subject_id) %>%
  mutate_if(is.character, list(~na_if(., ""))) %>% # change any blanks to NAs
  rowid_to_column("subject_id") %>%
  group_by(original_glmmter_id) %>%
  mutate(cluster_id = cur_group_id()) %>%
  mutate(subj_glmmter_id = row_number()) %>%
  ungroup() %>%
  add_count(cluster_id, name = "cluster_size") %>%
  relocate(subject_id, subj_glmmter_id, cluster_id, cluster_size) %>%
  ungroup() %>%
  dplyr::select(-original_subject_id, -original_glmmter_id) %>%
  mutate(random_arm = ifelse(random_arm == "Standard of Care", "Control",
                             ifelse(random_arm == "Intervention", "Treatment", NA))) %>%
  mutate(endpoint_seroconvert = ifelse(hiv_status_current == "HIV-infected",
                                       "Began study HIV-infected", endpoint_seroconvert))
```

```{r create_model_dat, include = FALSE}
# ModelDat is the clean dataset but with people excluded
# Only exclude people who already have HIV or refused testing
# Also people who don't have the outcome
modelDat_full <- cleanDat %>%
  # Calculate proportions first
  mutate(T_k = ifelse(random_arm == "Treatment", 1, 
                      ifelse(random_arm == "Control", 0, NA))) %>%
  # 1 if circumcised before or during study, 0 if no, "Female" if female
  mutate(X1_ik = ifelse(endpoint_coverage_mc == "Yes" | endpoint_coverage_mc == "Began study circumcised", "Yes",
                        ifelse(endpoint_coverage_mc == "No", "No", endpoint_coverage_mc))) %>%
  # 1 if HTC yes, 0 if HTC no
  mutate(X2_ik = ifelse(endpoint_coverage_htc == "Yes", 1,
                        ifelse(endpoint_coverage_htc == "No", 0, NA))) %>%
  # 1 if Male, circumcised, and got HTC | 1 if female and got HTC, 0 otherwise
  mutate(X12_ik = ifelse(gender == "Male" & X1_ik == "Yes" & X2_ik == 1, 1, 
                         ifelse(gender == "Female" & X2_ik == 1, 1, 0))) %>%
  # Gender characteristic, 1 if Male, 0 if female
  mutate(C1_ik = ifelse(gender == "Male", 1, 
                        ifelse(gender == "Female", 0, NA))) %>%
  mutate(X1_ik_vmmc = ifelse(endpoint_coverage_mc == "Yes", "Yes", 
                       ifelse(endpoint_coverage_mc %in% c("Began study circumcised", "No"), "No",
                              ifelse(endpoint_coverage_mc == "Female", "Female", NA)))) %>%
  group_by(cluster_id) %>%
  # Count of all men in each cluster
  mutate(male_count = sum(gender == "Male", na.rm = TRUE)) %>%
  # Count of all male circumcised men in each cluster
  mutate(mc_count = sum(X1_ik == "Yes", na.rm = TRUE)) %>%
  # Count of all male VMMC in each cluster
  mutate(vmmc_count = sum(X1_ik_vmmc == "Yes", na.rm = TRUE)) %>%
  # Count of those who received HTC in each cluster
  mutate(htc_count = sum(X2_ik == 1, na.rm = TRUE)) %>%
  # Count of those who received their full treatment in each cluster
  mutate(full_trt_count = sum(X12_ik == 1, na.rm = TRUE)) %>%
  # Count of those who started study HIV positive in each cluster
  mutate(hiv_infected_count = sum(hiv_status_current == "HIV-infected", na.rm = TRUE)) %>%
  mutate(hiv_refused_testing_count = sum(hiv_status_current == "Refused HIV testing", na.rm = TRUE)) %>%
  ungroup() %>%
  # Treatment related proportions
  mutate(Z1_k = mc_count/male_count, # Prop males circumcised
         Z1_k_vmmc = vmmc_count/male_count, # Prop males VMMC
         Z2_k = htc_count/cluster_size,
         Z12_k = full_trt_count/cluster_size) %>%
  # Characteristic related proportions
  mutate(hiv_infected_prop = hiv_infected_count/cluster_size) %>%
  mutate(hiv_refused_testing_prop = hiv_refused_testing_count/cluster_size) %>%
  mutate(Y_ik = ifelse(endpoint_seroconvert == "Yes", 1,
                       ifelse(endpoint_seroconvert == "No", 0, NA)))

# Then filter out people who already have HIV or refused testing
modelDat <- modelDat_full %>% 
  dplyr::filter(hiv_status_current == "HIV-uninfected") %>%
  dplyr::filter(!is.na(Y_ik))

excludedDat <- modelDat_full %>%
  dplyr::filter(hiv_status_current != "HIV-uninfected" | is.na(hiv_status_current) | is.na(Y_ik))
```


# BASELINE CHARACTERISTICS

## Characteristics Before Exclusions

The original dataset has `r nrow(cleanDat)` total individuals in the study; `r nrow(dplyr::filter(cleanDat, random_arm == "Treatment"))` in the treatment group, and `r nrow(dplyr::filter(cleanDat, random_arm == "Control"))` in the control arm. 


```{r include = FALSE}
var_order_full <- c("Gender", "HIV Status at Start", "Treatment Component: MC",
                    "Treatment Component: VMMC",
                    "Treatment Component: HTC", "Treatment Component: Full",
                    "Outcome: HIV Seroconversion (3-year period)")
level_order_full <- c("Male", "Yes", "No", "Began study circumcised", "Female",
                      "HIV-uninfected", "HIV-infected", "Refused HIV testing",
                      "Began study HIV-infected")

baseline_full <- cleanDat %>%
  mutate(endpoint_coverage_vmmc = ifelse(endpoint_coverage_mc == "Yes", "Yes", 
                       ifelse(endpoint_coverage_mc %in% c("Began study circumcised", "No"), "No",
                              ifelse(endpoint_coverage_mc == "Female", "Female", NA)))) %>%
  dplyr::select(`Treatment Group` = random_arm,
                `Cluster Size` = cluster_size,
                `Gender` = gender,
                `HIV Status at Start` = hiv_status_current,
                `Treatment Component: MC` = endpoint_coverage_mc,
                `Treatment Component: VMMC` = endpoint_coverage_vmmc,
                `Treatment Component: HTC` = endpoint_coverage_htc,
                `Treatment Component: Full` = endpoint_coverage_full,
                `Outcome: HIV Seroconversion (3-year period)` = endpoint_seroconvert) %>%
  mutate(across(
    where(~ !is.numeric(.x)),
    ~ ifelse(is.na(.x), "Missing", as.character(.x))
  ))

baseline_missing <- baseline_full %>%
  dplyr::select(-`Cluster Size`) %>%
  filter(if_any(everything(), ~ .x == "Missing")) %>%
  mutate(across(
    .cols = -c(`Treatment Group`),  # replace col1 and col2 with your actual column names
    .fns = ~ if_else(.x == "Missing", 1, 0)
  )) %>%
  group_by(`Treatment Group`) %>%
  summarise(across(
    everything(),  # No need to exclude the grouping var here
    sum,
    .names = "{.col}"
  )) %>%
  dplyr::select(-Gender) %>%
  ungroup() %>%
  pivot_longer(
    cols = -`Treatment Group`,  # gather all variables except the group
    names_to = "Variable",
    values_to = "Missing"
  ) %>%
  pivot_wider(
    names_from = `Treatment Group`,
    values_from = Missing
  ) %>%
  mutate(Overall = Control + Treatment) %>%
  rename(`Missing (Control)` = Control,
         `Missing (Treatment)` = Treatment,
         `Missing (Overall)` = Overall)

cluster_size <- tibble(Variable = c("Number of Individuals", 
                                    "Number of Clusters", 
                                    "Mean Cluster Size"),
                       Level = c(NA, NA, NA),
                       Control = c(nrow(dplyr::filter(cleanDat, random_arm == "Control")),
                                   length(unique(dplyr::filter(cleanDat, random_arm == "Control")$cluster_id)),
                                   mean(filter(cleanDat, random_arm == "Control")$cluster_size)),
                       Treatment = c(nrow(dplyr::filter(cleanDat, random_arm == "Treatment")),
                                     length(unique(dplyr::filter(cleanDat, random_arm == "Treatment")$cluster_id)),
                                     mean(filter(cleanDat, random_arm == "Treatment")$cluster_size))) %>%
  mutate(Control = as.integer(Control), Treatment = as.integer(Treatment)) %>%
  mutate(Overall = ifelse(Variable != "Mean Cluster Size", Treatment + Control, round((Treatment + Control) / 2, 1)))

baseline_tab <- baseline_full %>%
  dplyr::select(-`Cluster Size`) %>%
  pivot_longer(!`Treatment Group`, 
               names_to = "Variable", values_to = "Level") %>%
  arrange(`Treatment Group`, Variable, Level) %>%
  group_by(`Treatment Group`, Variable, Level) %>%
  dplyr::summarize(n = n()) %>%
  ungroup() %>%
  filter(Level != "Missing") %>%
  group_by(`Treatment Group`, `Variable`) %>%
  mutate(Overall = sum(n)) %>%
  ungroup() %>%
  rowwise() %>%
  mutate(percentage = paste0("(", round(n/Overall, 2)*100, "%)")) %>%
  mutate(n = paste(n, percentage)) %>%
  dplyr::select(-Overall, -percentage) %>%
  pivot_wider(
    names_from = `Treatment Group`,
    values_from = n
  ) %>%
  mutate(
    Overall = parse_number(Control) + parse_number(Treatment)
  ) %>%
  group_by(Variable) %>%
  mutate(Sum = sum(Overall)) %>%
  mutate(Overall = paste0(Overall, " (", round(Overall/Sum, 2)*100, "%)")) %>%
  dplyr::select(-Sum) %>%
  mutate(Variable = factor(Variable, levels = var_order_full),
         Level = factor(Level, levels = level_order_full)) %>%
  arrange(Variable, Level)

n_treat_full <- nrow(filter(cleanDat, random_arm == "Treatment"))
n_control_full <- nrow(filter(cleanDat, random_arm == "Control"))
n_overall_full <- nrow(cleanDat)

final_baseline_full_table <- rbind(cluster_size, baseline_tab) %>%
  left_join(baseline_missing, by = "Variable") %>%
  group_by(Variable) %>%
  mutate(
    Variable = if_else(row_number() == 1, Variable, NA_character_),
    `Missing (Control)` = if_else(row_number() == 1, `Missing (Control)`, NA_integer_),
    `Missing (Treatment)` = if_else(row_number() == 1, `Missing (Treatment)`, NA_integer_),
    `Missing (Overall)` = if_else(row_number() == 1, `Missing (Overall)`, NA_integer_)
  ) %>%
  ungroup() %>%
  mutate(`Missing (Control)` = as.integer(`Missing (Control)`),
         `Missing (Treatment)` = as.integer(`Missing (Treatment)`),
         `Missing (Overall)` = as.integer(`Missing (Overall)`)) %>%
  rowwise() %>%
  mutate(`Missing (Control)` = ifelse(!is.na(`Missing (Control)`), 
                                      paste0(`Missing (Control)`, " (", 
                                             round(`Missing (Control)`/n_control_full, 2)*100, "%)"), NA),
         `Missing (Treatment)` = ifelse(!is.na(`Missing (Treatment)`), 
                                      paste0(`Missing (Treatment)`, " (", 
                                             round(`Missing (Treatment)`/n_treat_full, 2)*100, "%)"), NA),
         `Missing (Overall)` = ifelse(!is.na(`Missing (Overall)`), 
                                      paste0(`Missing (Overall)`, " (", 
                                             round(`Missing (Overall)`/n_overall_full, 2)*100, "%)"), NA))
```


```{r, results = 'asis', echo = FALSE}
cat("\\begin{landscape}\n")

print(
  xtable(
    final_baseline_full_table,
    caption = "Characteristics by treatment group before exclusions",
    label = "tab:cluster_summary"
  ),
  type = "latex",
  include.rownames = FALSE,
  comment = FALSE
)

cat("\\end{landscape}\n")
```


Table below displays the mean proportion, per cluster, of various characteristics, including mean proportion of HIV infected individuals per cluster at baseline, etc. These are calculated before any exclusions. Note that for the proportion of males circumcised in a given cluster, this includes both circumcision that occurred during and before the study. 

```{r include = FALSE}
proportion_dat <- modelDat %>%
  mutate(`Proportion of Males in Cluster` = male_count/cluster_size) %>%
  dplyr::select(cluster_id, 
                `Treatment Group` = random_arm,
                `Proportion of HIV Infected in Cluster` = hiv_infected_prop,
                #`Proportion of Refused HIV Testing in Cluster` = hiv_refused_testing_prop,
                `Proportion of Males in Cluster`,
                `Proportion of Males Circumcised in Cluster` = Z1_k, 
                `Proportion of Males VMMC in Cluster` = Z1_k_vmmc,
                `Proportion HTC in Cluster` = Z2_k,
                `Proportion Fully Treated in Cluster` = Z12_k) %>%
  distinct()

# Compute summary with Mean and SD
proportion_table_final <- proportion_dat %>%
  group_by(`Treatment Group`) %>%
  dplyr::select(-cluster_id) %>%
  dplyr::summarize(across(
    everything(),
    list(
      Mean = ~mean(.x, na.rm = TRUE),
      SD = ~sd(.x, na.rm = TRUE)
    ),
    .names = "{.fn} | {.col}"
  )) %>%
  mutate(across(where(is.numeric), round, 2)) %>%
  pivot_longer(
    -`Treatment Group`,
    names_to = "Stat_Var",
    values_to = "Value"
  ) %>%
  separate(Stat_Var, into = c("Stat", "Variable"), sep = " \\| ") %>%
  pivot_wider(
    names_from = Stat,
    values_from = Value
  ) %>%
  mutate(
    Value = paste0(Mean, " (", SD, ")"),
    Variable = paste0(Variable, " (Mean, SD)")
  ) %>%
  dplyr::select(-Mean, -SD) %>%
  pivot_wider(
    names_from = `Treatment Group`,
    values_from = Value
  )

# View result
#proportion_table_final
#View(proportion_table_final)
```

```{r, results = 'asis', echo = FALSE}
print(
  xtable(
    proportion_table_final,
    caption = "Cluster-level proportions by treatment group before exclusions",
    label = "tab:cluster_summary"
  ),
  type = "latex",
  include.rownames = FALSE,
  comment = FALSE
)
```

## Characteristics After Exclusions

A total of `r nrow(excludedDat)` individuals were excluded from the analysis dataset. This is because these individuals either began the study as HIV-positive (n = `r nrow(filter(excludedDat, hiv_status_current == "HIV-infected"))`), refused HIV testing (n = `r nrow(filter(excludedDat, hiv_status_current == "Refused HIV testing"))`), or had a missing value (n = `r nrow(filter(excludedDat, is.na(hiv_status_current)))`). Or, if they began the study HIV-negative, if they had a missing value for seroconversion (the outcome), they were excluded (n = `r nrow(dplyr::filter(modelDat_full, hiv_status_current == "HIV-uninfected") %>% dplyr::filter(is.na(Y_ik)))`). 

Note that in our analyses, we evaluated whether the intervention reduced HIV incidence by modeling seroconversion among individuals who were HIV-negative at baseline (n = `r nrow(modelDat)`). Although the analysis was restricted to this at-risk subset, all cluster-level characteristics (e.g., proportion HIV-positive at baseline, proportion of men circumcised, etc.) were calculated using the full study population. This approach ensures that the covariates reflect the overall context and implementation environment of each cluster, rather than being limited to the analytic subset.

The following table shows the baseline characteristics of the new dataset that excludes these individuals (n = `r nrow(modelDat)`). 

```{r include = FALSE}
var_order_red <- c("Gender", "HIV Status at Start", "Treatment Component: MC",
                   "Treatment Component: VMMC",
                    "Treatment Component: HTC", "Treatment Component: Full",
                    "Outcome: HIV Seroconversion (3-year period)")
level_order_red <- c("Male", "Yes", "No", "Began study circumcised", "Female",
                      "HIV-uninfected", "HIV-infected", "Refused HIV testing",
                      "Began study HIV-infected")

baseline_red <- modelDat %>%
  mutate(endpoint_coverage_vmmc = ifelse(endpoint_coverage_mc == "Yes", "Yes", 
                       ifelse(endpoint_coverage_mc %in% c("Began study circumcised", "No"), "No",
                              ifelse(endpoint_coverage_mc == "Female", "Female", NA)))) %>%
  dplyr::select(`Treatment Group` = random_arm,
                `Cluster Size` = cluster_size,
                `Gender` = gender,
                `HIV Status at Start` = hiv_status_current,
                `Treatment Component: MC` = endpoint_coverage_mc,
                `Treatment Component: VMMC` = endpoint_coverage_vmmc,
                `Treatment Component: HTC` = endpoint_coverage_htc,
                `Treatment Component: Full` = endpoint_coverage_full,
                `Outcome: HIV Seroconversion (3-year period)` = endpoint_seroconvert) %>%
  mutate(across(
    where(~ !is.numeric(.x)),
    ~ ifelse(is.na(.x), "Missing", as.character(.x))
  ))

baseline_missing_red <- baseline_red %>%
  dplyr::select(-`Cluster Size`) %>%
  filter(if_any(everything(), ~ .x == "Missing")) %>%
  mutate(across(
    .cols = -c(`Treatment Group`),  # replace col1 and col2 with your actual column names
    .fns = ~ if_else(.x == "Missing", 1, 0)
  )) %>%
  group_by(`Treatment Group`) %>%
  summarise(across(
    everything(),  # No need to exclude the grouping var here
    sum,
    .names = "{.col}"
  )) %>%
  dplyr::select(-Gender) %>%
  ungroup() %>%
  pivot_longer(
    cols = -`Treatment Group`,  # gather all variables except the group
    names_to = "Variable",
    values_to = "Missing"
  ) %>%
  pivot_wider(
    names_from = `Treatment Group`,
    values_from = Missing
  ) %>%
  mutate(Overall = Control + Treatment) %>%
  rename(`Missing (Control)` = Control,
         `Missing (Treatment)` = Treatment,
         `Missing (Overall)` = Overall)

cluster_size_red <- tibble(Variable = c("Number of Individuals", 
                                    "Number of Clusters", 
                                    "Mean Cluster Size"),
                       Level = c(NA, NA, NA),
                       Control = c(nrow(dplyr::filter(modelDat, random_arm == "Control")),
                                   length(unique(dplyr::filter(modelDat, random_arm == "Control")$cluster_id)),
                                   mean(filter(modelDat, random_arm == "Control")$cluster_size)),
                       Treatment = c(nrow(dplyr::filter(modelDat, random_arm == "Treatment")),
                                     length(unique(dplyr::filter(modelDat, random_arm == "Treatment")$cluster_id)),
                                     mean(filter(modelDat, random_arm == "Treatment")$cluster_size))) %>%
  mutate(Control = as.integer(Control), Treatment = as.integer(Treatment)) %>%
  mutate(Overall = ifelse(Variable != "Mean Cluster Size", Treatment + Control, round((Treatment + Control) / 2, 1)))

baseline_tab_red <- baseline_red %>%
  dplyr::select(-`Cluster Size`) %>%
  pivot_longer(!`Treatment Group`, 
               names_to = "Variable", values_to = "Level") %>%
  arrange(`Treatment Group`, Variable, Level) %>%
  group_by(`Treatment Group`, Variable, Level) %>%
  dplyr::summarize(n = n()) %>%
  ungroup() %>%
  filter(Level != "Missing") %>%
  group_by(`Treatment Group`, `Variable`) %>%
  mutate(Overall = sum(n)) %>%
  ungroup() %>%
  rowwise() %>%
  mutate(percentage = paste0("(", round(n/Overall, 2)*100, "%)")) %>%
  mutate(n = paste(n, percentage)) %>%
  dplyr::select(-Overall, -percentage) %>%
  pivot_wider(
    names_from = `Treatment Group`,
    values_from = n
  ) %>%
  mutate(
    Overall = parse_number(Control) + parse_number(Treatment)
  ) %>%
  group_by(Variable) %>%
  mutate(Sum = sum(Overall)) %>%
  mutate(Overall = paste0(Overall, " (", round(Overall/Sum, 2)*100, "%)")) %>%
  dplyr::select(-Sum) %>%
  mutate(Variable = factor(Variable, levels = var_order_full),
         Level = factor(Level, levels = level_order_full)) %>%
  arrange(Variable, Level)

n_treat_red <- nrow(filter(modelDat, random_arm == "Treatment"))
n_control_red <- nrow(filter(modelDat, random_arm == "Control"))
n_overall_red <- nrow(modelDat)

final_baseline_red_table <- rbind(cluster_size_red, baseline_tab_red) %>%
  left_join(baseline_missing_red, by = "Variable") %>%
  group_by(Variable) %>%
  mutate(
    Variable = if_else(row_number() == 1, Variable, NA_character_),
    `Missing (Control)` = if_else(row_number() == 1, `Missing (Control)`, NA_integer_),
    `Missing (Treatment)` = if_else(row_number() == 1, `Missing (Treatment)`, NA_integer_),
    `Missing (Overall)` = if_else(row_number() == 1, `Missing (Overall)`, NA_integer_)
  ) %>%
  ungroup() %>%
  mutate(`Missing (Control)` = as.integer(`Missing (Control)`),
         `Missing (Treatment)` = as.integer(`Missing (Treatment)`),
         `Missing (Overall)` = as.integer(`Missing (Overall)`)) %>%
  rowwise() %>%
  mutate(`Missing (Control)` = ifelse(!is.na(`Missing (Control)`), 
                                      paste0(`Missing (Control)`, " (", 
                                             round(`Missing (Control)`/n_control_full, 2)*100, "%)"), NA),
         `Missing (Treatment)` = ifelse(!is.na(`Missing (Treatment)`), 
                                        paste0(`Missing (Treatment)`, " (", 
                                               round(`Missing (Treatment)`/n_treat_full, 2)*100, "%)"), NA),
         `Missing (Overall)` = ifelse(!is.na(`Missing (Overall)`), 
                                      paste0(`Missing (Overall)`, " (", 
                                             round(`Missing (Overall)`/n_overall_full, 2)*100, "%)"), NA)) %>%
  mutate(`Missing (Control)` = ifelse(`Missing (Control)` == "0 (0%)", 
                                      NA, `Missing (Control)`),
         `Missing (Treatment)` = ifelse(`Missing (Treatment)` == "0 (0%)", 
                                      NA, `Missing (Treatment)`),
         `Missing (Overall)` = ifelse(`Missing (Overall)` == "0 (0%)", 
                                      NA, `Missing (Overall)`))
```


```{r, results = 'asis', echo = FALSE}
cat("\\begin{landscape}\n")

print(
  xtable(
    final_baseline_red_table,
    caption = "Characteristics by treatment group after exclusions",
    label = "tab:cluster_summary"
  ),
  type = "latex",
  include.rownames = FALSE,
  comment = FALSE
)

cat("\\end{landscape}\n")
```

\newpage


## VMMC vs. MC

```{r, eval = FALSE}
mc_order <- c("Yes", "No", "Female", "Missing")

mc_table <- modelDat %>%
  dplyr::select(Y_ik, X1_ik) %>%
  mutate(X1_ik = ifelse(is.na(X1_ik), "Missing", X1_ik)) %>%
  mutate(Y_ik = ifelse(Y_ik == 1, "Yes", "No")) %>%
  group_by(Y_ik, X1_ik) %>%
  dplyr::summarize(n = n()) %>%
  ungroup() %>%
  pivot_wider(values_from = n, names_from = Y_ik) %>%
  mutate(MC = factor(X1_ik, levels = mc_order)) %>%
  dplyr::select(MC, Yes, No) %>%
  mutate(Yes = ifelse(is.na(Yes), 0, Yes)) %>%
  mutate(No = ifelse(is.na(No), 0, No)) %>%
  arrange(MC)

vmmc_table <- modelDat %>%
  dplyr::select(Y_ik, X1_ik_vmmc) %>%
  mutate(X1_ik_vmmc = ifelse(is.na(X1_ik_vmmc), "Missing", X1_ik_vmmc)) %>%
  mutate(Y_ik = ifelse(Y_ik == 1, "Yes", "No")) %>%
  group_by(Y_ik, X1_ik_vmmc) %>%
  dplyr::summarize(n = n()) %>%
  ungroup() %>%
  pivot_wider(values_from = n, names_from = Y_ik) %>%
  mutate(VMMC = factor(X1_ik_vmmc, levels = mc_order)) %>%
  dplyr::select(VMMC, Yes, No) %>%
  mutate(Yes = ifelse(is.na(Yes), 0, Yes)) %>%
  mutate(No = ifelse(is.na(No), 0, No)) %>%
  arrange(VMMC)
```



\newpage 

# MODELING RESULTS

## Overall Effects

### A. Overall Intervention Village Effect

The overall effect of being in an intervention village can be calculated by just fitting the following model on the overall dataset of HIV-negative individuals (at the start of the study, n = `r nrow(modelDat)`), without controlling for any other causal pathways. 

$$logit(Y_{ik}) = \beta_0^{\text{Overall}} + \beta_1^{\text{Overall}}(T_{k})$$

```{r}
# Overall Effects of T_k on Y_ik

# Model not accounting for clustering
model_overall <- glm(Y_ik ~ T_k,
                     family = binomial(link = 'logit'),
                     data = modelDat) # Everyone

# Model accounting for clustering using GLMM
model_overall_glmm <- glmer(Y_ik ~ T_k + (1|cluster_id),# Uses exchangeable
                            data = modelDat,
                            family = binomial(link = "logit"))

# Model accounting for clustering using GEE
model_overall_gee <- geeglm(Y_ik ~ T_k,
                            family = binomial(link = "logit"),
                            id = cluster_id,
                            data = modelDat,
                            corstr = "exchangeable") # working correlation
```

```{r, echo = FALSE}
# GlM Model
model_overall_summary <- summary(model_overall) # Save model summary

exp_beta_overall_0 <- exp(model_overall_summary$coefficients[1,1]) # Intercept
exp_beta_overall_1 <- exp(model_overall_summary$coefficients[2,1]) # T_k Coefficient

tidy_overall <- broom::tidy(model_overall, conf.int = TRUE, exponentiate = TRUE) %>%
  dplyr::select(term, estimate, std.error, p.value, conf.low, conf.high) %>%
  mutate(Model = "GLM",
         Term = term,
         `OR [95% CI]` = paste0(round(estimate, 3), " [", 
                            round(conf.low, 3), ", ", 
                            round(conf.high, 3), "]"),
         `p-value` = round(p.value, 3)) %>%
  dplyr::select(Model, Term, `OR [95% CI]`, `p-value`) %>%
  dplyr::filter(Term != "(Intercept)") %>%
  mutate(ICC = NA)

# GLMM Model
model_overall_summary_glmm <- summary(model_overall_glmm) # Save model summary

exp_beta_overall_0_glmm <- exp(model_overall_summary_glmm$coefficients[1,1]) # Intercept
exp_beta_overall_1_glmm <- exp(model_overall_summary_glmm$coefficients[2,1]) # T_k Coefficient

tidy_overall_glmm <- broom.mixed::tidy(model_overall_glmm, effects = "fixed", 
                  conf.int = TRUE, exponentiate = TRUE) %>%
  dplyr::select(term, estimate, std.error, p.value, conf.low, conf.high) %>%
  mutate(Model = "GLMM",
         Term = term,
         `OR [95% CI]` = paste0(round(estimate, 3), " [", 
                            round(conf.low, 3), ", ", 
                            round(conf.high, 3), "]"),
         `p-value` = round(p.value, 3)) %>%
  dplyr::select(Model, Term, `OR [95% CI]`, `p-value`) %>%
  dplyr::filter(Term != "(Intercept)") %>%
  mutate(ICC = c(round(performance::icc(model_overall_glmm)$ICC_adjusted[[1]], 3)))

# GEE Model
model_overall_summary_gee <- summary(model_overall_gee) # Save model summary

exp_beta_overall_0_gee <- exp(model_overall_summary_gee$coefficients[1,1]) # Intercept
exp_beta_overall_1_gee <- exp(model_overall_summary_gee$coefficients[2,1]) # T_k Coefficient

tidy_overall_gee <- broom::tidy(model_overall_gee, conf.int = TRUE, 
                            exponentiate = TRUE) %>%
  dplyr::select(term, estimate, std.error, p.value, conf.low, conf.high) %>%
  mutate(Model = "GEE",
         Term = term,
         `OR [95% CI]` = paste0(round(estimate, 3), " [", 
                            round(conf.low, 3), ", ", 
                            round(conf.high, 3), "]"),
         `p-value` = round(p.value, 3)) %>%
  dplyr::select(Model, Term, `OR [95% CI]`, `p-value`) %>%
  dplyr::filter(Term != "(Intercept)") %>%
  mutate(ICC = c(round(model_overall_gee$geese$alpha[[1]], 3)))

# Overall Output Table for SpW
overall_Model_Table <- rbind(tidy_overall, tidy_overall_glmm) %>%
  rbind(tidy_overall_gee)
```

```{r, results = 'asis', echo = FALSE}
print(xtable(overall_Model_Table, 
             caption = "Overall Effect of Treatment Assignment on HIV Model Output"), 
      type = 'latex', include.rownames = FALSE, comment = FALSE)
```

Thus, the OR is `r round(exp_beta_overall_1, 2)`, meaning that for HIV-negative individuals at baseline, living in an intervention village is associated with a `r (1 - round(exp_beta_overall_1, 2))*100`% reduction in the odds of seroconversion during follow-up compared with living in a control village. This single odds ratio blends every causal pathway, thus resulting in an overall effect. It is the total impact of the intervention environment on an average resident. 


## Within-Village Spillover


\underline{Setup}

- In this analysis, we include everyone in the study (who began the study HIV-negative) who DID NOT receive any part of the treatment. 

- This setup will allow us to estimate

    a. Total Within-Cluster Spillover Effect of the Intervention
    b. Within-Cluster Spillover of the Intervention Effect Not through Voluntary Medical Male Circumcision
    c. Proportion of Within-Intervention Village Spillover Effect Mediated by Voluntary Medical Male Circumcision
    
\underline{Dataset}

```{r}
# Only include those in treatment group who DID NOT receive any part of the treatment
# Only include those in control group who DID NOT receive any part of treatment
modelDat_SpW <- modelDat %>%
  filter(X1_ik_vmmc != "Yes", X2_ik == 0) # Exclude anyone who got any part of the treatment
```

The total sample size for this analysis is `r nrow(modelDat_SpW)`, meaning that `r nrow(modelDat) - nrow(modelDat_SpW)` individuals are excluded. 

\underline{Data Characteristics}

```{r, include = FALSE}
var_order_SpW <- c("Gender", "HIV Status at Start", "Treatment Component: MC",
                   "Treatment Component: VMMC",
                    "Treatment Component: HTC", "Treatment Component: Full",
                    "Outcome: HIV Seroconversion (3-year period)")
level_order_SpW <- c("Male", "Yes", "No", "Began study circumcised", "Female",
                      "HIV-uninfected", "HIV-infected", "Refused HIV testing",
                      "Began study HIV-infected")

baseline_SpW <- modelDat_SpW %>%
  mutate(endpoint_coverage_vmmc = ifelse(endpoint_coverage_mc == "Yes", "Yes", 
                       ifelse(endpoint_coverage_mc %in% c("Began study circumcised", "No"), "No",
                              ifelse(endpoint_coverage_mc == "Female", "Female", NA)))) %>%
  dplyr::select(`Treatment Group` = random_arm,
                `Cluster Size` = cluster_size,
                `Gender` = gender,
                `HIV Status at Start` = hiv_status_current,
                `Treatment Component: MC` = endpoint_coverage_mc,
                `Treatment Component: VMMC` = endpoint_coverage_vmmc,
                `Treatment Component: HTC` = endpoint_coverage_htc,
                `Treatment Component: Full` = endpoint_coverage_full,
                `Outcome: HIV Seroconversion (3-year period)` = endpoint_seroconvert) %>%
  mutate(across(
    where(~ !is.numeric(.x)),
    ~ ifelse(is.na(.x), "Missing", as.character(.x))
  ))

# No missing observed
# baseline_missing_SpW <- baseline_SpW %>%
#   dplyr::select(-`Cluster Size`) %>%
#   filter(if_any(everything(), ~ .x == "Missing")) %>%
#   mutate(across(
#     .cols = -c(`Treatment Group`),  # replace col1 and col2 with your actual column names
#     .fns = ~ if_else(.x == "Missing", 1, 0)
#   )) %>%
#   group_by(`Treatment Group`) %>%
#   summarise(across(
#     everything(),  # No need to exclude the grouping var here
#     sum,
#     .names = "{.col}"
#   )) %>%
#   dplyr::select(-Gender) %>%
#   ungroup() %>%
#   pivot_longer(
#     cols = -`Treatment Group`,  # gather all variables except the group
#     names_to = "Variable",
#     values_to = "Missing"
#   ) %>%
#   pivot_wider(
#     names_from = `Treatment Group`,
#     values_from = Missing
#   ) %>%
#   mutate(Overall = Control + Treatment) %>%
#   rename(`Missing (Control)` = Control,
#          `Missing (Treatment)` = Treatment,
#          `Missing (Overall)` = Overall)

cluster_size_SpW <- tibble(Variable = c("Number of Individuals", 
                                    "Number of Clusters", 
                                    "Mean Cluster Size"),
                       Level = c(NA, NA, NA),
                       Control = c(nrow(dplyr::filter(modelDat_SpW, random_arm == "Control")),
                                   length(unique(dplyr::filter(modelDat_SpW, random_arm == "Control")$cluster_id)),
                                   mean(filter(modelDat_SpW, random_arm == "Control")$cluster_size)),
                       Treatment = c(nrow(dplyr::filter(modelDat_SpW, random_arm == "Treatment")),
                                     length(unique(dplyr::filter(modelDat_SpW, random_arm == "Treatment")$cluster_id)),
                                     mean(filter(modelDat_SpW, random_arm == "Treatment")$cluster_size))) %>%
  mutate(Control = as.integer(Control), Treatment = as.integer(Treatment)) %>%
  mutate(Overall = ifelse(Variable != "Mean Cluster Size", Treatment + Control, round((Treatment + Control) / 2, 1)))

baseline_tab_SpW <- baseline_SpW %>%
  dplyr::select(-`Cluster Size`) %>%
  pivot_longer(!`Treatment Group`, 
               names_to = "Variable", values_to = "Level") %>%
  arrange(`Treatment Group`, Variable, Level) %>%
  group_by(`Treatment Group`, Variable, Level) %>%
  dplyr::summarize(n = n()) %>%
  ungroup() %>%
  filter(Level != "Missing") %>%
  group_by(`Treatment Group`, `Variable`) %>%
  mutate(Overall = sum(n)) %>%
  ungroup() %>%
  rowwise() %>%
  mutate(percentage = paste0("(", round(n/Overall, 2)*100, "%)")) %>%
  mutate(n = paste(n, percentage)) %>%
  dplyr::select(-Overall, -percentage) %>%
  pivot_wider(
    names_from = `Treatment Group`,
    values_from = n
  ) %>%
  mutate(
    Overall = parse_number(Control) + parse_number(Treatment)
  ) %>%
  group_by(Variable) %>%
  mutate(Sum = sum(Overall)) %>%
  mutate(Overall = paste0(Overall, " (", round(Overall/Sum, 2)*100, "%)")) %>%
  dplyr::select(-Sum) %>%
  mutate(Variable = factor(Variable, levels = var_order_full),
         Level = factor(Level, levels = level_order_full)) %>%
  arrange(Variable, Level)

n_treat_SpW <- nrow(filter(modelDat_SpW, random_arm == "Treatment"))
n_control_SpW <- nrow(filter(modelDat_SpW, random_arm == "Control"))
n_overall_SpW <- nrow(modelDat_SpW)

final_baseline_SpW_table <- rbind(cluster_size_SpW, baseline_tab_SpW) %>%
  #left_join(baseline_missing_SpW, by = "Variable") %>% No missing observed
  group_by(Variable) %>%
  mutate(
    Variable = if_else(row_number() == 1, Variable, NA_character_)
  #   `Missing (Control)` = if_else(row_number() == 1, `Missing (Control)`, NA_integer_),
  #   `Missing (Treatment)` = if_else(row_number() == 1, `Missing (Treatment)`, NA_integer_),
  #   `Missing (Overall)` = if_else(row_number() == 1, `Missing (Overall)`, NA_integer_)
  ) 
  # ungroup() %>%
  # mutate(`Missing (Control)` = as.integer(`Missing (Control)`),
  #        `Missing (Treatment)` = as.integer(`Missing (Treatment)`),
  #        `Missing (Overall)` = as.integer(`Missing (Overall)`)) %>%
  # rowwise() %>%
  # mutate(`Missing (Control)` = ifelse(!is.na(`Missing (Control)`), 
  #                                     paste0(`Missing (Control)`, " (", 
  #                                            round(`Missing (Control)`/n_control_full, 2)*100, "%)"), NA),
  #        `Missing (Treatment)` = ifelse(!is.na(`Missing (Treatment)`), 
  #                                       paste0(`Missing (Treatment)`, " (", 
  #                                              round(`Missing (Treatment)`/n_treat_full, 2)*100, "%)"), NA),
  #        `Missing (Overall)` = ifelse(!is.na(`Missing (Overall)`), 
  #                                     paste0(`Missing (Overall)`, " (", 
  #                                            round(`Missing (Overall)`/n_overall_full, 2)*100, "%)"), NA))

```



```{r, results = 'asis', echo = FALSE}
cat("\\begin{landscape}\n")

print(
  xtable(
    final_baseline_SpW_table,
    caption = "Characteristics of Spillover Effects Analysis Data",
  ),
  type = "latex",
  include.rownames = FALSE,
  comment = FALSE
)

cat("\\end{landscape}\n")
```

\newpage

### B. Total Within-Cluster Spillover Effect of the Intervention

"SpW" denotes total spillover within intervention clusters. This compares participants in intervention villages who received neither relevant intervention component to people in the control villages (who also did not receive any part of the intervention component)

Then, under certain assumptions, the only way for an intervention village participant to have lower HIV risk is by association with others in the village with lower HIV risk because of their exposure to the intervention. 

$$logit(Y_{ik}) = \beta_0^{\text{SpW}} + \beta_1^{\text{SpW}}(T_{k})$$

Then $\exp\left( \beta_1^{\text{SpW}} \right)$ is a within-village spillover OR, and estimates the causal effect of living in a CP village, despite receiving no components oneself, on the odds of seroconversion. This is total within-village spillover effect. 

```{r}
# Total Within-Cluster Spillover Effect of the Intervention Model

# Model not accounting for clustering
model_SpW <- glm(Y_ik ~ T_k,
                 family = binomial(link = 'logit'),
                 data = modelDat_SpW) # Exclude those who received full trt

# Model accounting for clustering using GLMM
model_SpW_glmm <- glmer(Y_ik ~ T_k + (1|cluster_id), # Uses exchangeable structure
                        data = modelDat_SpW, 
                        family = binomial(link = "logit"))

# Model accounting for clustering using GEE
model_SpW_gee <- geeglm(Y_ik ~ T_k,
                        family = binomial(link = "logit"), # logit link
                        id = cluster_id, # clustering variable
                        data = modelDat_SpW,
                        corstr  = "exchangeable") # working correlation
```

```{r, echo = FALSE}
# GLM Model
model_SpW_summary <- summary(model_SpW) # Save model summary

exp_beta_SpW_0 <- exp(model_SpW_summary$coefficients[1,1]) # Intercept
exp_beta_SpW_1 <- exp(model_SpW_summary$coefficients[2,1]) # T_k Coefficient

tidy_SpW <- broom::tidy(model_SpW, conf.int = TRUE, exponentiate = TRUE) %>%
  dplyr::select(term, estimate, std.error, p.value, conf.low, conf.high) %>%
  mutate(Model = "GLM",
         Term = term,
         `OR [95% CI]` = paste0(round(estimate, 3), " [", 
                            round(conf.low, 3), ", ", 
                            round(conf.high, 3), "]"),
         `p-value` = round(p.value, 3)) %>%
  dplyr::select(Model, Term, `OR [95% CI]`, `p-value`) %>%
  dplyr::filter(Term != "(Intercept)") %>%
  mutate(ICC = NA)

# GLMM Model
model_SpW_summary_glmm <- summary(model_SpW_glmm) # Save model summary

exp_beta_SpW_0_glmm <- exp(model_SpW_summary_glmm$coefficients[1,1]) # Intercept
exp_beta_SpW_1_glmm <- exp(model_SpW_summary_glmm$coefficients[2,1]) # T_k Coefficient

tidy_SpW_glmm <- broom.mixed::tidy(model_SpW_glmm, effects = "fixed", 
                  conf.int = TRUE, exponentiate = TRUE) %>%
  dplyr::select(term, estimate, std.error, p.value, conf.low, conf.high) %>%
  mutate(Model = "GLMM",
         Term = term,
         `OR [95% CI]` = paste0(round(estimate, 3), " [", 
                            round(conf.low, 3), ", ", 
                            round(conf.high, 3), "]"),
         `p-value` = round(p.value, 3)) %>%
  dplyr::select(Model, Term, `OR [95% CI]`, `p-value`) %>%
  dplyr::filter(Term != "(Intercept)") %>%
  mutate(ICC = round(performance::icc(model_SpW_glmm)$ICC_adjusted[[1]], 3))

# GEE Model
model_SpW_summary_gee <- summary(model_SpW_gee) # Save model summary

exp_beta_SpW_0_gee <- exp(model_SpW_summary_gee$coefficients[1,1]) # Intercept
exp_beta_SpW_1_gee <- exp(model_SpW_summary_gee$coefficients[2,1]) # T_k Coefficient

tidy_SpW_gee <- broom::tidy(model_SpW_gee, conf.int = TRUE, 
                            exponentiate = TRUE) %>%
  dplyr::select(term, estimate, std.error, p.value, conf.low, conf.high) %>%
  mutate(Model = "GEE",
         Term = term,
         `OR [95% CI]` = paste0(round(estimate, 3), " [", 
                            round(conf.low, 3), ", ", 
                            round(conf.high, 3), "]"),
         `p-value` = round(p.value, 3)) %>%
  dplyr::select(Model, Term, `OR [95% CI]`, `p-value`) %>%
  dplyr::filter(Term != "(Intercept)") %>%
  mutate(ICC = round(model_SpW_gee$geese$alpha[[1]], 3))

# Overall Output Table for SpW
SpW_Model_Table <- rbind(tidy_SpW, tidy_SpW_glmm) %>%
  rbind(tidy_SpW_gee)
```

```{r, results = 'asis', echo = FALSE}
print(xtable(SpW_Model_Table, 
             caption = "Spillover Within Intervention Clusters Model Output"), 
      type = 'latex', include.rownames = FALSE, comment = FALSE)
```

Thus, among people who received none of the intervention components, those living in CP villages had `r (1-round(exp_beta_SpW_1, 2))*100`% lower odds of HIV seroconversion than otherwise comparable untreated people in control villages. Since every individual in this analytic set is personally untreated, any difference in their HIV risk can only arise from indirect protection, and thus, `r round(exp_beta_SpW_1, 2)` is interpreted as the within-village spillover effect of CP.

\newpage

### C. Within-Cluster Spillover of the Intervention Effect Not through Male Circumcision

"SpWR" denotes all the remaining spillover that affects one's outcome that exists when we block the mediated spillover path that exists through male circumcision. 

$$logit(Y_{ik}) = \beta_0^{\text{SpWR}} + \beta_1^{\text{SpWR}}(T_{k}) + \beta_2^{\text{SpWR}}(Z_k^{(1, \text{VMMC})})$$

Here, $\exp\left(\beta_1^{\text{SpWR}} \right)$ compares untreated individuals in CP villages with untreated individuals in control villages after we hold the village's male-circumcision coverage fixed at the same value for both groups. So, it's the OR for the remaining within-village spillover - whatever protection (or risk) is left once the male-circumcision pathway has been accounted for. 

```{r}
test <- glm(Y_ik ~ Z1_k_vmmc,
                  family = binomial(link = 'logit'),
                  data = modelDat_SpW)

summary(test)
```


```{r}
# Within-Cluster Spillover of the Intervention Not Through MC

# Model not accounting for clustering
model_SpWR <- glm(Y_ik ~ T_k + Z1_k_vmmc,
                  family = binomial(link = 'logit'),
                  data = modelDat_SpW)

# Model accounting for clustering using GLMM
model_SpWR_glmm <- glmer(Y_ik ~ T_k + Z1_k_vmmc + (1|cluster_id), # Uses exchangeable
                         data = modelDat_SpW, 
                         family = binomial(link = "logit"))

# Model accounting for clustering using GEE
model_SpWR_gee <- geeglm(Y_ik ~ T_k + Z1_k_vmmc,
                         family = binomial(link = "logit"),
                         id = cluster_id,
                         data = modelDat_SpW,
                         corstr = "exchangeable") # working correlation
```

```{r, echo = FALSE}
# GlM Model
model_SpWR_summary <- summary(model_SpWR) # Save model summary

exp_beta_SpWR_0 <- exp(model_SpWR_summary$coefficients[1,1]) # Intercept
exp_beta_SpWR_1 <- exp(model_SpWR_summary$coefficients[2,1]) # T_k Coefficient
exp_beta_SpWR_2 <- exp(model_SpWR_summary$coefficients[3,1]) # Z1_k_vmmc Coefficient

tidy_SpWR <- broom::tidy(model_SpWR, conf.int = TRUE, exponentiate = TRUE) %>%
  dplyr::select(term, estimate, std.error, p.value, conf.low, conf.high) %>%
  mutate(Model = "GLM",
         Term = term,
         `OR [95% CI]` = paste0(round(estimate, 3), " [", 
                            round(conf.low, 3), ", ", 
                            round(conf.high, 3), "]"),
         `p-value` = round(p.value, 3)) %>%
  dplyr::select(Model, Term, `OR [95% CI]`, `p-value`) %>%
  dplyr::filter(Term != "(Intercept)") %>%
  mutate(ICC = NA)

# GLMM Model
model_SpWR_summary_glmm <- summary(model_SpWR_glmm) # Save model summary
exp_beta_SpWR_0_glmm <- exp(model_SpWR_summary_glmm$coefficients[1,1]) # Intercept
exp_beta_SpWR_1_glmm <- exp(model_SpWR_summary_glmm$coefficients[2,1]) # T_k Coefficient
exp_beta_SpWR_2_glmm <- exp(model_SpWR_summary_glmm$coefficients[3,1]) # Z1_k_vmmc Coefficient

tidy_SpWR_glmm <- broom.mixed::tidy(model_SpWR_glmm, effects = "fixed", 
                  conf.int = TRUE, exponentiate = TRUE) %>%
  dplyr::select(term, estimate, std.error, p.value, conf.low, conf.high) %>%
  mutate(Model = "GLMM",
         Term = term,
         `OR [95% CI]` = paste0(round(estimate, 3), " [", 
                            round(conf.low, 3), ", ", 
                            round(conf.high, 3), "]"),
         `p-value` = round(p.value, 3)) %>%
  dplyr::select(Model, Term, `OR [95% CI]`, `p-value`) %>%
  dplyr::filter(Term != "(Intercept)") %>%
  mutate(ICC = c(round(performance::icc(model_SpW_glmm)$ICC_adjusted[[1]], 3), NA))

# GEE Model
model_SpWR_summary_gee <- summary(model_SpWR_gee) # Save model summary

exp_beta_SpWR_0_gee <- exp(model_SpWR_summary_gee$coefficients[1,1]) # Intercept
exp_beta_SpWR_1_gee <- exp(model_SpWR_summary_gee$coefficients[2,1]) # T_k Coefficient
exp_beta_SpWR_2_gee <- exp(model_SpWR_summary_gee$coefficients[3,1]) # Z1_k_vmmc Coefficient

tidy_SpWR_gee <- broom::tidy(model_SpWR_gee, conf.int = TRUE, 
                            exponentiate = TRUE) %>%
  dplyr::select(term, estimate, std.error, p.value, conf.low, conf.high) %>%
  mutate(Model = "GEE",
         Term = term,
         `OR [95% CI]` = paste0(round(estimate, 3), " [", 
                            round(conf.low, 3), ", ", 
                            round(conf.high, 3), "]"),
         `p-value` = round(p.value, 3)) %>%
  dplyr::select(Model, Term, `OR [95% CI]`, `p-value`) %>%
  dplyr::filter(Term != "(Intercept)") %>%
  mutate(ICC = c(round(model_SpWR_gee$geese$alpha[[1]], 3), NA))

# Overall Output Table for SpW
SpWR_Model_Table <- rbind(tidy_SpWR, tidy_SpWR_glmm) %>%
  rbind(tidy_SpWR_gee)
```

```{r, results = 'asis', echo = FALSE}
print(xtable(SpWR_Model_Table, 
             caption = "Spillover Not Due to Male Circumcision Model Output"), 
      type = 'latex', include.rownames = FALSE, comment = FALSE)
```

After we hold village circumcision coverage fixed, untreated residence of CP villages will still have a `r (1 - round(exp_beta_SpWR_1, 2))*100`% lower odds of seroconversion than untreated residence of control villages. This is spillover that operates through pathways other than male-circumcision coverage (e.g. HTC uptake, general behavior change, program outreach). 

Then, moving from a 0% to 100% male circumcised coverage in a village multiplies an untreated person's odds of seroconversion by `r round(exp_beta_SpWR_2, 2)`. This means `r (1 - round(exp_beta_SpWR_2, 2))*100`% lower odds of HIV acquisition for an untreated person when their village goes from zero to complete male-circumcision coverage.  

\newpage

### D. Proportion of Within-Intervention Village Spillover Effect Mediated by Circumcision

Then, the proportion of within-intervention village spillover effect mediated by circumcision is

$$\frac{\beta_1^{\text{SpW}} - \beta_1^{\text{SpWR}}}{\beta_1^{\text{SpW}}}$$

Essentially, this is the total spillover minus the spillover that exists except through the circumcision component, divided by spillover total. 

```{r, include = FALSE}
# Proportion of within-intervention village spillover effect mediated by MC
proportion_SpW <- tibble(Model = c("GLM", "GLMM", "GEE"),
                         `Proportion of Spillover Mediated by MC` = c((log(exp_beta_SpW_1) - log(exp_beta_SpWR_1)) / log(exp_beta_SpW_1),
                                                                      (log(exp_beta_SpW_1_glmm) - log(exp_beta_SpWR_1_glmm)) / log(exp_beta_SpW_1_glmm),
                                                                      (log(exp_beta_SpW_1_gee) - log(exp_beta_SpWR_1_gee)) / log(exp_beta_SpW_1_gee))) %>%
  mutate(`95 CI` = c("(0.003, 0.189)", "(0.003, 0.188)", "(0.004, 0.187)"))
```

```{r, results = 'asis', echo = FALSE}
print(xtable(proportion_SpW, 
             caption = "Proportion of Within-Cluster Spillover Due to Male Circumcision"), 
      type = 'latex', include.rownames = FALSE, comment = FALSE)
```

Thus, about `r round((log(exp_beta_SpW_1) - log(exp_beta_SpWR_1)) / log(exp_beta_SpW_1), 2)*100`% of within-village spillover protection experienced by untreated people in CP villages is explained by the higher male-circumcision coverage in those villages. The remaining spillover benefit must come through other village-level channels (e.g. HTC uptake, community health behavior change, program outreach, etc.)

#### Calculating the Confidence Interval for Proportion Mediated

Delta Method: First-order Taylor approximation for the variance of a smooth function $g(\hat{\theta})$ of estimators, where 
$$\text{Var} \left\{ g(\hat{\theta}) \right\} \approx \nabla g(\hat{\theta})^T \hat{\text{Var}}(\hat{\theta}) \nabla g(\hat{\theta})$$
where $\nabla g$ is the gradient of $g$ with respects to $\theta$ evaluated at the estimates.

To simplify notation, let $a = \beta_1^{\text{SpW}}$ and $c = \beta_1^{\text{SpWR}}$. On the log-odds scale, the proportion of spillover mediated by VMMC is
$$\text{PSM} = \frac{a - c}{a} = 1 - \frac{c}{a}$$

Using the Delta Method, define $g(a, c) = 1 - \frac{c}{a}$. The gradient at $(a, c)$ is
$$\nabla g(a, c) = \left( \frac{c}{a^2}, -\frac{1}{a} \right)$$

Let $\theta = (a, c)^T$ and let $\Sigma = \text{Var}(\hat{\theta})$ be the joint $2 \times 2$ covariance matrix of $(\hat{a}, \hat{c})$. The delta-method variance of $\hat{\text{PSM}} = g(\hat{a}, \hat{c})$ is
$$\text{Var}(\hat{\text{PSM}}) \approx \nabla g(\hat{a}, \hat{c})^T \Sigma \nabla g(\hat{a}, \hat{c})$$

Expanding the quadratic form gives the following form:
$$\text{Var}(\hat{\text{PSM}}) \approx \frac{c^2}{a^4} \text{Var}(\hat{a}) + \frac{1}{a^2} \text{Var}(\hat{c}) - \frac{2c}{a^3} \text{Cov}(\hat{a}, \hat{c})$$

and the normal-approximation CI is
$$\hat{\text{PSM}} \pm z_{1-\alpha/2} \sqrt{\text{Var}(\hat{\text{PSM}})}$$

In each bootstrap $b$, we can refit the models on the same resampled clusters to get $(\hat{a}^{(c)}, \hat{c}^{(b)})$, and then
$$\hat{\Sigma} = \text{Cov}_{\text{boot}}(\hat{a}^{(b)}, \hat{c}^{(b)})$$

GLM CI for PSM

```{r, echo = FALSE, include = FALSE}
# ------------------------------------------------------------
# Spillover proportion mediated (GLM) with cluster bootstrap + delta CI
#   SpW  model:  Y_ik ~ T_k
#   SpWR model:  Y_ik ~ T_k + Z1_k_vmmc
#
# PM_spill = (a - c) / a = 1 - c/a,
#   where a = beta_T from SpW, c = beta_T from SpWR (logit scale).
#
# Bootstrap design (no penalization):
#   * Resample clusters with replacement (size = # unique clusters)
#   * Force-in ALL clusters with any Y_ik = 1 at least once (stability)
#   * Stratify by treatment so treated/control cluster counts match original
#   * Allow event clusters to be drawn again in the fill step (adds variability)
#
# Returns point estimate, percentile CI for PM, and delta-method CI using
# the bootstrapped joint covariance of (a, c). Plain glm() with higher maxit.
# ------------------------------------------------------------
pm_spill_boot_with_delta_glm <- function(dat, id = "cluster_id",
                                         B = 1000, level = 0.95,
                                         force_event_once = TRUE,
                                         allow_dup_events = TRUE,
                                         seed = NULL, verbose = TRUE) {
  if (!is.null(seed)) set.seed(seed)
  stopifnot(is.data.frame(dat))

  # --- sanity: required columns
  req <- c(id, "Y_ik", "T_k", "Z1_k_vmmc")
  miss <- setdiff(req, names(dat))
  if (length(miss)) stop("Missing columns: ", paste(miss, collapse = ", "))

  # --- formulas
  f_SpW  <- stats::as.formula("Y_ik ~ T_k")
  f_SpWR <- stats::as.formula("Y_ik ~ T_k + Z1_k_vmmc")

  # --- cluster-level treatment & event flags
  cl_T <- tapply(dat$T_k, dat[[id]], function(x) {
    u <- unique(x); if (length(u) == 1) u else as.numeric(mean(x, na.rm = TRUE) >= 0.5)
  })
  cl_event <- tapply(dat$Y_ik, dat[[id]], function(y) any(y == 1, na.rm = TRUE))

  cl_t1 <- names(cl_T)[cl_T == 1]
  cl_t0 <- names(cl_T)[cl_T == 0]
  n1 <- length(cl_t1); n0 <- length(cl_t0)

  evt_t1 <- intersect(cl_t1, names(cl_event)[cl_event])
  evt_t0 <- intersect(cl_t0, names(cl_event)[cl_event])

  # pools to fill from (optionally include event clusters again)
  pool_t1 <- if (allow_dup_events) cl_t1 else setdiff(cl_t1, evt_t1)
  pool_t0 <- if (allow_dup_events) cl_t0 else setdiff(cl_t0, evt_t0)

  # helper: draw one set of cluster IDs (stratified; force-in events)
  make_sample_ids <- function() {
    base <- if (force_event_once) c(evt_t1, evt_t0) else character(0)
    fill_t1 <- if (n1 - length(evt_t1) > 0) sample(pool_t1, n1 - length(evt_t1), replace = TRUE) else character(0)
    fill_t0 <- if (n0 - length(evt_t0) > 0) sample(pool_t0, n0 - length(evt_t0), replace = TRUE) else character(0)
    c(base, fill_t1, fill_t0)
  }

  # --- point estimates on full data
  ctrl <- stats::glm.control(maxit = 50)
  fit_SpW  <- stats::glm(f_SpW,  family = stats::binomial(), data = dat, control = ctrl)
  fit_SpWR <- stats::glm(f_SpWR, family = stats::binomial(), data = dat, control = ctrl)

  a0 <- unname(stats::coef(fit_SpW )["T_k"])     # beta_T from SpW
  c0 <- unname(stats::coef(fit_SpWR)["T_k"])     # beta_T from SpWR

  PM0 <- if (is.finite(a0) && abs(a0) > .Machine$double.eps) 1 - c0/a0 else NA_real_

  # --- bootstrap draws: store theta = (a, c) and PM
  theta <- matrix(NA_real_, nrow = B, ncol = 2, dimnames = list(NULL, c("a","c")))
  PM    <- rep(NA_real_, B)
  if (verbose) msg_every <- max(1, floor(B/10))

  for (b in seq_len(B)) {
    samp_ids <- make_sample_ids()
    boot_dat <- do.call(rbind, lapply(samp_ids, function(k) dat[dat[[id]] == k, , drop = FALSE]))

    fitW  <- suppressWarnings(stats::glm(f_SpW,  family = stats::binomial(), data = boot_dat, control = ctrl))
    fitWR <- suppressWarnings(stats::glm(f_SpWR, family = stats::binomial(), data = boot_dat, control = ctrl))

    a <- suppressWarnings(unname(stats::coef(fitW )["T_k"]))
    c <- suppressWarnings(unname(stats::coef(fitWR)["T_k"]))

    if (all(is.finite(c(a, c)))) {
      theta[b, ] <- c(a = a, c = c)
      PM[b] <- if (abs(a) > .Machine$double.eps) 1 - c/a else NA_real_
    } else {
      PM[b] <- NA_real_
    }

    if (verbose && b %% msg_every == 0) message("bootstrap: ", b, "/", B)
  }

  # --- percentile CI for PM (pure bootstrap)
  alpha <- (1 - level)/2
  ci_boot <- stats::quantile(PM, probs = c(alpha, 1 - alpha), na.rm = TRUE)

  # --- delta-method CI using bootstrapped joint covariance of (a, c)
  # gradient of g(a,c)=1 - c/a    (g/a, g/c) = (c/a^2,  -1/a)
  if (is.finite(PM0) && abs(a0) > .Machine$double.eps) {
    g1 <-  c0 / (a0^2)
    g2 <- -1  /  a0
    grad <- c(g1, g2)

    Sigma_hat <- stats::cov(theta, use = "pairwise.complete.obs")  # 2x2 joint cov of (a,c)
    var_PM    <- as.numeric(t(grad) %*% Sigma_hat %*% grad)
    se_PM     <- sqrt(var_PM)
    z         <- stats::qnorm(1 - alpha)
    ci_delta  <- PM0 + c(-1, 1) * z * se_PM
  } else {
    ci_delta <- c(NA_real_, NA_real_)
  }

  list(
    point_PM      = PM0,
    ci_boot_PM    = ci_boot,
    ci_delta_PM   = ci_delta,
    boot_draws_PM = PM,
    boot_theta    = theta,               # columns: a, c
    Sigma_hat     = if (exists("Sigma_hat")) Sigma_hat else NULL,
    settings      = list(B = B, level = level,
                         force_event_once = force_event_once,
                         allow_dup_events  = allow_dup_events)
  )
}

```

```{r, echo = FALSE, include = FALSE, eval = FALSE}
set.seed(123)
res_sp_glm <- pm_spill_boot_with_delta_glm(modelDat_SpW, id = "cluster_id",
                                           B = 1000, verbose = TRUE)
res_sp_glm$point_PM
res_sp_glm$ci_boot_PM
res_sp_glm$ci_delta_PM
```


GLMM CI for PSM

```{r, echo = FALSE, include = FALSE}
# ------------------------------------------------------------
# Spillover proportion mediated (GLMM) with cluster bootstrap + delta CI
#   SpW  (GLMM):  Y_ik ~ T_k + (1 | cluster_id)
#   SpWR (GLMM):  Y_ik ~ T_k + Z1_k_vmmc + (1 | cluster_id)
#
# PM_spill = (a - c) / a = 1 - c/a,
#   where a = beta_T from SpW, c = beta_T from SpWR (logit scale).
#
# Bootstrap design (no penalization):
#   * Resample clusters with replacement (size = # unique clusters)
#   * Force-in ALL clusters with any Y_ik = 1 at least once (stability)
#   * Stratify by treatment so treated/control cluster counts match original
#   * For GLMM, duplicate draws are given NEW random-effect labels (.boot_id)
#
# Returns: PM point estimate, percentile CI, delta-method CI using boot Sigma.
# ------------------------------------------------------------
pm_spill_boot_with_delta_glmm <- function(dat, id = "cluster_id",
                                          B = 500, level = 0.95,
                                          force_event_once = TRUE,
                                          allow_dup_events = TRUE,
                                          seed = NULL, verbose = TRUE) {
  if (!is.null(seed)) set.seed(seed)
  if (!requireNamespace("lme4", quietly = TRUE)) {
    stop("Package 'lme4' is required. Please install it.")
  }
  stopifnot(is.data.frame(dat))
  req <- c(id, "Y_ik", "T_k", "Z1_k_vmmc")
  miss <- setdiff(req, names(dat))
  if (length(miss)) stop("Missing columns: ", paste(miss, collapse = ", "))

  # --- GLMM controls (help convergence a bit)
  ctrl <- lme4::glmerControl(optimizer = "bobyqa",
                             optCtrl = list(maxfun = 2e5),
                             check.conv.grad = "ignore",
                             check.conv.singular = "ignore")

  # --- Full-data fits -> point estimates
  fW_full  <- stats::as.formula(paste0("Y_ik ~ T_k + (1|", id, ")"))
  fWR_full <- stats::as.formula(paste0("Y_ik ~ T_k + Z1_k_vmmc + (1|", id, ")"))

  fitW  <- suppressWarnings(lme4::glmer(fW_full,  family = stats::binomial(), data = dat, control = ctrl))
  fitWR <- suppressWarnings(lme4::glmer(fWR_full, family = stats::binomial(), data = dat, control = ctrl))

  a0 <- as.numeric(lme4::fixef(fitW )["T_k"])   # beta_T from SpW
  c0 <- as.numeric(lme4::fixef(fitWR)["T_k"])   # beta_T from SpWR

  PM0 <- if (is.finite(a0) && abs(a0) > .Machine$double.eps) 1 - c0/a0 else NA_real_

  # --- Cluster-level treatment & event flags for stratified resampling
  cl_T <- tapply(dat$T_k, dat[[id]], function(x) {
    u <- unique(x); if (length(u) == 1) u else as.numeric(mean(x, na.rm = TRUE) >= 0.5)
  })
  cl_event <- tapply(dat$Y_ik, dat[[id]], function(y) any(y == 1, na.rm = TRUE))

  cl_t1 <- names(cl_T)[cl_T == 1];  cl_t0 <- names(cl_T)[cl_T == 0]
  n1 <- length(cl_t1);              n0 <- length(cl_t0)

  evt_t1 <- intersect(cl_t1, names(cl_event)[cl_event])
  evt_t0 <- intersect(cl_t0, names(cl_event)[cl_event])

  pool_t1 <- if (allow_dup_events) cl_t1 else setdiff(cl_t1, evt_t1)
  pool_t0 <- if (allow_dup_events) cl_t0 else setdiff(cl_t0, evt_t0)

  # --- Build one bootstrap dataset with new random-effect IDs
  make_boot_df <- function() {
    base    <- if (force_event_once) c(evt_t1, evt_t0) else character(0)
    fill_t1 <- if (n1 - length(evt_t1) > 0) sample(pool_t1, n1 - length(evt_t1), replace = TRUE) else character(0)
    fill_t0 <- if (n0 - length(evt_t0) > 0) sample(pool_t0, n0 - length(evt_t0), replace = TRUE) else character(0)
    samp_ids <- c(base, fill_t1, fill_t0)

    parts <- vector("list", length(samp_ids))
    for (j in seq_along(samp_ids)) {
      k <- samp_ids[j]
      d <- dat[dat[[id]] == k, , drop = FALSE]
      d[[".boot_id"]] <- paste0("C", j, "_", k)   # NEW random-effect label for this copy
      parts[[j]] <- d
    }
    out <- do.call(rbind, parts)
    out[[".boot_id"]] <- factor(out[[".boot_id"]])
    out
  }

  # --- Bootstrap storage
  theta <- matrix(NA_real_, nrow = B, ncol = 2, dimnames = list(NULL, c("a","c")))
  PM     <- rep(NA_real_, B)
  if (verbose) msg_every <- max(1, floor(B/10))

  # --- GLMM formulas using .boot_id as grouping factor
  fW_boot  <- stats::as.formula("Y_ik ~ T_k + (1|.boot_id)")
  fWR_boot <- stats::as.formula("Y_ik ~ T_k + Z1_k_vmmc + (1|.boot_id)")

  for (b in seq_len(B)) {
    boot_dat <- make_boot_df()

    fitWb  <- try(suppressWarnings(lme4::glmer(fW_boot,  family = stats::binomial(), data = boot_dat, control = ctrl)), silent = TRUE)
    fitWRb <- try(suppressWarnings(lme4::glmer(fWR_boot, family = stats::binomial(), data = boot_dat, control = ctrl)), silent = TRUE)

    if (!inherits(fitWb, "try-error") && !inherits(fitWRb, "try-error")) {
      feW  <- try(lme4::fixef(fitWb),  silent = TRUE)
      feWR <- try(lme4::fixef(fitWRb), silent = TRUE)
      if (!inherits(feW, "try-error") && !inherits(feWR, "try-error")) {
        a <- as.numeric(feW ["T_k"])
        c <- as.numeric(feWR["T_k"])
        if (all(is.finite(c(a, c)))) {
          theta[b, ] <- c(a = a, c = c)
          PM[b] <- if (abs(a) > .Machine$double.eps) 1 - c/a else NA_real_
        }
      }
    }

    if (verbose && b %% msg_every == 0) message("bootstrap: ", b, "/", B)
  }

  # --- Percentile CI for PM (pure bootstrap)
  alpha   <- (1 - level) / 2
  ci_boot <- stats::quantile(PM, probs = c(alpha, 1 - alpha), na.rm = TRUE)

  # --- Delta-method CI using bootstrapped joint covariance of (a, c)
  if (is.finite(PM0) && abs(a0) > .Machine$double.eps) {
    g1 <-  c0 / (a0^2)      # PM/a
    g2 <- -1  /  a0         # PM/c
    grad <- c(g1, g2)

    Sigma_hat <- stats::cov(theta, use = "pairwise.complete.obs")  # 2x2 cov of (a,c)
    var_PM    <- as.numeric(t(grad) %*% Sigma_hat %*% grad)
    se_PM     <- sqrt(var_PM)
    z         <- stats::qnorm(1 - alpha)
    ci_delta  <- PM0 + c(-1, 1) * z * se_PM
  } else {
    Sigma_hat <- NULL
    ci_delta  <- c(NA_real_, NA_real_)
  }

  list(
    point_PM      = PM0,
    ci_boot_PM    = ci_boot,
    ci_delta_PM   = ci_delta,
    boot_draws_PM = PM,
    boot_theta    = theta,   # columns: a (SpW T_k), c (SpWR T_k)
    Sigma_hat     = Sigma_hat,
    settings      = list(B = B, level = level,
                         force_event_once = force_event_once,
                         allow_dup_events  = allow_dup_events,
                         optimizer = "bobyqa", maxfun = 2e5)
  )
}
```

```{r, eval = FALSE, include = FALSE, eval = FALSE}
set.seed(123)
res_sp_glmm <- pm_spill_boot_with_delta_glmm(modelDat_SpW, id = "cluster_id",
                                             B = 400, verbose = TRUE)
res_sp_glmm$point_PM
res_sp_glmm$ci_boot_PM
res_sp_glmm$ci_delta_PM
```


GEE CI for PSM

```{r, echo = FALSE, include = FALSE}
# ------------------------------------------------------------
# Spillover proportion mediated (GEE) with cluster bootstrap + delta CI
#   SpW  (GEE):  Y_ik ~ T_k
#   SpWR (GEE):  Y_ik ~ T_k + Z1_k_vmmc
#
# PM_spill = (a - c) / a = 1 - c/a,
#   where a = beta_T from SpW, c = beta_T from SpWR (logit scale).
#
# Bootstrap design (no penalties):
#   * Resample clusters with replacement (size = # unique clusters)
#   * Force-in ALL clusters with any Y_ik = 1 at least once (stability)
#   * Stratify by treatment so treated/control cluster counts match original
#   * For GEE, duplicate draws get NEW IDs (.boot_id) so they are separate
#     working-correlation groups in each replicate.
# Returns: PM point estimate, percentile CI, delta-method CI using boot Sigma.
# ------------------------------------------------------------
pm_spill_boot_with_delta_gee <- function(dat, id = "cluster_id",
                                         B = 1000, level = 0.95,
                                         corstr = "exchangeable",
                                         force_event_once = TRUE,
                                         allow_dup_events = TRUE,
                                         seed = NULL, verbose = TRUE) {
  if (!is.null(seed)) set.seed(seed)
  if (!requireNamespace("geepack", quietly = TRUE)) {
    stop("Package 'geepack' is required. Please install it.")
  }
  stopifnot(is.data.frame(dat))
  req <- c(id, "Y_ik", "T_k", "Z1_k_vmmc")
  miss <- setdiff(req, names(dat))
  if (length(miss)) stop("Missing columns: ", paste(miss, collapse = ", "))

  # --- Formulas
  fW  <- stats::as.formula("Y_ik ~ T_k")                 # SpW
  fWR <- stats::as.formula("Y_ik ~ T_k + Z1_k_vmmc")     # SpWR

  # --- Point estimates (full data, original IDs)
  id_full <- dat[[id]]
  fitW  <- suppressWarnings(geepack::geeglm(fW,  id = id_full, data = dat,
                                            family = stats::binomial(), corstr = corstr))
  fitWR <- suppressWarnings(geepack::geeglm(fWR, id = id_full, data = dat,
                                            family = stats::binomial(), corstr = corstr))

  a0 <- as.numeric(stats::coef(fitW )["T_k"])   # beta_T from SpW
  c0 <- as.numeric(stats::coef(fitWR)["T_k"])   # beta_T from SpWR
  PM0 <- if (is.finite(a0) && abs(a0) > .Machine$double.eps) 1 - c0/a0 else NA_real_

  # --- Cluster-level treatment & event flags for stratified resampling
  cl_T <- tapply(dat$T_k, dat[[id]], function(x) {
    u <- unique(x); if (length(u) == 1) u else as.numeric(mean(x, na.rm = TRUE) >= 0.5)
  })
  cl_event <- tapply(dat$Y_ik, dat[[id]], function(y) any(y == 1, na.rm = TRUE))

  cl_t1 <- names(cl_T)[cl_T == 1];  cl_t0 <- names(cl_T)[cl_T == 0]
  n1 <- length(cl_t1);              n0 <- length(cl_t0)

  evt_t1 <- intersect(cl_t1, names(cl_event)[cl_event])
  evt_t0 <- intersect(cl_t0, names(cl_event)[cl_event])

  pool_t1 <- if (allow_dup_events) cl_t1 else setdiff(cl_t1, evt_t1)
  pool_t0 <- if (allow_dup_events) cl_t0 else setdiff(cl_t0, evt_t0)

  # --- One bootstrap dataset with NEW GEE IDs
  make_boot_df <- function() {
    base    <- if (force_event_once) c(evt_t1, evt_t0) else character(0)
    fill_t1 <- if (n1 - length(evt_t1) > 0) sample(pool_t1, n1 - length(evt_t1), replace = TRUE) else character(0)
    fill_t0 <- if (n0 - length(evt_t0) > 0) sample(pool_t0, n0 - length(evt_t0), replace = TRUE) else character(0)
    samp_ids <- c(base, fill_t1, fill_t0)

    parts <- vector("list", length(samp_ids))
    for (j in seq_along(samp_ids)) {
      k <- samp_ids[j]
      d <- dat[dat[[id]] == k, , drop = FALSE]
      d[[".boot_id"]] <- paste0("G", j, "_", k)  # unique working-corr group
      parts[[j]] <- d
    }
    out <- do.call(rbind, parts)
    out[[".boot_id"]] <- factor(out[[".boot_id"]])
    out
  }

  # --- Bootstrap storage
  theta <- matrix(NA_real_, nrow = B, ncol = 2, dimnames = list(NULL, c("a","c")))
  PM     <- rep(NA_real_, B)
  if (verbose) msg_every <- max(1, floor(B/10))

  for (b in seq_len(B)) {
    boot_dat <- make_boot_df()
    idB <- boot_dat[[".boot_id"]]

    fitWb  <- try(suppressWarnings(
      geepack::geeglm(fW,  id = idB, data = boot_dat, family = stats::binomial(), corstr = corstr)
    ), silent = TRUE)
    fitWRb <- try(suppressWarnings(
      geepack::geeglm(fWR, id = idB, data = boot_dat, family = stats::binomial(), corstr = corstr)
    ), silent = TRUE)

    if (!inherits(fitWb, "try-error") && !inherits(fitWRb, "try-error")) {
      a <- suppressWarnings(as.numeric(stats::coef(fitWb )["T_k"]))
      c <- suppressWarnings(as.numeric(stats::coef(fitWRb)["T_k"]))
      if (all(is.finite(c(a, c)))) {
        theta[b, ] <- c(a = a, c = c)
        PM[b] <- if (abs(a) > .Machine$double.eps) 1 - c/a else NA_real_
      } else {
        PM[b] <- NA_real_
      }
    } else {
      PM[b] <- NA_real_
    }

    if (verbose && b %% msg_every == 0) message("bootstrap: ", b, "/", B)
  }

  # --- Percentile CI for PM (pure bootstrap)
  alpha   <- (1 - level)/2
  ci_boot <- stats::quantile(PM, probs = c(alpha, 1 - alpha), na.rm = TRUE)

  # --- Delta-method CI using bootstrapped joint covariance of (a, c)
  if (is.finite(PM0) && abs(a0) > .Machine$double.eps) {
    g1 <-  c0 / (a0^2)   # PM/a
    g2 <- -1  /  a0      # PM/c
    grad <- c(g1, g2)

    Sigma_hat <- stats::cov(theta, use = "pairwise.complete.obs")  # 2x2 cov of (a,c)
    var_PM    <- as.numeric(t(grad) %*% Sigma_hat %*% grad)
    se_PM     <- sqrt(var_PM)
    z         <- stats::qnorm(1 - alpha)
    ci_delta  <- PM0 + c(-1, 1) * z * se_PM
  } else {
    Sigma_hat <- NULL
    ci_delta  <- c(NA_real_, NA_real_)
  }

  list(
    point_PM      = PM0,
    ci_boot_PM    = ci_boot,
    ci_delta_PM   = ci_delta,
    boot_draws_PM = PM,
    boot_theta    = theta,     # columns: a (SpW T_k), c (SpWR T_k)
    Sigma_hat     = Sigma_hat,
    settings      = list(B = B, level = level, corstr = corstr,
                         force_event_once = force_event_once,
                         allow_dup_events  = allow_dup_events)
  )
}

```

```{r, echo = FALSE, include = FALSE, eval = FALSE}
set.seed(123)
res_sp_gee <- pm_spill_boot_with_delta_gee(modelDat_SpW, id = "cluster_id",
                                           B = 300, corstr = "exchangeable")
res_sp_gee$point_PM
res_sp_gee$ci_boot_PM
res_sp_gee$ci_delta_PM
```



\newpage

## Individual Effects

\underline{Setup}

- In this analysis, we include only males in the study.

- Here, we will estimate the effects of the intervention assignment on the outcome. In the mediation model, we will account for if they actually received the circumcision component or not.

- This setup will allow us to estimate

    d. Total Individual Effect of Treatment Assignment
    e. Individual Direct Effects of Treatment Assignment
    f. Indirect Individual Effect of Treatment Assignment
    g. Proportion of Individual Effect of Treatment Assignment Mediated by Circumcision

```{r}
# Alternative to fix data availability
  # Include only those who were circumcised in the treatment
  # Include everyone in the control
modelDat_Ind <- modelDat %>%
  filter(gender == "Male") %>%
  filter(!is.na(X1_ik_vmmc))
```

The total sample size for this analysis is `r nrow(modelDat_Ind)`, meaning that `r nrow(modelDat) - nrow(modelDat_Ind)` individuals are excluded (`r nrow(filter(modelDat, gender == "Female"))` females and `r nrow(filter(modelDat, is.na(X1_ik_vmmc)))` with missing data for VMMC).

\underline{Data Characteristics}

```{r, include = FALSE}
var_order_Ind <- c("Gender", "HIV Status at Start", "Treatment Component: MC",
                   "Treatment Component: VMMC",
                    "Treatment Component: HTC", "Treatment Component: Full",
                    "Outcome: HIV Seroconversion (3-year period)")
level_order_Ind <- c("Male", "Yes", "No", "Began study circumcised", "Female",
                      "HIV-uninfected", "HIV-infected", "Refused HIV testing",
                      "Began study HIV-infected")

baseline_Ind <- modelDat_Ind %>%
  mutate(endpoint_coverage_vmmc = ifelse(endpoint_coverage_mc == "Yes", "Yes", 
                       ifelse(endpoint_coverage_mc %in% c("Began study circumcised", "No"), "No",
                              ifelse(endpoint_coverage_mc == "Female", "Female", NA)))) %>%
  dplyr::select(`Treatment Group` = random_arm,
                `Cluster Size` = cluster_size,
                `Gender` = gender,
                `HIV Status at Start` = hiv_status_current,
                `Treatment Component: MC` = endpoint_coverage_mc,
                `Treatment Component: VMMC` = endpoint_coverage_vmmc,
                `Treatment Component: HTC` = endpoint_coverage_htc,
                `Treatment Component: Full` = endpoint_coverage_full,
                `Outcome: HIV Seroconversion (3-year period)` = endpoint_seroconvert) %>%
  mutate(across(
    where(~ !is.numeric(.x)),
    ~ ifelse(is.na(.x), "Missing", as.character(.x))
  ))

# baseline_missing_Ind <- baseline_Ind %>%
#   dplyr::select(-`Cluster Size`) %>%
#   filter(if_any(everything(), ~ .x == "Missing")) %>%
#   mutate(across(
#     .cols = -c(`Treatment Group`),  # replace col1 and col2 with your actual column names
#     .fns = ~ if_else(.x == "Missing", 1, 0)
#   )) %>%
#   group_by(`Treatment Group`) %>%
#   summarise(across(
#     everything(),  # No need to exclude the grouping var here
#     sum,
#     .names = "{.col}"
#   )) %>%
#   dplyr::select(-Gender) %>%
#   ungroup() %>%
#   pivot_longer(
#     cols = -`Treatment Group`,  # gather all variables except the group
#     names_to = "Variable",
#     values_to = "Missing"
#   ) %>%
#   pivot_wider(
#     names_from = `Treatment Group`,
#     values_from = Missing
#   ) %>%
#   mutate(Overall = Control + Treatment) %>%
#   rename(`Missing (Control)` = Control,
#          `Missing (Treatment)` = Treatment,
#          `Missing (Overall)` = Overall)

cluster_size_Ind <- tibble(Variable = c("Number of Individuals", 
                                    "Number of Clusters", 
                                    "Mean Cluster Size"),
                       Level = c(NA, NA, NA),
                       Control = c(nrow(dplyr::filter(modelDat_Ind, random_arm == "Control")),
                                   length(unique(dplyr::filter(modelDat_Ind, random_arm == "Control")$cluster_id)),
                                   mean(filter(modelDat_Ind, random_arm == "Control")$cluster_size)),
                       Treatment = c(nrow(dplyr::filter(modelDat_Ind, random_arm == "Treatment")),
                                     length(unique(dplyr::filter(modelDat_Ind, random_arm == "Treatment")$cluster_id)),
                                     mean(filter(modelDat_Ind, random_arm == "Treatment")$cluster_size))) %>%
  mutate(Control = as.integer(Control), Treatment = as.integer(Treatment)) %>%
  mutate(Overall = ifelse(Variable != "Mean Cluster Size", Treatment + Control, round((Treatment + Control) / 2, 1)))

baseline_tab_Ind <- baseline_Ind %>%
  dplyr::select(-`Cluster Size`) %>%
  pivot_longer(!`Treatment Group`, 
               names_to = "Variable", values_to = "Level") %>%
  arrange(`Treatment Group`, Variable, Level) %>%
  group_by(`Treatment Group`, Variable, Level) %>%
  dplyr::summarize(n = n()) %>%
  ungroup() %>%
  filter(Level != "Missing") %>%
  group_by(`Treatment Group`, `Variable`) %>%
  mutate(Overall = sum(n)) %>%
  ungroup() %>%
  rowwise() %>%
  mutate(percentage = paste0("(", round(n/Overall, 2)*100, "%)")) %>%
  mutate(n = paste(n, percentage)) %>%
  dplyr::select(-Overall, -percentage) %>%
  pivot_wider(
    names_from = `Treatment Group`,
    values_from = n
  ) %>%
  mutate(
    Overall = parse_number(Control) + parse_number(Treatment)
  ) %>%
  group_by(Variable) %>%
  mutate(Sum = sum(Overall)) %>%
  mutate(Overall = paste0(Overall, " (", round(Overall/Sum, 2)*100, "%)")) %>%
  dplyr::select(-Sum) %>%
  mutate(Variable = factor(Variable, levels = var_order_full),
         Level = factor(Level, levels = level_order_full)) %>%
  arrange(Variable, Level)

n_treat_Ind <- nrow(filter(modelDat_Ind, random_arm == "Treatment"))
n_control_Ind <- nrow(filter(modelDat_Ind, random_arm == "Control"))
n_overall_Ind <- nrow(modelDat_Ind)

final_baseline_Ind_table <- rbind(cluster_size_Ind, baseline_tab_Ind) %>%
  #left_join(baseline_missing_Ind, by = "Variable") %>%
  group_by(Variable) %>%
  mutate(
    Variable = if_else(row_number() == 1, Variable, NA_character_))
  #   `Missing (Control)` = if_else(row_number() == 1, `Missing (Control)`, NA_integer_),
  #   `Missing (Treatment)` = if_else(row_number() == 1, `Missing (Treatment)`, NA_integer_),
  #   `Missing (Overall)` = if_else(row_number() == 1, `Missing (Overall)`, NA_integer_)
  # ) %>%
  # ungroup() %>%
  # mutate(`Missing (Control)` = as.integer(`Missing (Control)`),
  #        `Missing (Treatment)` = as.integer(`Missing (Treatment)`),
  #        `Missing (Overall)` = as.integer(`Missing (Overall)`)) %>%
  # rowwise() %>%
  # mutate(`Missing (Control)` = ifelse(!is.na(`Missing (Control)`), 
  #                                     paste0(`Missing (Control)`, " (", 
  #                                            round(`Missing (Control)`/n_control_full, 2)*100, "%)"), NA),
  #        `Missing (Treatment)` = ifelse(!is.na(`Missing (Treatment)`), 
  #                                       paste0(`Missing (Treatment)`, " (", 
  #                                              round(`Missing (Treatment)`/n_treat_full, 2)*100, "%)"), NA),
  #        `Missing (Overall)` = ifelse(!is.na(`Missing (Overall)`), 
  #                                     paste0(`Missing (Overall)`, " (", 
  #                                            round(`Missing (Overall)`/n_overall_full, 2)*100, "%)"), NA)) %>%
  # mutate(`Missing (Control)` = ifelse(`Missing (Control)` == "0 (0%)", 
  #                                     NA, `Missing (Control)`),
  #        `Missing (Treatment)` = ifelse(`Missing (Treatment)` == "0 (0%)", 
  #                                     NA, `Missing (Treatment)`),
  #        `Missing (Overall)` = ifelse(`Missing (Overall)` == "0 (0%)", 
  #                                     NA, `Missing (Overall)`))

```

```{r, results = 'asis', echo = FALSE}
cat("\\begin{landscape}\n")

print(
  xtable(
    final_baseline_Ind_table,
    caption = "Characteristics of Individual Effects Analysis Data",
  ),
  type = "latex",
  include.rownames = FALSE,
  comment = FALSE
)

cat("\\end{landscape}\n")
```

The mediator model regresses the mediator on the exposure and confounders. Here, we block the spillover that exists through the proportion circumcised and proportion who received HTC in the cluster by controlling for it in the model (inclusion of $Z_k^{(1)}$ and $Z_k^{(2)}$ in the model). 

\newpage

### E. Mediator Model for Individual Effect of Treatment Assignment

"IndM" denotes individual effects, i.e. effects of a male's own treatment assignment on their own outcome. Here, we use the product method to calculate the direct and indirect effects, with the outcome being $Y_{ik}$, treatment being $T_k$, and mediator being $X_{ik}^{(1, \text{VMMC})}$, whether or not a male has VMMC. The abbreviation "IndM" refers to the individual effect mediator model, shown below.



$$logit(X_{ik}^{(1, \text{VMMC})}) = \beta_0^{\text{IndM}} + \beta_1^{\text{IndM}}(T_{k})$$

```{r, message = FALSE}
# Mediator Model for Individual Effect of Treatment Assignment

modelDat_Ind <- modelDat_Ind %>%
  mutate(X1_ik_vmmc = ifelse(X1_ik_vmmc == "Yes", 1, 
                             ifelse(X1_ik_vmmc == "No", 0, NA)))

# Model not accounting for clustering
model_IndM <- glm(X1_ik_vmmc ~ T_k,
                  family = binomial(link = 'logit'),
                  data = modelDat_Ind)

# Model accounting for clustering using GLMM
model_IndM_glmm <- glmer(X1_ik_vmmc ~ T_k + (1|cluster_id), # Uses exchangeable
                         data = modelDat_Ind,
                         family = binomial(link = "logit"))

# Model accounting for clustering using GEE
model_IndM_gee <- geeglm(X1_ik_vmmc ~ T_k,
                         family = binomial(link = "logit"),
                         id = cluster_id,
                         data = modelDat_Ind,
                         corstr = "exchangeable") # working correlation
```

```{r, echo = FALSE}
# GLM Model
model_IndM_summary <- summary(model_IndM) # Save model summary

exp_beta_IndM_0 <- exp(model_IndM_summary$coefficients[1,1]) # Intercept
exp_beta_IndM_1 <- exp(model_IndM_summary$coefficients[2,1]) # T_k Coefficient

tidy_IndM <- broom::tidy(model_IndM, conf.int = TRUE, exponentiate = TRUE) %>%
  dplyr::select(term, estimate, std.error, p.value, conf.low, conf.high) %>%
  mutate(Model = "GLM",
         Term = term,
         `OR [95% CI]` = paste0(round(estimate, 3), " [", 
                            round(conf.low, 3), ", ", 
                            round(conf.high, 3), "]"),
         `p-value` = round(p.value, 3)) %>%
  dplyr::select(Model, Term, `OR [95% CI]`, `p-value`) %>%
  dplyr::filter(Term != "(Intercept)") %>%
  mutate(ICC = NA)

# GLMM Model
model_IndM_summary_glmm <- summary(model_IndM_glmm) # Save model summary

exp_beta_IndM_0_glmm <- exp(model_IndM_summary_glmm$coefficients[1,1]) # Intercept
exp_beta_IndM_1_glmm <- exp(model_IndM_summary_glmm$coefficients[2,1]) # T_k Coefficient

tidy_IndM_glmm <- broom.mixed::tidy(model_IndM_glmm, effects = "fixed", 
                  conf.int = TRUE, exponentiate = TRUE) %>%
  dplyr::select(term, estimate, std.error, p.value, conf.low, conf.high) %>%
  mutate(Model = "GLMM",
         Term = term,
         `OR [95% CI]` = paste0(round(estimate, 3), " [", 
                            round(conf.low, 3), ", ", 
                            round(conf.high, 3), "]"),
         `p-value` = round(p.value, 3)) %>%
  dplyr::select(Model, Term, `OR [95% CI]`, `p-value`) %>%
  dplyr::filter(Term != "(Intercept)") %>%
  mutate(ICC = round(performance::icc(model_IndM_glmm)$ICC_adjusted[[1]], 3))

# GEE Model
model_IndM_summary_gee <- summary(model_IndM_gee) # Save model summary

exp_beta_IndM_0_gee <- exp(model_IndM_summary_gee$coefficients[1,1]) # Intercept
exp_beta_IndM_1_gee <- exp(model_IndM_summary_gee$coefficients[2,1]) # T_k Coefficient

tidy_IndM_gee <- broom::tidy(model_IndM_gee, conf.int = TRUE, 
                            exponentiate = TRUE) %>%
  dplyr::select(term, estimate, std.error, p.value, conf.low, conf.high) %>%
  mutate(Model = "GEE",
         Term = term,
         `OR [95% CI]` = paste0(round(estimate, 3), " [", 
                            round(conf.low, 3), ", ", 
                            round(conf.high, 3), "]"),
         `p-value` = round(p.value, 3)) %>%
  dplyr::select(Model, Term, `OR [95% CI]`, `p-value`) %>%
  dplyr::filter(Term != "(Intercept)") %>%
  mutate(ICC = round(model_IndM_gee$geese$alpha[[1]], 3))

# Overall Output Table for SpW
IndM_Model_Table <- rbind(tidy_IndM, tidy_IndM_glmm) %>%
  rbind(tidy_IndM_gee)
```

```{r, results = 'asis', echo = FALSE}
print(xtable(IndM_Model_Table, 
             caption = "Mediator Model for Individual Effects"), 
      type = 'latex', include.rownames = FALSE, comment = FALSE)
```


### F. Outcome Model for Individual Effect of Treatment Assignment

Now, we regress the outcome, $Y_{ik}$ on the treatment assignment $T_k$ and VMMC mediator $X_{ik}^{(1, \text{VMMC})}$. The abbreviation "IndO" refers to the individual effect outcome model, shown below.

$$logit(Y_{ik}) = \beta_0^{\text{IndO}} + \beta_1^{\text{IndO}}(T_{k}) + \beta_2^{\text{IndO}} (X_{ik}^{(1, \text{VMMC})})$$

```{r, warning = FALSE, message = FALSE}
# Outcome Model for Individual Effect of Treatment Assignment

# Model not accounting for clustering
model_IndO <- glm(Y_ik ~ T_k + X1_ik_vmmc,
                  family = binomial(link = 'logit'),
                  data = modelDat_Ind)

# Model accounting for clustering using GLMM
model_IndO_glmm <- glmer(Y_ik ~ T_k + X1_ik_vmmc + (1|cluster_id), # Uses exchangeable
                         data = modelDat_Ind,
                         family = binomial(link = "logit"))

# Model accounting for clustering using GEE
model_IndO_gee <- geeglm(Y_ik ~ T_k + X1_ik_vmmc,
                         family = binomial(link = "logit"),
                         id = cluster_id,
                         data = modelDat_Ind,
                         corstr = "exchangeable") # working correlation
```

```{r, echo = FALSE}
# GLM Model
model_IndO_summary <- summary(model_IndO) # Save model summary

exp_beta_IndO_0 <- exp(model_IndO_summary$coefficients[1,1]) # Intercept
exp_beta_IndO_1 <- exp(model_IndO_summary$coefficients[2,1]) # T_k Coefficient
exp_beta_IndO_2 <- exp(model_IndO_summary$coefficients[3,1]) # X1_vmmc Coefficient

tidy_IndO <- broom::tidy(model_IndO, conf.int = TRUE, exponentiate = TRUE) %>%
  dplyr::select(term, estimate, std.error, p.value, conf.low, conf.high) %>%
  mutate(Model = "GLM",
         Term = term,
         `OR [95% CI]` = paste0(round(estimate, 3), " [", 
                            round(conf.low, 3), ", ", 
                            round(conf.high, 3), "]"),
         `p-value` = round(p.value, 3)) %>%
  dplyr::select(Model, Term, `OR [95% CI]`, `p-value`) %>%
  dplyr::filter(Term != "(Intercept)") %>%
  mutate(ICC = NA)

# GLMM Model
model_IndO_summary_glmm <- summary(model_IndO_glmm) # Save model summary

exp_beta_IndO_0_glmm <- exp(model_IndO_summary_glmm$coefficients[1,1]) # Intercept
exp_beta_IndO_1_glmm <- exp(model_IndO_summary_glmm$coefficients[2,1]) # T_k Coefficient
exp_beta_IndO_2_glmm <- exp(model_IndO_summary_glmm$coefficients[3,1]) # X1_vmmc Coefficient

tidy_IndO_glmm <- broom.mixed::tidy(model_IndO_glmm, effects = "fixed", 
                  conf.int = TRUE, exponentiate = TRUE) %>%
  dplyr::select(term, estimate, std.error, p.value, conf.low, conf.high) %>%
  mutate(Model = "GLMM",
         Term = term,
         `OR [95% CI]` = paste0(round(estimate, 3), " [", 
                            round(conf.low, 3), ", ", 
                            round(conf.high, 3), "]"),
         `p-value` = round(p.value, 3)) %>%
  dplyr::select(Model, Term, `OR [95% CI]`, `p-value`) %>%
  dplyr::filter(Term != "(Intercept)") %>%
  mutate(ICC = round(performance::icc(model_IndO_glmm)$ICC_adjusted[[1]], 3))

# GEE Model
model_IndO_summary_gee <- summary(model_IndO_gee) # Save model summary

exp_beta_IndO_0_gee <- exp(model_IndO_summary_gee$coefficients[1,1]) # Intercept
exp_beta_IndO_1_gee <- exp(model_IndO_summary_gee$coefficients[2,1]) # T_k Coefficient
exp_beta_IndO_2_gee <- exp(model_IndO_summary_gee$coefficients[3,1]) # X1_vmmc Coefficient

tidy_IndO_gee <- broom::tidy(model_IndO_gee, conf.int = TRUE, 
                            exponentiate = TRUE) %>%
  dplyr::select(term, estimate, std.error, p.value, conf.low, conf.high) %>%
  mutate(Model = "GEE",
         Term = term,
         `OR [95% CI]` = paste0(round(estimate, 3), " [", 
                            round(conf.low, 3), ", ", 
                            round(conf.high, 3), "]"),
         `p-value` = round(p.value, 3)) %>%
  dplyr::select(Model, Term, `OR [95% CI]`, `p-value`) %>%
  dplyr::filter(Term != "(Intercept)") %>%
  mutate(ICC = abs(round(model_IndO_gee$geese$alpha[[1]], 3)))

# Overall Output Table for SpW
IndO_Model_Table <- rbind(tidy_IndO, tidy_IndO_glmm) %>%
  rbind(tidy_IndO_gee)
```

```{r, results = 'asis', echo = FALSE}
print(xtable(IndO_Model_Table, 
             caption = "Outcome Model for Individual Effects"), 
      type = 'latex', include.rownames = FALSE, comment = FALSE)
```

### G. Direct and Indirect Individual Effects of Treatment Assignment

The direct individual effect of treatment assignment on HIV seroconversion is $\beta_1^{\text{IndO}}$. The indirect individual effect of treatment assignment on HIV seroconversion is $\beta_1^{\text{IndM}} \times \beta_2^{\text{IndO}}$. Then, the total effect is the sum of these, namely $\beta_1^{\text{IndO}} + \beta_1^{\text{IndM}} \times \beta_2^{\text{IndO}}$.

```{r, echo = FALSE}
Ind_DirectIndirect_Table <- tibble(
  Model = c("GLM", "GLMM", "GEE"),
  `Direct Effect` = c(exp_beta_IndO_1,
                      exp_beta_IndO_1_glmm, 
                      exp_beta_IndO_1_gee),
  `Indirect Effect` = c(exp(log(exp_beta_IndM_1)*log(exp_beta_IndO_2)), 
                        exp(log(exp_beta_IndM_1_glmm)*log(exp_beta_IndO_2_glmm)), 
                        exp(log(exp_beta_IndM_1_gee)*log(exp_beta_IndO_2_gee)))) %>%
  mutate(`Total Effect` = c(exp(log(exp_beta_IndO_1) + log(exp_beta_IndM_1)*log(exp_beta_IndO_2)),
                            exp(log(exp_beta_IndO_1_glmm) + log(exp_beta_IndM_1_glmm)*log(exp_beta_IndO_2_glmm)),
                            exp(log(exp_beta_IndO_1_gee) + log(exp_beta_IndM_1_gee)*log(exp_beta_IndO_2_gee)))) %>%
  mutate(across(where(is.numeric), ~ round(.x, 3)))
```

```{r, results = 'asis', echo = FALSE}
print(xtable(Ind_DirectIndirect_Table, 
             caption = "Direct, Indirect, and Total Individual Effects of Treatment Assignment (Shown as ORs)"), 
      type = 'latex', include.rownames = FALSE, comment = FALSE)
```


### H. Proportion of Individual Effect of Treatment Assignment Mediated by Circumcision

The proportion of the total individual effect that is mediated by circumcision can be calculated as:

$$\frac{\beta_1^{\text{IndM}} \times \beta_2^{\text{IndO}}}{\beta_1^{\text{IndO}} + \beta_1^{\text{IndM}} \times \beta_2^{\text{IndO}}}$$

This is the indirect effect (i.e. effect of treatment assignment through the MC mediator on the outcome) divided by the total effect of the treatment assignment on the outcome (both through and not through the mediator). 

```{r, include = FALSE}
Ind_PropMediated <- tibble(
  Model = c("GLM", "GLMM", "GEE"),
  `Proportion Mediated` = c((log(exp_beta_IndM_1)*log(exp_beta_IndO_2))/(log(exp_beta_IndO_1) + log(exp_beta_IndM_1)*log(exp_beta_IndO_2)),
                            (log(exp_beta_IndM_1_glmm)*log(exp_beta_IndO_2_glmm))/(log(exp_beta_IndO_1_glmm) + log(exp_beta_IndM_1_glmm)*log(exp_beta_IndO_2_glmm)),
                            (log(exp_beta_IndM_1_gee)*log(exp_beta_IndO_2_gee))/(log(exp_beta_IndO_1_gee) + log(exp_beta_IndM_1_gee)*log(exp_beta_IndO_2_gee)))) %>%
  mutate(across(where(is.numeric), ~ round(.x, 3)))
```

```{r, results = 'asis', echo = FALSE}
print(xtable(Ind_PropMediated, 
             caption = "Proportion of Individual Effect of Treatment Assignment Mediated by Circumcision"), 
      type = 'latex', include.rownames = FALSE, comment = FALSE)
```


#### Calculating the Confidence Interval for Proportion Mediated

Delta Method: First-order Taylor approximation for the variance of a smooth function $g(\hat{\theta})$ of estimators, where 
$$\text{Var} \left\{ g(\hat{\theta}) \right\} \approx \nabla g(\hat{\theta})^T \hat{\text{Var}}(\hat{\theta}) \nabla g(\hat{\theta})$$
where $\nabla g$ is the gradient of $g$ with respects to $\theta$ evaluated at the estimates.

To simplify notation, let $a = \beta_1^{\text{IndM}}$ (from the mediator logit model), $b_1 = \beta_1^{\text{IndO}}$ and $b_2 = \beta_2^{\text{IndO}}$ (from the outcome logit model). Then, $\text{NIE} = a b_2$, $\text{TE} = b_1 + a b_2$, and $\text{PM} = \frac{\text{NIE}}{\text{TE}} = \frac{a b_2}{b_1 + a b_2}$ (natural indirect effect, total effect, and proportion mediated, respectively). The gradient for PM with respects to $(a, b_1, b_2)$ is

$$\nabla \text{PM} = \left( \frac{b_1 b_2}{(b_1 + ab_2)^2}, -\frac{a b_2}{(b_1 + ab_2)^2}, \frac{a b_1}{(b_1 + ab_2)^2} \right)$$

Then $\text{SE}(\text{PM}) \approx \sqrt{\nabla^T \Sigma \nabla}$, where $\Sigma$ is the joint covariance matrix of $(a, b_1, b_2)$. The mediator and outcome coefficients come from different models on the same data, so in principle, $\Sigma$ has cross-covariances between $a$ and $(b_1, b_2)$. Those aren't available by default, but we can use bootstrapping. We can use bootstrapping to find an estimated joint covariance of the logit coefficients $(a, b_1, b_2)$ to obtain $\hat{\Sigma} = \text{Cov}_{\text{boot}}(\hat{a}, \hat{b}_1, \hat{b}_2)$, and then apply
$$\text{Var}(\hat{\text{PM}}) \approx \nabla \text{PM} (\hat{\theta})^T \hat{\Sigma} \nabla \text{PM}(\hat{\theta})$$

Letting the gradient be $g(a, b_1, b_2) = (g_a, g_{b_1}, g_{b_2})$, this is written as
$$\text{Var}(\hat{\text{PM}}) \approx g_a^2 \text{Var}(a) + g_{b_1}^2 \text{Var}(b_1) + g_{b_2}^2 \text{Var}(b_2) + 2 g_a g_{b_1} \text{Cov}(a, b_1) + 2 g_a g_{b_2} \text{Cov}(a, b_2) + 2 g_{b_1} g_{b_2} \text{Cov}(b_1, b_2)$$

A normal-approximation CI is
$$\hat{\text{PM}} \pm z_{1 - \alpha/2} \sqrt{\text{Var}(\hat{PM})}$$

More specifically, in each bootstrap replicate $b = 1,...,B$, you refit both models on the same resampled clusters, giving the triplet $\hat{\theta}^{(b)} = (\hat{a}^{(b)}, \hat{b}_1^{(b)}, \hat{b}_2^{(b)})$. The joint covariance matrix $\hat{\Sigma}$ is just the sample covariance of those triplets:
$$\hat{\Sigma} = \frac{1}{B-1}\sum_{b=1}^{B}(\hat{\theta}^{(b)} - \bar{\theta})(\hat{\theta}^{(b)} - \bar{\theta})^T, \bar{\theta} = \frac{1}{B}\sum_{b=1}^B \hat{\theta}^{(b)}$$

The diagonals are the boot variances of $a$, $b_1$, and $b_2$. The off-diagonals (e.g. $\hat{Cov}(a,b_2)$) capture their dependence across models, because we estimated them from the same resamples. This way, we don't need to falsely assume independence between the mediator and outcome fits. 

Below shows the CI for the PM using the delta method (and bootstrapping the joint covariance), and also the CI without using the delta method and purely just using the bootstrap. The percentile bootstrap CIs are extremely susceptible to sparse data, thus causing a wide interval. However, the delta-method CI with boot $\hat{\Sigma}$ reflects local uncertainty and preserves the true cross-model dependence, leading to narrower and easier to interpret CIs.

GLM CI for PM

```{r, echo = FALSE, include = FALSE}
# Cluster-bootstrap CI for Proportion Mediated (GLM product method)
#   - Mediator:   X1_ik_vmmc ~ T_k
#   - Outcome:    Y_ik       ~ T_k + X1_ik_vmmc
#   - Effects:    NIE = a*b2,  NDE = b1,  TE = b1 + a*b2,  PM = NIE/TE
# Bootstrap design:
#   * Resample clusters with replacement (size = # unique clusters)
#   * Force-in ALL clusters that have any Y_ik = 1 at least once
#   * Stratify by treatment so treated/control cluster counts match original
#   * Allow event clusters to be drawn again in the fill step (more variability)
# No penalization; plain glm() with a higher maxit to help convergence.
# Returns: PM point estimate, percentile CI, delta-method CI using boot Sigma.
pm_boot_with_delta <- function(dat, id = "cluster_id",
                               B = 1000, level = 0.95,
                               force_event_once = TRUE,
                               allow_dup_events = TRUE,
                               seed = NULL, verbose = TRUE) {

  if (!is.null(seed)) set.seed(seed)

  # ---------- Basic checks & setup ----------
  if (!is.data.frame(dat)) stop("`dat` must be a data.frame/tibble.")
  req <- c(id, "T_k", "X1_ik_vmmc", "Y_ik")
  miss <- setdiff(req, names(dat))
  if (length(miss)) stop("Missing required columns: ", paste(miss, collapse = ", "))

  # logit models we will fit (plain GLMs)
  fM <- stats::as.formula("X1_ik_vmmc ~ T_k")           # mediator
  fO <- stats::as.formula("Y_ik ~ T_k + X1_ik_vmmc")    # outcome

  # ---------- Cluster-level summaries ----------
  # cluster-level treatment: assume constant within cluster;
  # if not constant, use majority (warn the user).
  cl_T <- tapply(dat$T_k, dat[[id]], function(x) {
    u <- unique(x)
    if (length(u) == 1) u else as.numeric(mean(x, na.rm = TRUE) >= 0.5)
  })

  # which clusters contain ANY events (Y_ik = 1)?
  cl_event <- tapply(dat$Y_ik, dat[[id]], function(y) any(y == 1, na.rm = TRUE))

  cl_t1 <- names(cl_T)[cl_T == 1]
  cl_t0 <- names(cl_T)[cl_T == 0]

  evt_t1 <- intersect(cl_t1, names(cl_event)[cl_event])
  evt_t0 <- intersect(cl_t0, names(cl_event)[cl_event])

  # pools for filling the sample, stratified by treatment
  pool_t1 <- if (allow_dup_events) cl_t1 else setdiff(cl_t1, evt_t1)
  pool_t0 <- if (allow_dup_events) cl_t0 else setdiff(cl_t0, evt_t0)

  n1 <- length(cl_t1); n0 <- length(cl_t0)   # target # clusters per arm
  e1 <- length(evt_t1); e0 <- length(evt_t0)

  # Detect and warn if treatment varies within some clusters
  nonconst <- vapply(tapply(dat$T_k, dat[[id]], function(x) length(unique(x))), `>`, logical(1), 1)
  if (any(nonconst)) warning("Treatment varies within some clusters; stratification uses cluster-level majority.")

  # ---------- Helper to draw one bootstrap sample of cluster IDs ----------
  make_sample_ids <- function() {
    # Always include each event cluster once (if requested)
    base <- if (force_event_once) c(evt_t1, evt_t0) else character(0)

    # Fill up to original counts with replacement, by treatment arm
    fill_t1 <- if (n1 - length(evt_t1) > 0) sample(pool_t1, n1 - length(evt_t1), replace = TRUE) else character(0)
    fill_t0 <- if (n0 - length(evt_t0) > 0) sample(pool_t0, n0 - length(evt_t0), replace = TRUE) else character(0)

    c(base, fill_t1, fill_t0)
  }

  # ---------- Point estimates on the full data ----------
  ctrl <- stats::glm.control(maxit = 50)   # a few extra iterations can help
  fit_M <- stats::glm(fM, family = stats::binomial(link = "logit"), data = dat, control = ctrl)
  fit_O <- stats::glm(fO, family = stats::binomial(link = "logit"), data = dat, control = ctrl)

  a0  <- stats::coef(fit_M)[["T_k"]]                 # mediator slope (T -> X)
  b10 <- stats::coef(fit_O)[["T_k"]]                 # direct path   (T -> Y | X)
  b20 <- stats::coef(fit_O)[["X1_ik_vmmc"]]          # mediator path (X -> Y | T)

  NIE0 <- a0 * b20
  TE0  <- b10 + NIE0
  PM0  <- if (is.finite(TE0) && abs(TE0) > .Machine$double.eps) NIE0 / TE0 else NA_real_

  # ---------- Bootstrap: store theta = (a, b1, b2) and PM ----------
  theta <- matrix(NA_real_, nrow = B, ncol = 3, dimnames = list(NULL, c("a","b1","b2")))
  PM    <- rep(NA_real_, B)

  if (verbose) msg_every <- max(1, floor(B / 10))

  for (b in seq_len(B)) {
    # 1) draw cluster IDs (stratified, event clusters forced in once)
    samp_ids <- make_sample_ids()

    # 2) build the bootstrap dataset
    boot_dat <- do.call(rbind, lapply(samp_ids, function(k)
      dat[dat[[id]] == k, , drop = FALSE]))

    # 3) fit both GLMs on the bootstrap sample
    fit_Mb <- suppressWarnings(stats::glm(fM, family = stats::binomial(link = "logit"), data = boot_dat, control = ctrl))
    fit_Ob <- suppressWarnings(stats::glm(fO, family = stats::binomial(link = "logit"), data = boot_dat, control = ctrl))

    # 4) extract coefficients; if any are NA/Inf, mark this draw as NA
    a  <- suppressWarnings(stats::coef(fit_Mb)[["T_k"]])
    b1 <- suppressWarnings(stats::coef(fit_Ob)[["T_k"]])
    b2 <- suppressWarnings(stats::coef(fit_Ob)[["X1_ik_vmmc"]])

    if (all(is.finite(c(a, b1, b2)))) {
      theta[b, ] <- c(a = a, b1 = b1, b2 = b2)
      NIE <- a * b2
      TE  <- b1 + NIE
      PM[b] <- if (is.finite(TE) && abs(TE) > .Machine$double.eps) NIE / TE else NA_real_
    } else {
      PM[b] <- NA_real_
    }

    if (verbose && b %% msg_every == 0) message("bootstrap: ", b, "/", B)
  }

  # ---------- Percentile CI for PM (pure bootstrap) ----------
  alpha <- (1 - level) / 2
  ci_boot <- stats::quantile(PM, probs = c(alpha, 1 - alpha), na.rm = TRUE)

  # ---------- Delta-method CI using bootstrapped joint covariance ----------
  # Gradient PM at point estimates (a0, b10, b20)
  TE <- TE0
  g1 <- (b10 * b20) / (TE^2)    # dPM/da
  g2 <- -(a0 * b20) / (TE^2)    # dPM/db1
  g3 <- (a0 * b10) / (TE^2)     # dPM/db2
  grad <- c(g1, g2, g3)

  # Empirical joint covariance of (a, b1, b2) from bootstrap draws
  # (no independence assumption needed)
  Sigma_hat <- stats::cov(theta, use = "pairwise.complete.obs")

  var_PM <- as.numeric(t(grad) %*% Sigma_hat %*% grad)
  se_PM  <- sqrt(var_PM)
  z      <- stats::qnorm(1 - alpha)
  ci_delta <- PM0 + c(-1, 1) * z * se_PM

  # ---------- Return results ----------
  list(
    point_PM      = PM0,
    ci_boot_PM    = ci_boot,
    ci_delta_PM   = ci_delta,
    boot_draws_PM = PM,
    boot_theta    = theta,
    Sigma_hat     = Sigma_hat,
    settings      = list(B = B,
                         level = level,
                         force_event_once = force_event_once,
                         allow_dup_events  = allow_dup_events)
  )
}
```

```{r, echo = FALSE, include = FALSE}
set.seed(123)
res <- pm_boot_with_delta(modelDat_Ind, id = "cluster_id", B = 1000, verbose = TRUE)
res$point_PM
res$ci_boot_PM
res$ci_delta_PM
```


GLMM CI for PM

```{r, echo = FALSE, include = FALSE}
# ------------------------------------------------------------
# Cluster-bootstrap CI for Proportion Mediated (GLMM product method)
#   Mediator (GLMM): X1_ik_vmmc ~ T_k + (1 | cluster_id)
#   Outcome  (GLMM): Y_ik       ~ T_k + X1_ik_vmmc + (1 | cluster_id)
# Effects on logit scale:
#   NIE = a * b2,  NDE = b1,  TE = b1 + a*b2,  PM = NIE / TE
# Bootstrap design:
#   * Resample clusters with replacement (size = # unique clusters)
#   * Force-in ALL clusters that have any Y_ik = 1 at least once
#   * Stratify by treatment so treated/control cluster counts match original
#   * For GLMM, duplicate draws are given NEW random-effect labels (.boot_id)
# Returns: PM point estimate, percentile CI, delta-method CI using boot Sigma.
# ------------------------------------------------------------
pm_boot_with_delta_glmm <- function(dat, id = "cluster_id",
                                    B = 500, level = 0.95,
                                    force_event_once = TRUE,
                                    allow_dup_events = TRUE,
                                    seed = NULL, verbose = TRUE) {

  if (!is.null(seed)) set.seed(seed)
  if (!requireNamespace("lme4", quietly = TRUE)) {
    stop("Package 'lme4' is required for GLMM. Please install it.")
  }

  # ---------- Basic checks ----------
  if (!is.data.frame(dat)) stop("`dat` must be a data.frame/tibble.")
  req <- c(id, "T_k", "X1_ik_vmmc", "Y_ik")
  miss <- setdiff(req, names(dat))
  if (length(miss)) stop("Missing required columns: ", paste(miss, collapse = ", "))

  # ---------- Point-estimate GLMMs on FULL data ----------
  fM_full <- stats::as.formula(paste0("X1_ik_vmmc ~ T_k + (1|", id, ")"))
  fO_full <- stats::as.formula(paste0("Y_ik ~ T_k + X1_ik_vmmc + (1|", id, ")"))
  ctrl <- lme4::glmerControl(optimizer = "bobyqa",
                             optCtrl = list(maxfun = 2e5),
                             check.conv.grad = "ignore",
                             check.conv.singular = "ignore")

  fit_M <- suppressWarnings(lme4::glmer(fM_full, family = stats::binomial(link = "logit"),
                                        data = dat, control = ctrl))
  fit_O <- suppressWarnings(lme4::glmer(fO_full, family = stats::binomial(link = "logit"),
                                        data = dat, control = ctrl))

  a0  <- lme4::fixef(fit_M)[["T_k"]]                # effect of T on mediator
  b10 <- lme4::fixef(fit_O)[["T_k"]]                # direct effect (T -> Y | X)
  b20 <- lme4::fixef(fit_O)[["X1_ik_vmmc"]]         # mediator effect (X -> Y | T)

  NIE0 <- a0 * b20
  TE0  <- b10 + NIE0
  PM0  <- if (is.finite(TE0) && abs(TE0) > .Machine$double.eps) NIE0 / TE0 else NA_real_

  # ---------- Cluster-level treatment & event flags ----------
  # If treatment varies within a cluster, use majority as its cluster-level label.
  cl_T <- tapply(dat$T_k, dat[[id]], function(x) {
    u <- unique(x); if (length(u) == 1) u else as.numeric(mean(x, na.rm = TRUE) >= 0.5)
  })
  cl_event <- tapply(dat$Y_ik, dat[[id]], function(y) any(y == 1, na.rm = TRUE))

  cl_t1 <- names(cl_T)[cl_T == 1]
  cl_t0 <- names(cl_T)[cl_T == 0]

  evt_t1 <- intersect(cl_t1, names(cl_event)[cl_event])
  evt_t0 <- intersect(cl_t0, names(cl_event)[cl_event])

  n1 <- length(cl_t1); n0 <- length(cl_t0)

  # Pools to fill from; allow event clusters to also be drawn again if requested
  pool_t1 <- if (allow_dup_events) cl_t1 else setdiff(cl_t1, evt_t1)
  pool_t0 <- if (allow_dup_events) cl_t0 else setdiff(cl_t0, evt_t0)

  # ---------- Helper: build ONE bootstrap dataset with NEW random-effect IDs ----------
  make_boot_df <- function() {
    # 1) choose cluster IDs for this replicate (stratified, force-in event clusters)
    base <- if (force_event_once) c(evt_t1, evt_t0) else character(0)
    fill_t1 <- if (n1 - length(evt_t1) > 0) sample(pool_t1, n1 - length(evt_t1), replace = TRUE) else character(0)
    fill_t0 <- if (n0 - length(evt_t0) > 0) sample(pool_t0, n0 - length(evt_t0), replace = TRUE) else character(0)
    samp_ids <- c(base, fill_t1, fill_t0)

    # 2) build the data by stacking selected clusters, assigning a NEW .boot_id per draw
    parts <- vector("list", length(samp_ids))
    for (j in seq_along(samp_ids)) {
      k <- samp_ids[j]
      d <- dat[dat[[id]] == k, , drop = FALSE]
      # Give a unique random-effect label to THIS sampled copy of cluster k
      d[[".boot_id"]] <- paste0("C", j, "_", k)
      parts[[j]] <- d
    }
    out <- do.call(rbind, parts)
    out[[".boot_id"]] <- factor(out[[".boot_id"]])  # ensure treated as grouping factor
    out
  }

  # ---------- Bootstrap: store theta = (a, b1, b2) and PM ----------
  theta <- matrix(NA_real_, nrow = B, ncol = 3, dimnames = list(NULL, c("a","b1","b2")))
  PM     <- rep(NA_real_, B)

  # GLMM formulas that use the temporary .boot_id as the random-intercept grouping
  fM_boot <- stats::as.formula("X1_ik_vmmc ~ T_k + (1|.boot_id)")
  fO_boot <- stats::as.formula("Y_ik ~ T_k + X1_ik_vmmc + (1|.boot_id)")

  if (verbose) msg_every <- max(1, floor(B/10))

  for (b in seq_len(B)) {
    boot_dat <- make_boot_df()

    fit_Mb <- try(suppressWarnings(
      lme4::glmer(fM_boot, family = stats::binomial(link = "logit"), data = boot_dat, control = ctrl)
    ), silent = TRUE)
    fit_Ob <- try(suppressWarnings(
      lme4::glmer(fO_boot, family = stats::binomial(link = "logit"), data = boot_dat, control = ctrl)
    ), silent = TRUE)

    if (!inherits(fit_Mb, "try-error") && !inherits(fit_Ob, "try-error")) {
      feM <- try(lme4::fixef(fit_Mb), silent = TRUE)
      feO <- try(lme4::fixef(fit_Ob), silent = TRUE)
      if (!inherits(feM, "try-error") && !inherits(feO, "try-error")) {
        a  <- as.numeric(feM[["T_k"]])
        b1 <- as.numeric(feO[["T_k"]])
        b2 <- as.numeric(feO[["X1_ik_vmmc"]])
        if (all(is.finite(c(a,b1,b2)))) {
          theta[b, ] <- c(a = a, b1 = b1, b2 = b2)
          NIE <- a * b2
          TE  <- b1 + NIE
          PM[b] <- if (is.finite(TE) && abs(TE) > .Machine$double.eps) NIE / TE else NA_real_
        }
      }
    }

    if (verbose && b %% msg_every == 0) message("bootstrap: ", b, "/", B)
  }

  # ---------- Percentile CI for PM (pure bootstrap) ----------
  alpha   <- (1 - level) / 2
  ci_boot <- stats::quantile(PM, probs = c(alpha, 1 - alpha), na.rm = TRUE)

  # ---------- Delta-method CI using bootstrapped joint covariance ----------
  # Gradient PM at point estimates (a0, b10, b20)
  TE   <- TE0
  g1   <- (b10 * b20) / (TE^2)     # dPM/da
  g2   <- -(a0 * b20) / (TE^2)     # dPM/db1
  g3   <- (a0 * b10) / (TE^2)      # dPM/db2
  grad <- c(g1, g2, g3)

  Sigma_hat <- stats::cov(theta, use = "pairwise.complete.obs")  # joint cov of (a,b1,b2)
  var_PM    <- as.numeric(t(grad) %*% Sigma_hat %*% grad)
  se_PM     <- sqrt(var_PM)
  z         <- stats::qnorm(1 - alpha)
  ci_delta  <- PM0 + c(-1, 1) * z * se_PM

  # ---------- Return results ----------
  list(
    point_PM      = PM0,
    ci_boot_PM    = ci_boot,
    ci_delta_PM   = ci_delta,
    boot_draws_PM = PM,
    boot_theta    = theta,
    Sigma_hat     = Sigma_hat,
    settings      = list(B = B, level = level,
                         force_event_once = force_event_once,
                         allow_dup_events  = allow_dup_events,
                         optimizer = "bobyqa", maxfun = 2e5)
  )
}
```

```{r, echo = FALSE, include = FALSE}
set.seed(123)
res_glmm <- pm_boot_with_delta_glmm(modelDat_Ind, id = "cluster_id", B = 500)
res_glmm$point_PM
res_glmm$ci_boot_PM
res_glmm$ci_delta_PM
```




GEE CI for PM

```{r, echo = FALSE, include = FALSE}
# ------------------------------------------------------------
# Cluster-bootstrap CI for Proportion Mediated (GEE product method)
#   Mediator (GEE): X1_ik_vmmc ~ T_k
#   Outcome  (GEE): Y_ik       ~ T_k + X1_ik_vmmc
# Effects on logit scale:
#   NIE = a * b2,  NDE = b1,  TE = b1 + a*b2,  PM = NIE / TE
# Bootstrap design:
#   * Resample clusters with replacement (size = # unique clusters)
#   * Force-in ALL clusters that have any Y_ik = 1 at least once
#   * Stratify by treatment so treated/control cluster counts match original
#   * For GEE, duplicate draws are given NEW IDs (.boot_id) so working
#     correlation is computed within each resampled copy separately.
# Returns: PM point estimate, percentile CI, delta-method CI using boot Sigma.
# ------------------------------------------------------------
pm_boot_with_delta_gee <- function(dat, id = "cluster_id",
                                   B = 1000, level = 0.95,
                                   corstr = "exchangeable",
                                   force_event_once = TRUE,
                                   allow_dup_events = TRUE,
                                   seed = NULL, verbose = TRUE) {

  if (!is.null(seed)) set.seed(seed)
  if (!requireNamespace("geepack", quietly = TRUE)) {
    stop("Package 'geepack' is required for GEE. Please install it.")
  }

  # ---------- Basic checks ----------
  if (!is.data.frame(dat)) stop("`dat` must be a data.frame/tibble.")
  req <- c(id, "T_k", "X1_ik_vmmc", "Y_ik")
  miss <- setdiff(req, names(dat))
  if (length(miss)) stop("Missing required columns: ", paste(miss, collapse = ", "))

  # ---------- Formulas ----------
  fM <- stats::as.formula("X1_ik_vmmc ~ T_k")            # mediator
  fO <- stats::as.formula("Y_ik ~ T_k + X1_ik_vmmc")     # outcome

  # ---------- Point estimates on FULL data (GEE) ----------
  id_full <- dat[[id]]
  fit_M <- suppressWarnings(geepack::geeglm(fM, id = id_full, data = dat,
                                            family = stats::binomial(link = "logit"), corstr = corstr))
  fit_O <- suppressWarnings(geepack::geeglm(fO, id = id_full, data = dat,
                                            family = stats::binomial(link = "logit"), corstr = corstr))

  a0  <- stats::coef(fit_M)[["T_k"]]                 # a: T -> X
  b10 <- stats::coef(fit_O)[["T_k"]]                 # b1: T -> Y | X
  b20 <- stats::coef(fit_O)[["X1_ik_vmmc"]]          # b2: X -> Y | T

  NIE0 <- a0 * b20
  TE0  <- b10 + NIE0
  PM0  <- if (is.finite(TE0) && abs(TE0) > .Machine$double.eps) NIE0 / TE0 else NA_real_

  # ---------- Cluster-level treatment & event flags ----------
  # If treatment varies within a cluster, use majority as its label (warn implicitly).
  cl_T <- tapply(dat$T_k, dat[[id]], function(x) {
    u <- unique(x); if (length(u) == 1) u else as.numeric(mean(x, na.rm = TRUE) >= 0.5)
  })
  cl_event <- tapply(dat$Y_ik, dat[[id]], function(y) any(y == 1, na.rm = TRUE))

  cl_t1 <- names(cl_T)[cl_T == 1]
  cl_t0 <- names(cl_T)[cl_T == 0]

  evt_t1 <- intersect(cl_t1, names(cl_event)[cl_event])
  evt_t0 <- intersect(cl_t0, names(cl_event)[cl_event])

  n1 <- length(cl_t1); n0 <- length(cl_t0)

  # Pools to fill from; optionally allow event clusters to be drawn again
  pool_t1 <- if (allow_dup_events) cl_t1 else setdiff(cl_t1, evt_t1)
  pool_t0 <- if (allow_dup_events) cl_t0 else setdiff(cl_t0, evt_t0)

  # ---------- Helper: build ONE bootstrap dataset w/ NEW GEE IDs ----------
  make_boot_df <- function() {
    # 1) choose cluster IDs for this replicate (stratified, force-in event clusters)
    base <- if (force_event_once) c(evt_t1, evt_t0) else character(0)
    fill_t1 <- if (n1 - length(evt_t1) > 0) sample(pool_t1, n1 - length(evt_t1), replace = TRUE) else character(0)
    fill_t0 <- if (n0 - length(evt_t0) > 0) sample(pool_t0, n0 - length(evt_t0), replace = TRUE) else character(0)
    samp_ids <- c(base, fill_t1, fill_t0)

    # 2) stack selected clusters; assign a NEW .boot_id per sampled copy
    parts <- vector("list", length(samp_ids))
    for (j in seq_along(samp_ids)) {
      k <- samp_ids[j]
      d <- dat[dat[[id]] == k, , drop = FALSE]
      d[[".boot_id"]] <- paste0("G", j, "_", k)  # unique working-correlation group
      parts[[j]] <- d
    }
    out <- do.call(rbind, parts)
    out[[".boot_id"]] <- factor(out[[".boot_id"]])
    out
  }

  # ---------- Bootstrap: store theta = (a, b1, b2) and PM ----------
  theta <- matrix(NA_real_, nrow = B, ncol = 3, dimnames = list(NULL, c("a","b1","b2")))
  PM     <- rep(NA_real_, B)
  if (verbose) msg_every <- max(1, floor(B/10))

  for (b in seq_len(B)) {
    boot_dat <- make_boot_df()
    idB <- boot_dat[[".boot_id"]]

    fit_Mb <- try(suppressWarnings(
      geepack::geeglm(fM, id = idB, data = boot_dat,
                      family = stats::binomial(link = "logit"), corstr = corstr)
    ), silent = TRUE)
    fit_Ob <- try(suppressWarnings(
      geepack::geeglm(fO, id = idB, data = boot_dat,
                      family = stats::binomial(link = "logit"), corstr = corstr)
    ), silent = TRUE)

    if (!inherits(fit_Mb, "try-error") && !inherits(fit_Ob, "try-error")) {
      a  <- suppressWarnings(stats::coef(fit_Mb)[["T_k"]])
      b1 <- suppressWarnings(stats::coef(fit_Ob)[["T_k"]])
      b2 <- suppressWarnings(stats::coef(fit_Ob)[["X1_ik_vmmc"]])
      if (all(is.finite(c(a,b1,b2)))) {
        theta[b, ] <- c(a = a, b1 = b1, b2 = b2)
        NIE <- a * b2
        TE  <- b1 + NIE
        PM[b] <- if (is.finite(TE) && abs(TE) > .Machine$double.eps) NIE / TE else NA_real_
      }
    }

    if (verbose && b %% msg_every == 0) message("bootstrap: ", b, "/", B)
  }

  # ---------- Percentile CI for PM (pure bootstrap) ----------
  alpha   <- (1 - level) / 2
  ci_boot <- stats::quantile(PM, probs = c(alpha, 1 - alpha), na.rm = TRUE)

  # ---------- Delta-method CI using bootstrapped joint covariance ----------
  TE   <- TE0
  g1   <- (b10 * b20) / (TE^2)     # dPM/da
  g2   <- -(a0 * b20) / (TE^2)     # dPM/db1
  g3   <- (a0 * b10) / (TE^2)      # dPM/db2
  grad <- c(g1, g2, g3)

  Sigma_hat <- stats::cov(theta, use = "pairwise.complete.obs")  # joint cov of (a,b1,b2)
  var_PM    <- as.numeric(t(grad) %*% Sigma_hat %*% grad)
  se_PM     <- sqrt(var_PM)
  z         <- stats::qnorm(1 - alpha)
  ci_delta  <- PM0 + c(-1, 1) * z * se_PM

  # ---------- Return results ----------
  list(
    point_PM      = PM0,
    ci_boot_PM    = ci_boot,
    ci_delta_PM   = ci_delta,
    boot_draws_PM = PM,
    boot_theta    = theta,
    Sigma_hat     = Sigma_hat,
    settings      = list(B = B, level = level, corstr = corstr,
                         force_event_once = force_event_once,
                         allow_dup_events  = allow_dup_events)
  )
}
```

```{r, echo = FALSE, include = FALSE}
set.seed(123)
res_gee <- pm_boot_with_delta_gee(modelDat_Ind, id = "cluster_id",
                                  B = 300, corstr = "exchangeable")
res_gee$point_PM
res_gee$ci_boot_PM
res_gee$ci_delta_PM
```

```{r, echo = FALSE}
# Summarize PM across GLM / GLMM / GEE into one tidy table
summarize_pm_results <- function(res_glm = NULL, res_glmm = NULL, res_gee = NULL,
                                 digits = 2) {
  rows <- list()

  add_row <- function(res, label) {
    if (is.null(res)) return(NULL)
    B   <- if (!is.null(res$settings$B)) res$settings$B else NA_integer_
    use <- if (!is.null(res$boot_draws_PM)) sum(is.finite(res$boot_draws_PM)) else NA_integer_
    boot <- res$ci_boot_PM
    delt <- res$ci_delta_PM
    data.frame(
      Method        = label,
      PM_Estimate   = res$point_PM,
      PM_Boot_Lower = as.numeric(boot[1]),
      PM_Boot_Upper = as.numeric(boot[2]),
      PM_Delta_Lower= as.numeric(delt[1]),
      PM_Delta_Upper= as.numeric(delt[2]),
      Boot_Used     = use,
      Boot_B        = B,
      stringsAsFactors = FALSE
    )
  }

  if (!is.null(res_glm))  rows <- c(rows, list(add_row(res_glm,  "GLM")))
  if (!is.null(res_glmm)) rows <- c(rows, list(add_row(res_glmm, "GLMM")))
  if (!is.null(res_gee))  {
    # include corstr in label if available
    lbl <- if (!is.null(res_gee$settings$corstr)) paste0("GEE (", res_gee$settings$corstr, ")") else "GEE"
    rows <- c(rows, list(add_row(res_gee, lbl)))
  }

  out <- do.call(rbind, rows)

  # Pretty, presentation-friendly columns (optional)
  fmt <- function(x) formatC(x, format = "f", digits = digits)
  out$`PM (boot CI)`  <- paste0(fmt(out$PM_Estimate), " [",
                                fmt(out$PM_Boot_Lower), ", ",
                                fmt(out$PM_Boot_Upper), "]")
  out$`PM (delta CI)` <- paste0(fmt(out$PM_Estimate), " [",
                                fmt(out$PM_Delta_Lower), ", ",
                                fmt(out$PM_Delta_Upper), "]")

  # Reorder & return
  out[, c("Method", "PM (boot CI)", "PM (delta CI)", "Boot_Used", "Boot_B")]
}

pm_table <- summarize_pm_results(res, res_glmm, res_gee, digits = 2)
#pm_table
```

```{r, results = 'asis', echo = FALSE}
print(xtable::xtable(dplyr::select(pm_table, Method, `PM (delta CI)`),
       caption = "Proportion mediated (PM) with bootstrap and delta-method CIs"),
      include.rownames = FALSE, comment = FALSE)
```



\newpage

## Total Proportion Mediated

#### I. Proportion of total effect mediated by male circumcision

The proportion of total effect mediated by male circumcision is

(Total Individual - Direct Individual) + (Total Spillover - Spillover Not Mediated by MC)
/ 
Overall 
(Or Total Individual + Total Spillover)

$$\frac{[(\beta_1^{\text{IndM}}\times \beta_2^{\text{IndO}}) + (\beta_1^{\text{SpW}} - \beta_1^{\text{SpWR}})]}{(\beta_1^{\text{Overall}})}$$

```{r, include = FALSE}
Overall_PropMediated <- tibble(
  Model = c("GLM", "GLMM", "GEE"),
  `Proportion of Overall Effect Mediated by Circumcision` = 
    c(((log(exp_beta_IndM_1)*log(exp_beta_IndO_2)) + (log(exp_beta_SpW_1) - log(exp_beta_SpWR_1)))/(log(exp_beta_overall_1)),
      ((log(exp_beta_IndM_1_glmm)*log(exp_beta_IndO_2_glmm)) + (log(exp_beta_SpW_1_glmm) - log(exp_beta_SpWR_1_glmm)))/(log(exp_beta_overall_1_glmm)),
      ((log(exp_beta_IndM_1_gee)*log(exp_beta_IndO_2_gee)) + (log(exp_beta_SpW_1_gee) - log(exp_beta_SpWR_1_gee)))/(log(exp_beta_overall_1_gee))))
```

```{r, results = 'asis', echo = FALSE}
print(xtable(Overall_PropMediated, 
             caption = "Proportion of Overall Effect of Treatment Assignment Mediated by VMMC"), 
      type = 'latex', include.rownames = FALSE, comment = FALSE)
```


$$\frac{[(\beta_1^{\text{IndM}}\times \beta_2^{\text{IndO}}) + (\beta_1^{\text{SpW}} - \beta_1^{\text{SpWR}})]}{(\beta_1^{\text{IndO}} + \beta_1^{\text{IndM}} \times \beta_2^{\text{IndO}})+\beta_1^{\text{SpW}}}$$

```{r, include = FALSE}
total_glm <- (log(exp_beta_IndO_1)+log(exp_beta_IndM_1)*log(exp_beta_IndO_2))+log(exp_beta_SpW_1)
total_glmm <- (log(exp_beta_IndO_1_glmm)+log(exp_beta_IndM_1_glmm)*log(exp_beta_IndO_2_glmm))+log(exp_beta_SpW_1_glmm)
total_gee <- (log(exp_beta_IndO_1_gee)+log(exp_beta_IndM_1_gee)*log(exp_beta_IndO_2_gee))+log(exp_beta_SpW_1_gee)

Overall_PropMediated_Alt <- tibble(
  Model = c("GLM", "GLMM", "GEE"),
  `Proportion of Overall Effect Mediated by Circumcision` = 
    c(((log(exp_beta_IndM_1)*log(exp_beta_IndO_2)) + (log(exp_beta_SpW_1) - log(exp_beta_SpWR_1)))/(total_glm),
      ((log(exp_beta_IndM_1_glmm)*log(exp_beta_IndO_2_glmm)) + (log(exp_beta_SpW_1_glmm) - log(exp_beta_SpWR_1_glmm)))/(total_glmm),
      ((log(exp_beta_IndM_1_gee)*log(exp_beta_IndO_2_gee)) + (log(exp_beta_SpW_1_gee) - log(exp_beta_SpWR_1_gee)))/(total_gee)))
```

```{r, results = 'asis', echo = FALSE}
print(xtable(Overall_PropMediated_Alt, 
             caption = "Proportion of Overall Effect of Treatment Assignment Mediated by VMMC"), 
      type = 'latex', include.rownames = FALSE, comment = FALSE)
```

```{r include = FALSE}
# Proportion of total effect mediated by male circumcision
#((beta_Ind_1 - beta_IndM_1) + (beta_SpW_1 - beta_SpWM_1))/(beta_Ind_1 + beta_SpW_1) 
# Proportion of total effect mediated by male circumcision firth model
# ((log(exp_beta_Ind_1) - log(exp_beta_IndD_1_firth)) + (log(exp_beta_SpW_1) - log(exp_beta_SpWR_1)))/(log(exp_beta_Ind_1) + log(exp_beta_SpW_1))
# 
# exp(((log(exp_beta_Ind_1) - log(exp_beta_IndD_1_firth)) + (log(exp_beta_SpW_1) - log(exp_beta_SpWR_1)))/(log(exp_beta_Ind_1) + log(exp_beta_SpW_1)))
```

```{r include = FALSE}
# ((log(exp_beta_Ind_1) - log(exp_beta_IndD_1_firth)) + (log(exp_beta_SpW_1) - log(exp_beta_SpWR_1)))/(log(exp_beta_overall_1))
# 
# exp(((log(exp_beta_Ind_1) - log(exp_beta_IndD_1_firth)) + (log(exp_beta_SpW_1) - log(exp_beta_SpWR_1)))/(log(exp_beta_overall_1)))
```




```{r include = FALSE, eval = FALSE}
### J. Proportion of intervention village total effect due to spillover within intervention villages

#The proportion of intervention village total effect due to spillover within intervention villages is 

#$$\frac{\beta_1^{\text{SpW}}}{(\beta_1^{\text{Ind}} + \beta_1^{\text{SpW}})}$$
# Proportion of intervention village total effect due to spillover within intervention villages
#log(exp_beta_SpW_1)/(log(exp_beta_Ind_1) + log(exp_beta_SpW_1))
#log(exp_beta_SpW_1)/(log(exp_beta_overall_1))
```


\newpage

# CURRENT ISSUES AND NOTES

## Ashley's email:

1. It would be helpful to write out the estimands for each effect. Are these the same as Tyler's paper? Does it matter that your mediator is part of the intervention package, while Tyler's is another covariate? https://pmc.ncbi.nlm.nih.gov/articles/PMC3753117/

2. Are the meditators at the individual level, group level or both? If group level, are you using an exposure mapping function? 

3. Can the spillover effect itself be mediated? In the case of just two people in a cluster, I believe the spillover problem can be exactly described as meditation.

4. How are the other package components handled? Could treat as confounders, averaging over them. 

5. For the OR =22, I would check the table of village assignment, VMMC exposure and outcome, probably a zero or small cell. Ke, any other ideas here?

6. Are you concerned about mediator confounding in this case? How is the correlation within cluster modeled? 

7. I think the positivity assumption is OK - as you have a three level exposure (women, male cirm, male unicorn) and fairly sure there are no gender restrictions on the covariates., but the "woman" status is not an intervention like VMMC is. 


## Notes from Laura

1. what we are doing is first estimating the total effect (which is a sum of the direct and indirect effects) by regressing on T.

    a. Laura's response: If regressing on T, this is the overall (total) effect, that is the overall effect of being in an intervention cluster compared to control. It's total because it's regardless of mediation.

2. then we are adjusting for x1 (vmmc) to get the direct effect of CP (assuming perfect compliance) and we can get the indirect effect through vmmc through the usual method we have in the slides.

    a. This is the overall indirect effect, that is the effect of cluster assignment through individual VMMC.

the new suggestion allows for imperfect compliance and this uses X12 in place of T. 

    a. What is the new suggestion?

## Other Notes

1. Circumcision that is done locally, not for medical purposes but for cultural purposes, is incomplete and may not be effective for preventing HIV. So at some point later in the analysis, it would be of interest to assess the effects of circumcision before the study started, with circumcision after.

2. Positivity assumption was mentioned as a possible issue because women can't have VMMC

3. Add a dag for mediation, and a dag for spillover - has anybody ever done this?

4. Do we have data on death? We can combine HIV and death as another outcome to have more events

5. There is a variable called hiv_status_time that gives HIV status by each visit, with status already positive, new positive, negative. Do you see this? And then there is a variable hiv_results_days that is days from enrollment to that test. That could give us 1 year incidence when/if we want that (for survival data analysis for example). These should add up to the number of cases in total.

6. If we want to create a combined variable, death or seroconversion, which could give us more cases and more power, if all or most of the deaths are due to HIV.

7. Time from enrollment to death is death_days. There is also a variable death_cause (can we take a look at this? It might be possible to delete deaths that are obviously not HIV related, such as accidents). And then there is another variable death_primary, which is the primary cause of death.



\newpage

# MC and VMMC

Evidence that VMMC and MC has no individual effect on HIV incidence and therefore cannot mediate the intervention

```{r echo = FALSE}
mcDat <- modelDat %>%
  filter(gender == "Male") %>%
  filter(!is.na(X1_ik)) %>%
  mutate(X1_ik = ifelse(X1_ik == "Yes", 1, 
                        ifelse(X1_ik == "No", 0, NA)))

vmmcDat <- modelDat %>%
  filter(gender == "Male") %>%
  filter(!is.na(X1_ik_vmmc)) %>%
  mutate(X1_ik_vmmc = ifelse(X1_ik_vmmc == "Yes", 1, 
                ifelse(X1_ik_vmmc == "No", 0, NA)))
```

```{r, include = FALSE}
mc_freq_table <- modelDat %>%
  filter(gender == "Male") %>%
  dplyr::select(X1_ik, Y_ik) %>%
  mutate(X1_ik = ifelse(is.na(X1_ik), "Missing", X1_ik),
         Y_ik = ifelse(Y_ik == 1, "Yes",
                       ifelse(Y_ik == 0, "No", "Missing"))) %>%
  mutate(Y_ik = paste0("Y_ik = ", Y_ik)) %>%
  mutate(X1_ik = paste0("X1_ik = ", X1_ik)) %>%
  group_by(X1_ik, Y_ik) %>%
  dplyr::summarize(n = n()) %>%
  ungroup() %>%
  pivot_wider(names_from = Y_ik, values_from = n) %>%
  mutate(across(everything(), ~replace_na(.x, 0))) %>%
  dplyr::select(`X1_ik`, `Y_ik = Yes`, `Y_ik = No`) %>%
  arrange(desc(`X1_ik`))
```

```{r, results = 'asis', echo = FALSE}
print(xtable(mc_freq_table,
             caption = "Counts of HIV Seroconversion (Y) by Male Circumcision (X1)"), 
      type = 'latex', include.rownames = FALSE, comment = FALSE)
```

```{r, include = FALSE}
vmmc_freq_table <- modelDat %>%
  filter(gender == "Male") %>%
  dplyr::select(X1_ik_vmmc, Y_ik) %>%
  mutate(X1_ik_vmmc = ifelse(is.na(X1_ik_vmmc), "Missing", X1_ik_vmmc),
         Y_ik = ifelse(Y_ik == 1, "Yes",
                       ifelse(Y_ik == 0, "No", "Missing"))) %>%
  mutate(Y_ik = paste0("Y_ik = ", Y_ik)) %>%
  mutate(X1_ik_vmmc = paste0("X1_ik_vmmc = ", X1_ik_vmmc)) %>%
  group_by(X1_ik_vmmc, Y_ik) %>%
  dplyr::summarize(n = n()) %>%
  ungroup() %>%
  pivot_wider(names_from = Y_ik, values_from = n) %>%
  mutate(across(everything(), ~replace_na(.x, 0))) %>%
  dplyr::select(`X1_ik_vmmc`, `Y_ik = Yes`, `Y_ik = No`) %>%
  arrange(desc(`X1_ik_vmmc`))
```

```{r, results = 'asis', echo = FALSE}
print(xtable(vmmc_freq_table,
             caption = "Counts of HIV Seroconversion (Y) by VMMC (X1)"), 
      type = 'latex', include.rownames = FALSE, comment = FALSE)
```

```{r, echo = FALSE, include = FALSE}
tally(~X1_ik, data = mcDat)
tally(~X1_ik_vmmc, data = vmmcDat)
```



```{r echo = FALSE}
# MC
# Model not accounting for clustering
model_mc <- glm(Y_ik ~ X1_ik,
                 family = binomial(link = 'logit'),
                 data = mcDat) # Exclude those who received full trt

# Model accounting for clustering using GLMM
model_mc_glmm <- glmer(Y_ik ~ X1_ik + (1|cluster_id), # Uses exchangeable structure
                        data = mcDat, 
                        family = binomial(link = "logit"))

# Model accounting for clustering using GEE
model_mc_gee <- geeglm(Y_ik ~ X1_ik,
                        family = binomial(link = "logit"), # logit link
                        id = cluster_id, # clustering variable
                        data = mcDat,
                        corstr  = "exchangeable") # working correlation


# VMMC
# Model not accounting for clustering
model_vmmc <- glm(Y_ik ~ X1_ik_vmmc,
                 family = binomial(link = 'logit'),
                 data = vmmcDat) # Exclude those who received full trt

# Model accounting for clustering using GLMM
model_vmmc_glmm <- glmer(Y_ik ~ X1_ik_vmmc + (1|cluster_id), # Uses exchangeable structure
                        data = vmmcDat, 
                        family = binomial(link = "logit"))

# Model accounting for clustering using GEE
model_vmmc_gee <- geeglm(Y_ik ~ X1_ik_vmmc,
                        family = binomial(link = "logit"), # logit link
                        id = cluster_id, # clustering variable
                        data = vmmcDat,
                        corstr  = "exchangeable") # working correlation
```

```{r, echo = FALSE, warning = FALSE}
# GLM Model
model_mc_summary <- summary(model_mc) # Save model summary

exp_beta_mc_0 <- exp(model_mc_summary$coefficients[1,1]) # Intercept
exp_beta_mc_1 <- exp(model_mc_summary$coefficients[2,1]) # X1 Coefficient

tidy_mc <- broom::tidy(model_mc, conf.int = TRUE, exponentiate = TRUE) %>%
  dplyr::select(term, estimate, std.error, p.value, conf.low, conf.high) %>%
  mutate(Model = "GLM",
         Term = term,
         `OR [95% CI]` = paste0(round(estimate, 3), " [", 
                            round(conf.low, 3), ", ", 
                            round(conf.high, 3), "]"),
         `p-value` = round(p.value, 3)) %>%
  dplyr::select(Model, Term, `OR [95% CI]`, `p-value`) %>%
  dplyr::filter(Term != "(Intercept)") %>%
  mutate(ICC = NA)

# GLMM Model
model_mc_summary_glmm <- summary(model_mc_glmm) # Save model summary

exp_beta_mc_0_glmm <- exp(model_mc_summary_glmm$coefficients[1,1]) # Intercept
exp_beta_mc_1_glmm <- exp(model_mc_summary_glmm$coefficients[2,1]) # X1 Coefficient

tidy_mc_glmm <- broom.mixed::tidy(model_mc_glmm, effects = "fixed", 
                  conf.int = TRUE, exponentiate = TRUE) %>%
  dplyr::select(term, estimate, std.error, p.value, conf.low, conf.high) %>%
  mutate(Model = "GLMM",
         Term = term,
         `OR [95% CI]` = paste0(round(estimate, 3), " [", 
                            round(conf.low, 3), ", ", 
                            round(conf.high, 3), "]"),
         `p-value` = round(p.value, 3)) %>%
  dplyr::select(Model, Term, `OR [95% CI]`, `p-value`) %>%
  dplyr::filter(Term != "(Intercept)") %>%
  mutate(ICC = round(performance::icc(model_mc_glmm)$ICC_adjusted[[1]], 3))

# GEE Model
model_mc_summary_gee <- summary(model_mc_gee) # Save model summary

exp_beta_mc_0_gee <- exp(model_mc_summary_gee$coefficients[1,1]) # Intercept
exp_beta_mc_1_gee <- exp(model_mc_summary_gee$coefficients[2,1]) # X1 Coefficient

tidy_mc_gee <- broom::tidy(model_mc_gee, conf.int = TRUE, 
                            exponentiate = TRUE) %>%
  dplyr::select(term, estimate, std.error, p.value, conf.low, conf.high) %>%
  mutate(Model = "GEE",
         Term = term,
         `OR [95% CI]` = paste0(round(estimate, 3), " [", 
                            round(conf.low, 3), ", ", 
                            round(conf.high, 3), "]"),
         `p-value` = round(p.value, 3)) %>%
  dplyr::select(Model, Term, `OR [95% CI]`, `p-value`) %>%
  dplyr::filter(Term != "(Intercept)") %>%
  mutate(ICC = round(model_mc_gee$geese$alpha[[1]], 3))

# Overall Output Table for SpW
mc_Model_Table <- rbind(tidy_mc, tidy_mc_glmm) %>%
  rbind(tidy_mc_gee)
```

```{r, results = 'asis', echo = FALSE}
print(xtable(mc_Model_Table, 
             caption = "Effect of MC on HIV Incidence"), 
      type = 'latex', include.rownames = FALSE, comment = FALSE)
```
Fisher's exact test

```{r}
mat <- matrix(c(9, 1528,   # first row
                0, 1591),  # second row
              nrow = 2, byrow = TRUE)
fisher.test(mat, alternative = "two.sided")


vmmcmat <- matrix(c(6, 984,   # first row
                3, 2135),  # second row
              nrow = 2, byrow = TRUE)
fisher.test(vmmcmat, alternative = "two.sided")
```




```{r, echo = FALSE, warning = FALSE}
# GLM Model
model_vmmc_summary <- summary(model_vmmc) # Save model summary

exp_beta_vmmc_0 <- exp(model_vmmc_summary$coefficients[1,1]) # Intercept
exp_beta_vmmc_1 <- exp(model_vmmc_summary$coefficients[2,1]) # X1vmmc Coefficient

tidy_vmmc <- broom::tidy(model_vmmc, conf.int = TRUE, exponentiate = TRUE) %>%
  dplyr::select(term, estimate, std.error, p.value, conf.low, conf.high) %>%
  mutate(Model = "GLM",
         Term = term,
         `OR [95% CI]` = paste0(round(estimate, 3), " [", 
                            round(conf.low, 3), ", ", 
                            round(conf.high, 3), "]"),
         `p-value` = round(p.value, 3)) %>%
  dplyr::select(Model, Term, `OR [95% CI]`, `p-value`) %>%
  dplyr::filter(Term != "(Intercept)") %>%
  mutate(ICC = NA)

# GLMM Model
model_vmmc_summary_glmm <- summary(model_vmmc_glmm) # Save model summary

exp_beta_vmmc_0_glmm <- exp(model_vmmc_summary_glmm$coefficients[1,1]) # Intercept
exp_beta_vmmc_1_glmm <- exp(model_vmmc_summary_glmm$coefficients[2,1]) # X1vmmc Coefficient

tidy_vmmc_glmm <- broom.mixed::tidy(model_vmmc_glmm, effects = "fixed", 
                  conf.int = TRUE, exponentiate = TRUE) %>%
  dplyr::select(term, estimate, std.error, p.value, conf.low, conf.high) %>%
  mutate(Model = "GLMM",
         Term = term,
         `OR [95% CI]` = paste0(round(estimate, 3), " [", 
                            round(conf.low, 3), ", ", 
                            round(conf.high, 3), "]"),
         `p-value` = round(p.value, 3)) %>%
  dplyr::select(Model, Term, `OR [95% CI]`, `p-value`) %>%
  dplyr::filter(Term != "(Intercept)") %>%
  mutate(ICC = round(performance::icc(model_vmmc_glmm)$ICC_adjusted[[1]], 3))

# GEE Model
model_vmmc_summary_gee <- summary(model_vmmc_gee) # Save model summary

exp_beta_vmmc_0_gee <- exp(model_vmmc_summary_gee$coefficients[1,1]) # Intercept
exp_beta_vmmc_1_gee <- exp(model_vmmc_summary_gee$coefficients[2,1]) # X1 Coefficient

tidy_vmmc_gee <- broom::tidy(model_vmmc_gee, conf.int = TRUE, 
                            exponentiate = TRUE) %>%
  dplyr::select(term, estimate, std.error, p.value, conf.low, conf.high) %>%
  mutate(Model = "GEE",
         Term = term,
         `OR [95% CI]` = paste0(round(estimate, 3), " [", 
                            round(conf.low, 3), ", ", 
                            round(conf.high, 3), "]"),
         `p-value` = round(p.value, 3)) %>%
  dplyr::select(Model, Term, `OR [95% CI]`, `p-value`) %>%
  dplyr::filter(Term != "(Intercept)") %>%
  mutate(ICC = round(model_vmmc_gee$geese$alpha[[1]], 3))

# Overall Output Table for SpW
vmmc_Model_Table <- rbind(tidy_vmmc, tidy_vmmc_glmm) %>%
  rbind(tidy_vmmc_gee)
```

```{r, results = 'asis', echo = FALSE}
print(xtable(vmmc_Model_Table, 
             caption = "Effect of VMMC on HIV Incidence"), 
      type = 'latex', include.rownames = FALSE, comment = FALSE)
```

Evidence that village-level circumcision rates have a strong effect and mediate treatment effect in men.

Mediator Model:

$$Z_{k}^{(1)} = \beta_0^{\text{M}} + \beta_1^{\text{M}} (T_k)$$




```{r, echo = FALSE, warning = FALSE}
# Model not accounting for clustering
model_z_med <- lm(Z1_k ~ T_k,
                 data = modelDat) # Exclude those who received full trt

# Model accounting for clustering using GLMM
model_z_med_glmm <- lmer(Z1_k ~ T_k + (1 | cluster_id),
                         data = modelDat)

# Model accounting for clustering using GEE
model_z_med_gee <- geeglm(Z1_k ~ T_k,
                        family = gaussian(link = "identity"), # logit link
                        id = cluster_id, # clustering variable
                        data = modelDat,
                        corstr  = "exchangeable") # working correlation

# GLM Model
model_z_med_summary <- summary(model_z_med) # Save model summary

beta_z_med_0 <- (model_z_med_summary$coefficients[1,1]) # Intercept
beta_z_med_1 <- (model_z_med_summary$coefficients[2,1]) # X1vmmc Coefficient

tidy_z_med <- broom::tidy(model_z_med, conf.int = TRUE, exponentiate = FALSE) %>%
  dplyr::select(term, estimate, std.error, p.value, conf.low, conf.high) %>%
  mutate(Model = "LM",
         Term = term,
         `Beta [95% CI]` = paste0(round(estimate, 3), " [", 
                            round(conf.low, 3), ", ", 
                            round(conf.high, 3), "]"),
         `p-value` = round(p.value, 3)) %>%
  dplyr::select(Model, Term, `Beta [95% CI]`, `p-value`) %>%
  dplyr::filter(Term != "(Intercept)") %>%
  mutate(ICC = NA)

# GLMM Model
model_z_med_summary_glmm <- summary(model_z_med_glmm) # Save model summary

beta_z_med_0_glmm <- (model_z_med_summary_glmm$coefficients[1,1]) # Intercept
beta_z_med_1_glmm <- (model_z_med_summary_glmm$coefficients[2,1]) # X1vmmc Coefficient

tidy_z_med_glmm <- broom.mixed::tidy(model_z_med_glmm, effects = "fixed",
                                    conf.int = TRUE) %>%
  dplyr::mutate(p.value = 2 * pnorm(-abs(statistic)),   # z-approximation
                Model   = "LMM",
                Term    = term,
                `Beta [95% CI]` = sprintf("%.3f [%.3f, %.3f]",
                                      estimate, conf.low, conf.high)) %>%
  dplyr::select(Model, Term, `Beta [95% CI]`, `p-value` = p.value) %>%
  dplyr::filter(Term != "(Intercept)") %>%
  dplyr::mutate(ICC = round(performance::icc(model_z_med_glmm)$ICC_adjusted[[1]], 3))

# GEE Model
model_z_med_summary_gee <- summary(model_z_med_gee) # Save model summary

beta_z_med_0_gee <- (model_z_med_summary_gee$coefficients[1,1]) # Intercept
beta_z_med_1_gee <- (model_z_med_summary_gee$coefficients[2,1]) # X1 Coefficient

tidy_z_med_gee <- broom::tidy(model_z_med_gee, conf.int = TRUE, 
                            exponentiate = FALSE) %>%
  dplyr::select(term, estimate, std.error, p.value, conf.low, conf.high) %>%
  mutate(Model = "GEE",
         Term = term,
         `Beta [95% CI]` = paste0(round(estimate, 3), " [", 
                            round(conf.low, 3), ", ", 
                            round(conf.high, 3), "]"),
         `p-value` = round(p.value, 3)) %>%
  dplyr::select(Model, Term, `Beta [95% CI]`, `p-value`) %>%
  dplyr::filter(Term != "(Intercept)") %>%
  mutate(ICC = round(model_z_med_gee$geese$alpha[[1]], 3))

# Overall Output Table for SpW
z_med_Model_Table <- rbind(tidy_z_med, tidy_z_med_glmm) %>%
  rbind(tidy_z_med_gee) %>%
  dplyr::select(-ICC)
```

```{r, results = 'asis', echo = FALSE}
print(xtable(z_med_Model_Table, 
             caption = "Mediatior Model for Proportion VMMC"), 
      type = 'latex', include.rownames = FALSE, comment = FALSE)
```



Outcome Model: 


$$logit(Y_{ik}) = \beta_0^{\text{O}} + \beta_1^{\text{O}} (T_k) + \beta_2 (Z_{k}^{(1)})$$



```{r, echo = FALSE, warning = FALSE}
# Model not accounting for clustering
model_z_out <- glm(Y_ik ~ T_k + Z1_k,
                  family = binomial(link = "logit"),
                 data = modelDat) # Exclude those who received full trt

# Model accounting for clustering using GLMM
model_z_out_glmm <- glmer(Y_ik ~ T_k + Z1_k + (1|cluster_id), # Uses exchangeable structure
                        data = modelDat, 
                        family = binomial(link = "logit"))

# Model accounting for clustering using GEE
model_z_out_gee <- geeglm(Y_ik ~ T_k + Z1_k,
                        family = binomial(link = "logit"), # logit link
                        id = cluster_id, # clustering variable
                        data = modelDat,
                        corstr  = "exchangeable") # working correlation

# GLM Model
model_z_out_summary <- summary(model_z_out) # Save model summary

beta_z_out_0 <- (model_z_out_summary$coefficients[1,1]) # Intercept
beta_z_out_1 <- (model_z_out_summary$coefficients[2,1]) # T Coefficient
beta_z_out_2 <- (model_z_out_summary$coefficients[3,1]) # Z1 Coefficient

tidy_z_out <- broom::tidy(model_z_out, conf.int = TRUE, exponentiate = TRUE) %>%
  dplyr::select(term, estimate, std.error, p.value, conf.low, conf.high) %>%
  mutate(Model = "GLM",
         Term = term,
         `OR [95% CI]` = paste0(round(estimate, 3), " [", 
                            round(conf.low, 3), ", ", 
                            round(conf.high, 3), "]"),
         `Beta [95% CI]` = paste0(round(log(estimate), 3), " [", 
                            round(log(conf.low), 3), ", ", 
                            round(log(conf.high), 3), "]"),
         `p-value` = round(p.value, 3)) %>%
  dplyr::select(Model, Term, `OR [95% CI]`, `Beta [95% CI]`, `p-value`) %>%
  dplyr::filter(Term != "(Intercept)") %>%
  mutate(ICC = NA)

# GLMM Model
model_z_out_summary_glmm <- summary(model_z_out_glmm) # Save model summary

beta_z_out_0_glmm <- (model_z_out_summary_glmm$coefficients[1,1]) # Intercept
beta_z_out_1_glmm <- (model_z_out_summary_glmm$coefficients[2,1]) # T Coefficient
beta_z_out_2_glmm <- (model_z_out_summary_glmm$coefficients[3,1]) # Z1 Coefficient

tidy_z_out_glmm <- broom.mixed::tidy(model_z_out_glmm, effects = "fixed", 
                  conf.int = TRUE, exponentiate = TRUE) %>%
  dplyr::select(term, estimate, std.error, p.value, conf.low, conf.high) %>%
  mutate(Model = "GLMM",
         Term = term,
         `OR [95% CI]` = paste0(round(estimate, 3), " [", 
                            round(conf.low, 3), ", ", 
                            round(conf.high, 3), "]"),
         `Beta [95% CI]` = paste0(round(log(estimate), 3), " [", 
                            round(log(conf.low), 3), ", ", 
                            round(log(conf.high), 3), "]"),
         `p-value` = round(p.value, 3),
         `p-value` = round(p.value, 3)) %>%
  dplyr::select(Model, Term, `OR [95% CI]`, `Beta [95% CI]`, `p-value`) %>%
  dplyr::filter(Term != "(Intercept)") %>%
  mutate(ICC = round(performance::icc(model_z_out_glmm)$ICC_adjusted[[1]], 3))

# GEE Model
model_z_out_summary_gee <- summary(model_z_out_gee) # Save model summary

beta_z_out_0_gee <- (model_z_out_summary_gee$coefficients[1,1]) # Intercept
beta_z_out_1_gee <- (model_z_out_summary_gee$coefficients[2,1]) # T Coefficient
beta_z_out_2_gee <- (model_z_out_summary_gee$coefficients[3,1]) # Z1 Coefficient

tidy_z_out_gee <- broom::tidy(model_z_out_gee, conf.int = TRUE, 
                            exponentiate = TRUE) %>%
  dplyr::select(term, estimate, std.error, p.value, conf.low, conf.high) %>%
  mutate(Model = "GEE",
         Term = term,
         `OR [95% CI]` = paste0(round(estimate, 3), " [", 
                            round(conf.low, 3), ", ", 
                            round(conf.high, 3), "]"),
         `Beta [95% CI]` = paste0(round(log(estimate), 3), " [", 
                            round(log(conf.low), 3), ", ", 
                            round(log(conf.high), 3), "]"),
         `p-value` = round(p.value, 3)) %>%
  dplyr::select(Model, Term, `OR [95% CI]`, `Beta [95% CI]`, `p-value`) %>%
  dplyr::filter(Term != "(Intercept)") %>%
  mutate(ICC = round(model_z_out_gee$geese$alpha[[1]], 3))

# Overall Output Table for SpW
z_out_Model_Table <- rbind(tidy_z_out, tidy_z_out_glmm) %>%
  rbind(tidy_z_out_gee)
```

```{r, results = 'asis', echo = FALSE}
print(xtable(z_out_Model_Table, 
             caption = "Outcome Model for Proportion VMMC"), 
      type = 'latex', include.rownames = FALSE, comment = FALSE)
```




```{r, echo = FALSE}
Ind_DirectIndirect_Table <- tibble(
  Model = c("LM/GLM", "LMM/GLMM", "GEE"),
  `Direct Effect` = c(beta_z_out_1,
                      beta_z_out_1_glmm, 
                      beta_z_out_1_gee),
  `Indirect Effect` = c(beta_z_med_1*beta_z_out_2,
                        beta_z_med_1_glmm*beta_z_out_2_glmm,
                        beta_z_med_1_gee*beta_z_out_2_gee)
  ) %>%
  mutate(`Total Effect` = `Direct Effect`+`Indirect Effect`) %>%
  mutate(`Proportion Mediated` = `Indirect Effect`/`Total Effect`)
```

```{r, results = 'asis', echo = FALSE}
print(xtable(Ind_DirectIndirect_Table, 
             caption = "Direct, Indirect, Total, and Proportion Mediated Proportion VMMC"), 
      type = 'latex', include.rownames = FALSE, comment = FALSE)
```



