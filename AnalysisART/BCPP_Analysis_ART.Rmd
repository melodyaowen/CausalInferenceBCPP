---
title: "BCPP ART Analysis"
author: "Melody Owen"
date: "2025-08-01"
output:
  pdf_document:
    toc: true
    toc_depth: 3
    latex_engine: pdflatex  # or xelatex/lualatex if you're using those
    includes:
      in_header: preamble.tex
geometry: margin=0.5in
---

\newpage

# OVERVIEW

## The Botswana Combination Prevention Project (BCPP)

### Motivation

- \underline{Goal}: The primary goal of BCPP was to determine whether implementation of combination prevention package (CP) can significantly reduce population-level, cumulative HIV incidence

- \underline{Population}: Individuals in Botswana aged 16-64 years

- \underline{Timeline}: Study length was approximately 3 years

- \underline{Design}: 30 communities were selected and matched into pairs based on community characteristics thought to be associated with HIV incidence

### Treatment in BCPP

The Combination Prevention (CP) prevention package included the following four components:

1. \underline{VMMC}: Voluntary Medical Male Circumcision (only for HIV-negative males)

2. \underline{HTC}: HIV Testing and Counseling (only for HIV-negative individuals)

3. \underline{ART}: Antiretroviral Therapy (only for HIV-positive individuals)

4. \underline{PMTCT}: Prevention of mother-to-child transmission (only for pregnant HIV-positive females)

Clusters (30 communities) were randomized to either:

- \underline{Treatment}: CP Package

- \underline{Control}: Standard of Care

Our analysis examines the impact of CP for HIV-negative individuals, so we consider the "entire" package components 1 and 2 only.

\newpage

## Terminology

\underline{Individual Effects}: Refers to an effect of one's own input on their own outcome

\underline{Spillover Effects}: Refers to an effect of others' inputs on one's outcome; "within-cluster spillover" refers to spillover between individuals in the same cluster

\underline{Direct Effects}: Refers to an effect pathway that links directly from an input to an output with nothing else on the pathway

\underline{Indirect Effects}: Refers to an effect pathway that links indirectly from an input to an output through a node (mediator) on the pathway \newline

With these, we can define the following:

\underline{Individual Effects}

  - **Individual Direct Effect**: Path from one's own input to their own outcome with no other nodes on the pathway
  - **Individual Indirect Effect**: Path from one's own input to their own outcome through a node (mediator) on the pathway
  - **Total Individual Effect**: Total effect of one's input on their outcome through all pathways (Individual Direct + Individual Indirect)

\underline{Spillover Effects}

  - **Spillover Direct Effect**: Path from others' inputs to one's outcome with no other nodes on the pathway
  - **Spillover Indirect Effect**: Path from others' inputs to one's outcome through a node (mediator) on the pathway
  - **Total Spillover Effect**: Total effect of other's inputs on one's outcome through all pathways (Spillover Direct + Spillover Indirect)

\underline{Overall Effects}
  
  - **Overall Effect**: Total Individual Effect + Total Spillover Effect

## Questions of Interest

1. What is the direct individual effect of the CP intervention on HIV incidence?

2. To what extent is the total individual effect mediated by Voluntary Male Medical Circumcision (VMMC)?

3. What is the direct spillover effect of the CP intervention on HIV incidence?

4. To what extent is the total spillover effect mediated by VMMC? 

5. What is the overall effect of CP on HIV incidence? ("overall" includes both spillover and individual totals)

6. To what extent is the overall effect mediated by VMMC? 

\newpage

# NOTATION

$K$ is the total number of villages in the study, indexed as $k = 1,...,K$

$m_k$ is the total number of individuals in cluster $k$, indexed as $i = 1,...,m_k$

- $m_k^{(\text{male})}$ are the total number of males in cluster $k$
- $m_k^{(\text{female})}$ are the total number of females in cluster $k$
    
$Y_{ik}$ is the outcome of subject $i$ in cluster $k$, and is binary

- In BCPP, $Y_{ik} = 1$ if a subject seroconverted by the end of the study, $Y_{ik} = 0$ otherwise

$T_k$ is the cluster-level binary treatment assignment

- In BCPP, $T_k = 1$ if a cluster has been assigned to receive CP, and $T_k = 0$ otherwise

$X_{ik}^{(1)}$, $X_{ik}^{(2)}$ denotes each of the two components of the treatment, $T_k$. 

- In BCPP, the Combination Prevention (CP) package included the following:

    1. MC: Male Circumcision (available only for HIV-negative males)
    2. HTC: HIV Testing and Counseling (available only for HIV-negative individuals)
    3. ART: Antiretroviral Therapy (available only for HIV-positive individuals)
    4. PMTCT: Prevention of Mother-to-Child Transmission (available only for HIV-positive females)
    
- We are only considering the first two components as the entire treatment package, since the last two apply to HIV-positive individuals only.
- $X_{ik}^{(1)}$ denotes any type of male circumcision (MC); $X_{ik}^{(1)} = \text{"Yes"}$ if individual $i$ in cluster $k$ was circumcised before or during the study, $X_{ik}^{(1)} = \text{"No"}$ if they are male and not circumcised, and $X_{ik}^{(1)} = \text{"Female"}$ if they are female (three levels are included as to not exclude females)
- $X_{ik}^{(1, \text{VMMC})}$ denotes voluntary medical male circumcision (VMMC); $X_{ik}^{(1)} = \text{"Yes"}$ if individual $i$ in cluster $k$ was circumcised, $X_{ik}^{(1)} = \text{"No"}$ if they are male and not circumcised or circumcised before the study, and $X_{ik}^{(1)} = \text{"Female"}$ if they are female (three levels are included as to not exclude females)
- $X_{ik}^{(2)} = 1$ if individual $i$ in cluster $k$ received HTC at enrollment or thereafter, and $X_{ik}^{(2)} = 0$ otherwise

$X_{ik}^{(12)}$ denotes whether individual $i$ in cluster $k$ received the entire treatment

- For males in BCPP, $X_{ik}^{(12)} = X_{ik}^{(1)} \times X_{ik}^{(2)} = 1$ if they received both MC and HTC, $X_{ik}^{(12)} = 0$ otherwise
- For females in BCPP, $X_{ik}^{(12)} = X_{ik}^{(2)} = 1$ if they received HTC, $X_{ik}^{(12)} = 0$ otherwise

$Z_k^{(1)}$, $Z_k^{(2)}$ is the proportion of individuals in village $k$ who received the first component and second component of the treatment, respectively

- For males in BCPP, $Z_k^{(1)} = \sum_{i=1}^{m_k^{(\text{male})}} \frac{X_{ik}^{(1)}}{m_k^{(\text{male})}}$ is the proportion of males in village $k$ who are circumcised before or during the study

- For males in BCPP, $Z_k^{(1, \text{VMMC})} = \sum_{i=1}^{m_k^{(\text{male})}} \frac{X_{ik}^{(1, \text{VMMC})}}{m_k^{(\text{male})}}$ is the proportion of males in village $k$ who have received VMMC during the study

- For all individuals in BCPP, $Z_k^{(2)} = \sum_{i=1}^{m_k} \frac{X_{ik}^{(2)}}{m_k}$ is the proportion of all individuals in village $k$ who received HTC

$Z_{ik}^{(12)}$ is the proportion of individuals who received the full treatment

- For males in BCPP, $Z_{ik}^{(12)} = \sum_{i=1}^{m_k^{(\text{male})}} \frac{X_{ik}^{(1)} \times X_{ik}^{(2)}}{m_k^{(\text{male})}}$ is the proportion of males who are both circumcised and received HTC
- For females in BCPP, $Z_{ik}^{(12)} = Z_{ik}^{(2)} = \sum_{i=1}^{m_k^{(\text{female})}} \frac{X_{ik}^{(2)}}{m_k^{(\text{female})}}$ is the proprtion of females who received HTC

$\mathbf{C}_{ik} = (C_{1k}^{(1)}, ..., C_{m_k k}^{(1)}, C_{1k}^{(2)}, ..., C_{m_k k}^{(2)})$ are the individual level covariates

$\mathbf{V}_k = (V_k^{(1)}, ..., V_k^{(v)})$ are the cluster-level covariates

\newpage

```{r setup, include = FALSE}
# Package names
packages <- c("tidyverse", "lme4", "MASS", "Matrix", "matrixcalc", "latex2exp",
              "ICC", "nlme", "bindata", "gee", "crt2power", "mosaic", "haven",
              "tmvtnorm", "ggplot2", "latex2exp", "reshape2", "gridExtra",
              "table1", "broom", "xtable", "logistf", "kableExtra", "geepack",
              "elrm", "broom", "dplyr", "tibble", "lme4", "broom.mixed",
              "performance", "mice", "glmnet", "rms")

# Install packages not yet installed
installed_packages <- packages %in% rownames(installed.packages())
if (any(installed_packages == FALSE)) {
  install.packages(packages[!installed_packages])
}

# Packages loading
invisible(lapply(packages, library, character.only = TRUE))
```


```{r load_data, include = FALSE}
# Loading in original datasets
dat1 <- read_sas("~/Desktop/3. Causal Inference Mediation/BCPP data/BCPP data/longyr1_20samp_open.sas7bdat")
dat2 <- read_sas("~/Desktop/3. Causal Inference Mediation/BCPP data/BCPP data/longyr2_20samp_open.sas7bdat")
dat3 <- read_sas("~/Desktop/3. Causal Inference Mediation/BCPP data/BCPP data/longyr3_20samp_open.sas7bdat")
```


```{r column_names, include = FALSE}
# Create a dataframe for each set of column names
names1 <- tibble(colname = sort(colnames(dat1)), dataset = "dat1")
names2 <- tibble(colname = sort(colnames(dat2)), dataset = "dat2")
names3 <- tibble(colname = sort(colnames(dat3)), dataset = "dat3")

# Bind and pivot to wide
all_names <- bind_rows(names1, names2, names3) %>%
  mutate(present = colname) %>%
  pivot_wider(names_from = dataset, values_from = present) %>%
  arrange(colname)

all_names_filtered <- bind_rows(names1, names2, names3) %>%
  mutate(present = colname) %>%
  pivot_wider(names_from = dataset, values_from = present) %>%
  arrange(colname) %>%
  dplyr::filter(colname %in% c("de_subj_idC", # Subject identifier
                               "community", # Community identifier
                               
                               "random_arm", # Randomization arm (Treatment Assignment)
                               "gender", # Gender
                               
                               # At start of study? Unclear
                               "hiv_status_current", # Current HIV status
                               "circumcised", # Male circumcision
                               
                               # "Coverage Endpoint"
                               "endpoint_coverage_htc", # Coverage endpoint: HIV-tested or diagnosed HIV+
                               "endpoint_coverage_mc", # Coverage endpoint: male circumcision
                               
                               
                               # Outcome
                               "endpoint_seroconvert") # Incidence endpoint: seroconverted by study completion
  )

# Keeping subject ID the same name so I can match the data
dat1_renamed <- dat1 %>% rename_with(~ paste0(., "_dat1"), -de_subj_idC)
dat2_renamed <- dat2 %>% rename_with(~ paste0(., "_dat2"), -de_subj_idC)
dat3_renamed <- dat3 %>% rename_with(~ paste0(., "_dat3"), -de_subj_idC)
```

```{r echo = FALSE}
combinedDat <- full_join(dat1_renamed, dat2_renamed, by = "de_subj_idC") %>%
  full_join(dat3_renamed, by = "de_subj_idC") %>%
  dplyr::select(de_subj_idC, starts_with("random_arm_dat"), 
                contains("community_dat"),
                starts_with("Gender_dat"), hiv_status_current_dat1,
                starts_with("circumcised_dat"), starts_with("circumcision_days"),
                contains("endpoint_coverage_mc"),
                contains("endpoint_coverage_htc"), contains("seroconvert")) 
```


```{r merging_datasets, include = FALSE}
# Circumcision in all three datasets
combinedDat <- full_join(dat1_renamed, dat2_renamed, by = "de_subj_idC") %>%
  full_join(dat3_renamed, by = "de_subj_idC") %>%
  dplyr::select(de_subj_idC, starts_with("random_arm_dat"), 
                contains("community_dat"),
                starts_with("Gender_dat"), hiv_status_current_dat1,
                starts_with("circumcised_dat"), starts_with("circumcision_days"), 
                contains("endpoint_coverage_mc"),
                contains("endpoint_coverage_htc"), contains("seroconvert")) %>%
  mutate(random_arm = ifelse(!is.na(random_arm_dat1), random_arm_dat1,
                             ifelse(!is.na(random_arm_dat2), random_arm_dat2,
                                    random_arm_dat3))) %>%
  mutate(gender = ifelse(!is.na(gender_dat1), gender_dat1,
                         ifelse(!is.na(gender_dat2), gender_dat2,
                                gender_dat3))) %>%
  mutate(community = ifelse(!is.na(community_dat1), community_dat1,
                            ifelse(!is.na(community_dat2), community_dat2,
                                   community_dat3))) %>%
  dplyr::select(subject_ID = de_subj_idC, community, gender,
                random_arm, hiv_status_current = hiv_status_current_dat1,
                starts_with("circumcised"), starts_with("circumcision_days"),
                contains("endpoint_coverage_mc"), 
                contains("endpoint_coverage_htc"),
                contains("seroconvert")) %>%
  mutate(gender = case_when(gender == "F" ~ "Female",
                            gender == "M" ~ "Male",
                            TRUE ~ NA_character_
  )) %>%
  mutate(circumcised_dat1 = ifelse(gender == "Female",
                                   "Female", circumcised_dat1),
         circumcised_dat2 = ifelse(gender == "Female",
                                   "Female", circumcised_dat2),
         circumcised_dat3 = ifelse(gender == "Female",
                                   "Female", circumcised_dat3)) %>%
  mutate(circumcised_dat2 = ifelse(circumcised_dat1 == "Yes", "Yes",
                                   circumcised_dat2)) %>%
  mutate(circumcised_dat3 = ifelse(circumcised_dat2 == "Yes", "Yes",
                                   ifelse(circumcised_dat1 == "Yes", "Yes",
                                          circumcised_dat3))) %>%
  mutate(across(where(~ !is.numeric(.)), ~ na_if(., ""))) %>%
  mutate(across(where(is.character), str_trim)) %>%
  mutate(endpoint_coverage_mc_dat1 = ifelse(gender == "Female", "Female", endpoint_coverage_mc_dat1),
         endpoint_coverage_mc_dat2 = ifelse(gender == "Female", "Female", endpoint_coverage_mc_dat2),
         endpoint_coverage_mc_dat3 = ifelse(gender == "Female", "Female", endpoint_coverage_mc_dat3)) %>%
  mutate(endpoint_coverage_mc = ifelse(circumcised_dat1 == "Yes" & circumcision_days_dat1 < 0,
                                       "Began study circumcised", ifelse(circumcised_dat1 == "Yes" & (circumcision_days_dat1 >= 0 | is.na(circumcision_days_dat1)), "Yes", NA))) %>%
  # mutate(endpoint_coverage_mc = ifelse(circumcised_dat1 == "Yes",
  #                                      "Began study circumcised", NA)) %>%
  mutate(endpoint_coverage_mc = ifelse(gender == "Female", "Female",
                                       endpoint_coverage_mc)) %>%
  mutate(endpoint_coverage_mc = ifelse(is.na(endpoint_coverage_mc) & endpoint_coverage_mc_dat3 == "Yes",
                                       "Yes", endpoint_coverage_mc)) %>%
  mutate(endpoint_coverage_mc = ifelse(is.na(endpoint_coverage_mc) & endpoint_coverage_mc_dat2 == "Yes",
                                       "Yes", endpoint_coverage_mc)) %>%
  mutate(endpoint_coverage_mc = ifelse(is.na(endpoint_coverage_mc) & endpoint_coverage_mc_dat1 == "Yes",
                                       "Yes", endpoint_coverage_mc)) %>%
  mutate(endpoint_coverage_mc = ifelse(is.na(endpoint_coverage_mc) & circumcised_dat3 == "Yes",
                                       "Yes", endpoint_coverage_mc)) %>%
  mutate(endpoint_coverage_mc = ifelse(is.na(endpoint_coverage_mc) & circumcised_dat2 == "Yes",
                                       "Yes", endpoint_coverage_mc)) %>%
  mutate(endpoint_coverage_mc = ifelse(is.na(endpoint_coverage_mc) &
                                         rowSums(across(contains("dat"), ~ replace_na(. == "No", FALSE))) > 0 &
                                         rowSums(across(contains("dat"), ~ replace_na(. == "Yes", FALSE))) == 0,
                                       "No", endpoint_coverage_mc))
```


```{r cleaning_data, include = FALSE}
# This dataset is a cleaned version of the original dataset with NO ONE EXCLUDED YET
cleanDat <- combinedDat %>%
  dplyr::select(original_subject_id = subject_ID, 
                original_glmmter_id = community, 
                random_arm, gender, 
                hiv_status_current,
                endpoint_coverage_htc = endpoint_coverage_htc_dat1, 
                endpoint_coverage_mc, 
                endpoint_seroconvert = endpoint_seroconvert_dat1) %>%
  mutate(endpoint_coverage_full = ifelse(gender == "Male" & (endpoint_coverage_mc == "Yes" | endpoint_coverage_mc == "Began study circumcised") & endpoint_coverage_htc == "Yes", "Yes", 
                         ifelse(gender == "Female" & endpoint_coverage_htc == "Yes", "Yes", "No"))) %>%
  arrange(original_glmmter_id, original_subject_id) %>%
  mutate_if(is.character, list(~na_if(., ""))) %>% # change any blanks to NAs
  rowid_to_column("subject_id") %>%
  group_by(original_glmmter_id) %>%
  mutate(cluster_id = cur_group_id()) %>%
  mutate(subj_glmmter_id = row_number()) %>%
  ungroup() %>%
  add_count(cluster_id, name = "cluster_size") %>%
  relocate(subject_id, subj_glmmter_id, cluster_id, cluster_size) %>%
  ungroup() %>%
  dplyr::select(-original_subject_id, -original_glmmter_id) %>%
  mutate(random_arm = ifelse(random_arm == "Standard of Care", "Control",
                             ifelse(random_arm == "Intervention", "Treatment", NA))) %>%
  mutate(endpoint_seroconvert = ifelse(hiv_status_current == "HIV-infected",
                                       "Began study HIV-infected", endpoint_seroconvert))
```

```{r create_model_dat, include = FALSE}
# ModelDat is the clean dataset but with people excluded
# Only exclude people who already have HIV or refused testing
# Also people who don't have the outcome
modelDat_full <- cleanDat %>%
  # Calculate proportions first
  mutate(T_k = ifelse(random_arm == "Treatment", 1, 
                      ifelse(random_arm == "Control", 0, NA))) %>%
  # 1 if circumcised before or during study, 0 if no, "Female" if female
  mutate(X1_ik = ifelse(endpoint_coverage_mc == "Yes" | endpoint_coverage_mc == "Began study circumcised", "Yes",
                        ifelse(endpoint_coverage_mc == "No", "No", endpoint_coverage_mc))) %>%
  # 1 if HTC yes, 0 if HTC no
  mutate(X2_ik = ifelse(endpoint_coverage_htc == "Yes", 1,
                        ifelse(endpoint_coverage_htc == "No", 0, NA))) %>%
  # 1 if Male, circumcised, and got HTC | 1 if female and got HTC, 0 otherwise
  mutate(X12_ik = ifelse(gender == "Male" & X1_ik == "Yes" & X2_ik == 1, 1, 
                         ifelse(gender == "Female" & X2_ik == 1, 1, 0))) %>%
  # Gender characteristic, 1 if Male, 0 if female
  mutate(C1_ik = ifelse(gender == "Male", 1, 
                        ifelse(gender == "Female", 0, NA))) %>%
  mutate(X1_ik_vmmc = ifelse(endpoint_coverage_mc == "Yes", "Yes", 
                       ifelse(endpoint_coverage_mc %in% c("Began study circumcised", "No"), "No",
                              ifelse(endpoint_coverage_mc == "Female", "Female", NA)))) %>%
  group_by(cluster_id) %>%
  # Count of all men in each cluster
  mutate(male_count = sum(gender == "Male", na.rm = TRUE)) %>%
  # Count of all male circumcised men in each cluster
  mutate(mc_count = sum(X1_ik == "Yes", na.rm = TRUE)) %>%
  # Count of all male VMMC in each cluster
  mutate(vmmc_count = sum(X1_ik_vmmc == "Yes", na.rm = TRUE)) %>%
  # Count of those who received HTC in each cluster
  mutate(htc_count = sum(X2_ik == 1, na.rm = TRUE)) %>%
  # Count of those who received their full treatment in each cluster
  mutate(full_trt_count = sum(X12_ik == 1, na.rm = TRUE)) %>%
  # Count of those who started study HIV positive in each cluster
  mutate(hiv_infected_count = sum(hiv_status_current == "HIV-infected", na.rm = TRUE)) %>%
  mutate(hiv_refused_testing_count = sum(hiv_status_current == "Refused HIV testing", na.rm = TRUE)) %>%
  ungroup() %>%
  # Treatment related proportions
  mutate(Z1_k = mc_count/male_count, # Prop males circumcised
         Z1_k_vmmc = vmmc_count/male_count, # Prop males VMMC
         Z2_k = htc_count/cluster_size,
         Z12_k = full_trt_count/cluster_size) %>%
  # Characteristic related proportions
  mutate(hiv_infected_prop = hiv_infected_count/cluster_size) %>%
  mutate(hiv_refused_testing_prop = hiv_refused_testing_count/cluster_size) %>%
  mutate(Y_ik = ifelse(endpoint_seroconvert == "Yes", 1,
                       ifelse(endpoint_seroconvert == "No", 0, NA)))

# Then filter out people who already have HIV or refused testing
modelDat <- modelDat_full %>% 
  dplyr::filter(hiv_status_current == "HIV-uninfected") %>%
  dplyr::filter(!is.na(Y_ik))

excludedDat <- modelDat_full %>%
  dplyr::filter(hiv_status_current != "HIV-uninfected" | is.na(hiv_status_current) | is.na(Y_ik))
```


# BASELINE CHARACTERISTICS

## Characteristics Before Exclusions

The original dataset has `r nrow(cleanDat)` total individuals in the study; `r nrow(dplyr::filter(cleanDat, random_arm == "Treatment"))` in the treatment group, and `r nrow(dplyr::filter(cleanDat, random_arm == "Control"))` in the control arm. 


```{r include = FALSE}
var_order_full <- c("Gender", "HIV Status at Start", "Treatment Component: MC",
                    "Treatment Component: VMMC",
                    "Treatment Component: HTC", "Treatment Component: Full",
                    "Outcome: HIV Seroconversion (3-year period)")
level_order_full <- c("Male", "Yes", "No", "Began study circumcised", "Female",
                      "HIV-uninfected", "HIV-infected", "Refused HIV testing",
                      "Began study HIV-infected")

baseline_full <- cleanDat %>%
  mutate(endpoint_coverage_vmmc = ifelse(endpoint_coverage_mc == "Yes", "Yes", 
                       ifelse(endpoint_coverage_mc %in% c("Began study circumcised", "No"), "No",
                              ifelse(endpoint_coverage_mc == "Female", "Female", NA)))) %>%
  dplyr::select(`Treatment Group` = random_arm,
                `Cluster Size` = cluster_size,
                `Gender` = gender,
                `HIV Status at Start` = hiv_status_current,
                `Treatment Component: MC` = endpoint_coverage_mc,
                `Treatment Component: VMMC` = endpoint_coverage_vmmc,
                `Treatment Component: HTC` = endpoint_coverage_htc,
                `Treatment Component: Full` = endpoint_coverage_full,
                `Outcome: HIV Seroconversion (3-year period)` = endpoint_seroconvert) %>%
  mutate(across(
    where(~ !is.numeric(.x)),
    ~ ifelse(is.na(.x), "Missing", as.character(.x))
  ))

baseline_missing <- baseline_full %>%
  dplyr::select(-`Cluster Size`) %>%
  filter(if_any(everything(), ~ .x == "Missing")) %>%
  mutate(across(
    .cols = -c(`Treatment Group`),  # replace col1 and col2 with your actual column names
    .fns = ~ if_else(.x == "Missing", 1, 0)
  )) %>%
  group_by(`Treatment Group`) %>%
  summarise(across(
    everything(),  # No need to exclude the grouping var here
    sum,
    .names = "{.col}"
  )) %>%
  dplyr::select(-Gender) %>%
  ungroup() %>%
  pivot_longer(
    cols = -`Treatment Group`,  # gather all variables except the group
    names_to = "Variable",
    values_to = "Missing"
  ) %>%
  pivot_wider(
    names_from = `Treatment Group`,
    values_from = Missing
  ) %>%
  mutate(Overall = Control + Treatment) %>%
  rename(`Missing (Control)` = Control,
         `Missing (Treatment)` = Treatment,
         `Missing (Overall)` = Overall)

cluster_size <- tibble(Variable = c("Number of Individuals", 
                                    "Number of Clusters", 
                                    "Mean Cluster Size"),
                       Level = c(NA, NA, NA),
                       Control = c(nrow(dplyr::filter(cleanDat, random_arm == "Control")),
                                   length(unique(dplyr::filter(cleanDat, random_arm == "Control")$cluster_id)),
                                   mean(filter(cleanDat, random_arm == "Control")$cluster_size)),
                       Treatment = c(nrow(dplyr::filter(cleanDat, random_arm == "Treatment")),
                                     length(unique(dplyr::filter(cleanDat, random_arm == "Treatment")$cluster_id)),
                                     mean(filter(cleanDat, random_arm == "Treatment")$cluster_size))) %>%
  mutate(Control = as.integer(Control), Treatment = as.integer(Treatment)) %>%
  mutate(Overall = ifelse(Variable != "Mean Cluster Size", Treatment + Control, round((Treatment + Control) / 2, 1)))

baseline_tab <- baseline_full %>%
  dplyr::select(-`Cluster Size`) %>%
  pivot_longer(!`Treatment Group`, 
               names_to = "Variable", values_to = "Level") %>%
  arrange(`Treatment Group`, Variable, Level) %>%
  group_by(`Treatment Group`, Variable, Level) %>%
  dplyr::summarize(n = n()) %>%
  ungroup() %>%
  filter(Level != "Missing") %>%
  group_by(`Treatment Group`, `Variable`) %>%
  mutate(Overall = sum(n)) %>%
  ungroup() %>%
  rowwise() %>%
  mutate(percentage = paste0("(", round(n/Overall, 2)*100, "%)")) %>%
  mutate(n = paste(n, percentage)) %>%
  dplyr::select(-Overall, -percentage) %>%
  pivot_wider(
    names_from = `Treatment Group`,
    values_from = n
  ) %>%
  mutate(
    Overall = parse_number(Control) + parse_number(Treatment)
  ) %>%
  group_by(Variable) %>%
  mutate(Sum = sum(Overall)) %>%
  mutate(Overall = paste0(Overall, " (", round(Overall/Sum, 2)*100, "%)")) %>%
  dplyr::select(-Sum) %>%
  mutate(Variable = factor(Variable, levels = var_order_full),
         Level = factor(Level, levels = level_order_full)) %>%
  arrange(Variable, Level)

n_treat_full <- nrow(filter(cleanDat, random_arm == "Treatment"))
n_control_full <- nrow(filter(cleanDat, random_arm == "Control"))
n_overall_full <- nrow(cleanDat)

final_baseline_full_table <- rbind(cluster_size, baseline_tab) %>%
  left_join(baseline_missing, by = "Variable") %>%
  group_by(Variable) %>%
  mutate(
    Variable = if_else(row_number() == 1, Variable, NA_character_),
    `Missing (Control)` = if_else(row_number() == 1, `Missing (Control)`, NA_integer_),
    `Missing (Treatment)` = if_else(row_number() == 1, `Missing (Treatment)`, NA_integer_),
    `Missing (Overall)` = if_else(row_number() == 1, `Missing (Overall)`, NA_integer_)
  ) %>%
  ungroup() %>%
  mutate(`Missing (Control)` = as.integer(`Missing (Control)`),
         `Missing (Treatment)` = as.integer(`Missing (Treatment)`),
         `Missing (Overall)` = as.integer(`Missing (Overall)`)) %>%
  rowwise() %>%
  mutate(`Missing (Control)` = ifelse(!is.na(`Missing (Control)`), 
                                      paste0(`Missing (Control)`, " (", 
                                             round(`Missing (Control)`/n_control_full, 2)*100, "%)"), NA),
         `Missing (Treatment)` = ifelse(!is.na(`Missing (Treatment)`), 
                                      paste0(`Missing (Treatment)`, " (", 
                                             round(`Missing (Treatment)`/n_treat_full, 2)*100, "%)"), NA),
         `Missing (Overall)` = ifelse(!is.na(`Missing (Overall)`), 
                                      paste0(`Missing (Overall)`, " (", 
                                             round(`Missing (Overall)`/n_overall_full, 2)*100, "%)"), NA))
```


```{r, results = 'asis', echo = FALSE}
cat("\\begin{landscape}\n")

print(
  xtable(
    final_baseline_full_table,
    caption = "Characteristics by treatment group before exclusions",
    label = "tab:cluster_summary"
  ),
  type = "latex",
  include.rownames = FALSE,
  comment = FALSE
)

cat("\\end{landscape}\n")
```


Table below displays the mean proportion, per cluster, of various characteristics, including mean proportion of HIV infected individuals per cluster at baseline, etc. These are calculated before any exclusions. Note that for the proportion of males circumcised in a given cluster, this includes both circumcision that occurred during and before the study. 

```{r include = FALSE}
proportion_dat <- modelDat %>%
  mutate(`Proportion of Males in Cluster` = male_count/cluster_size) %>%
  dplyr::select(cluster_id, 
                `Treatment Group` = random_arm,
                `Proportion of HIV Infected in Cluster` = hiv_infected_prop,
                #`Proportion of Refused HIV Testing in Cluster` = hiv_refused_testing_prop,
                `Proportion of Males in Cluster`,
                `Proportion of Males Circumcised in Cluster` = Z1_k, 
                `Proportion of Males VMMC in Cluster` = Z1_k_vmmc,
                `Proportion HTC in Cluster` = Z2_k,
                `Proportion Fully Treated in Cluster` = Z12_k) %>%
  distinct()

# Compute summary with Mean and SD
proportion_table_final <- proportion_dat %>%
  group_by(`Treatment Group`) %>%
  dplyr::select(-cluster_id) %>%
  dplyr::summarize(across(
    everything(),
    list(
      Mean = ~mean(.x, na.rm = TRUE),
      SD = ~sd(.x, na.rm = TRUE)
    ),
    .names = "{.fn} | {.col}"
  )) %>%
  mutate(across(where(is.numeric), round, 2)) %>%
  pivot_longer(
    -`Treatment Group`,
    names_to = "Stat_Var",
    values_to = "Value"
  ) %>%
  separate(Stat_Var, into = c("Stat", "Variable"), sep = " \\| ") %>%
  pivot_wider(
    names_from = Stat,
    values_from = Value
  ) %>%
  mutate(
    Value = paste0(Mean, " (", SD, ")"),
    Variable = paste0(Variable, " (Mean, SD)")
  ) %>%
  dplyr::select(-Mean, -SD) %>%
  pivot_wider(
    names_from = `Treatment Group`,
    values_from = Value
  )

# View result
#proportion_table_final
#View(proportion_table_final)
```

```{r, results = 'asis', echo = FALSE}
print(
  xtable(
    proportion_table_final,
    caption = "Cluster-level proportions by treatment group before exclusions",
    label = "tab:cluster_summary"
  ),
  type = "latex",
  include.rownames = FALSE,
  comment = FALSE
)
```

## Characteristics After Exclusions

A total of `r nrow(excludedDat)` individuals were excluded from the analysis dataset. This is because these individuals either began the study as HIV-positive (n = `r nrow(filter(excludedDat, hiv_status_current == "HIV-infected"))`), refused HIV testing (n = `r nrow(filter(excludedDat, hiv_status_current == "Refused HIV testing"))`), or had a missing value (n = `r nrow(filter(excludedDat, is.na(hiv_status_current)))`). Or, if they began the study HIV-negative, if they had a missing value for seroconversion (the outcome), they were excluded (n = `r nrow(dplyr::filter(modelDat_full, hiv_status_current == "HIV-uninfected") %>% dplyr::filter(is.na(Y_ik)))`). 

Note that in our analyses, we evaluated whether the intervention reduced HIV incidence by modeling seroconversion among individuals who were HIV-negative at baseline (n = `r nrow(modelDat)`). Although the analysis was restricted to this at-risk subset, all cluster-level characteristics (e.g., proportion HIV-positive at baseline, proportion of men circumcised, etc.) were calculated using the full study population. This approach ensures that the covariates reflect the overall context and implementation environment of each cluster, rather than being limited to the analytic subset.

The following table shows the baseline characteristics of the new dataset that excludes these individuals (n = `r nrow(modelDat)`). 

```{r include = FALSE}
var_order_red <- c("Gender", "HIV Status at Start", "Treatment Component: MC",
                   "Treatment Component: VMMC",
                    "Treatment Component: HTC", "Treatment Component: Full",
                    "Outcome: HIV Seroconversion (3-year period)")
level_order_red <- c("Male", "Yes", "No", "Began study circumcised", "Female",
                      "HIV-uninfected", "HIV-infected", "Refused HIV testing",
                      "Began study HIV-infected")

baseline_red <- modelDat %>%
  mutate(endpoint_coverage_vmmc = ifelse(endpoint_coverage_mc == "Yes", "Yes", 
                       ifelse(endpoint_coverage_mc %in% c("Began study circumcised", "No"), "No",
                              ifelse(endpoint_coverage_mc == "Female", "Female", NA)))) %>%
  dplyr::select(`Treatment Group` = random_arm,
                `Cluster Size` = cluster_size,
                `Gender` = gender,
                `HIV Status at Start` = hiv_status_current,
                `Treatment Component: MC` = endpoint_coverage_mc,
                `Treatment Component: VMMC` = endpoint_coverage_vmmc,
                `Treatment Component: HTC` = endpoint_coverage_htc,
                `Treatment Component: Full` = endpoint_coverage_full,
                `Outcome: HIV Seroconversion (3-year period)` = endpoint_seroconvert) %>%
  mutate(across(
    where(~ !is.numeric(.x)),
    ~ ifelse(is.na(.x), "Missing", as.character(.x))
  ))

baseline_missing_red <- baseline_red %>%
  dplyr::select(-`Cluster Size`) %>%
  filter(if_any(everything(), ~ .x == "Missing")) %>%
  mutate(across(
    .cols = -c(`Treatment Group`),  # replace col1 and col2 with your actual column names
    .fns = ~ if_else(.x == "Missing", 1, 0)
  )) %>%
  group_by(`Treatment Group`) %>%
  summarise(across(
    everything(),  # No need to exclude the grouping var here
    sum,
    .names = "{.col}"
  )) %>%
  dplyr::select(-Gender) %>%
  ungroup() %>%
  pivot_longer(
    cols = -`Treatment Group`,  # gather all variables except the group
    names_to = "Variable",
    values_to = "Missing"
  ) %>%
  pivot_wider(
    names_from = `Treatment Group`,
    values_from = Missing
  ) %>%
  mutate(Overall = Control + Treatment) %>%
  rename(`Missing (Control)` = Control,
         `Missing (Treatment)` = Treatment,
         `Missing (Overall)` = Overall)

cluster_size_red <- tibble(Variable = c("Number of Individuals", 
                                    "Number of Clusters", 
                                    "Mean Cluster Size"),
                       Level = c(NA, NA, NA),
                       Control = c(nrow(dplyr::filter(modelDat, random_arm == "Control")),
                                   length(unique(dplyr::filter(modelDat, random_arm == "Control")$cluster_id)),
                                   mean(filter(modelDat, random_arm == "Control")$cluster_size)),
                       Treatment = c(nrow(dplyr::filter(modelDat, random_arm == "Treatment")),
                                     length(unique(dplyr::filter(modelDat, random_arm == "Treatment")$cluster_id)),
                                     mean(filter(modelDat, random_arm == "Treatment")$cluster_size))) %>%
  mutate(Control = as.integer(Control), Treatment = as.integer(Treatment)) %>%
  mutate(Overall = ifelse(Variable != "Mean Cluster Size", Treatment + Control, round((Treatment + Control) / 2, 1)))

baseline_tab_red <- baseline_red %>%
  dplyr::select(-`Cluster Size`) %>%
  pivot_longer(!`Treatment Group`, 
               names_to = "Variable", values_to = "Level") %>%
  arrange(`Treatment Group`, Variable, Level) %>%
  group_by(`Treatment Group`, Variable, Level) %>%
  dplyr::summarize(n = n()) %>%
  ungroup() %>%
  filter(Level != "Missing") %>%
  group_by(`Treatment Group`, `Variable`) %>%
  mutate(Overall = sum(n)) %>%
  ungroup() %>%
  rowwise() %>%
  mutate(percentage = paste0("(", round(n/Overall, 2)*100, "%)")) %>%
  mutate(n = paste(n, percentage)) %>%
  dplyr::select(-Overall, -percentage) %>%
  pivot_wider(
    names_from = `Treatment Group`,
    values_from = n
  ) %>%
  mutate(
    Overall = parse_number(Control) + parse_number(Treatment)
  ) %>%
  group_by(Variable) %>%
  mutate(Sum = sum(Overall)) %>%
  mutate(Overall = paste0(Overall, " (", round(Overall/Sum, 2)*100, "%)")) %>%
  dplyr::select(-Sum) %>%
  mutate(Variable = factor(Variable, levels = var_order_full),
         Level = factor(Level, levels = level_order_full)) %>%
  arrange(Variable, Level)

n_treat_red <- nrow(filter(modelDat, random_arm == "Treatment"))
n_control_red <- nrow(filter(modelDat, random_arm == "Control"))
n_overall_red <- nrow(modelDat)

final_baseline_red_table <- rbind(cluster_size_red, baseline_tab_red) %>%
  left_join(baseline_missing_red, by = "Variable") %>%
  group_by(Variable) %>%
  mutate(
    Variable = if_else(row_number() == 1, Variable, NA_character_),
    `Missing (Control)` = if_else(row_number() == 1, `Missing (Control)`, NA_integer_),
    `Missing (Treatment)` = if_else(row_number() == 1, `Missing (Treatment)`, NA_integer_),
    `Missing (Overall)` = if_else(row_number() == 1, `Missing (Overall)`, NA_integer_)
  ) %>%
  ungroup() %>%
  mutate(`Missing (Control)` = as.integer(`Missing (Control)`),
         `Missing (Treatment)` = as.integer(`Missing (Treatment)`),
         `Missing (Overall)` = as.integer(`Missing (Overall)`)) %>%
  rowwise() %>%
  mutate(`Missing (Control)` = ifelse(!is.na(`Missing (Control)`), 
                                      paste0(`Missing (Control)`, " (", 
                                             round(`Missing (Control)`/n_control_full, 2)*100, "%)"), NA),
         `Missing (Treatment)` = ifelse(!is.na(`Missing (Treatment)`), 
                                        paste0(`Missing (Treatment)`, " (", 
                                               round(`Missing (Treatment)`/n_treat_full, 2)*100, "%)"), NA),
         `Missing (Overall)` = ifelse(!is.na(`Missing (Overall)`), 
                                      paste0(`Missing (Overall)`, " (", 
                                             round(`Missing (Overall)`/n_overall_full, 2)*100, "%)"), NA)) %>%
  mutate(`Missing (Control)` = ifelse(`Missing (Control)` == "0 (0%)", 
                                      NA, `Missing (Control)`),
         `Missing (Treatment)` = ifelse(`Missing (Treatment)` == "0 (0%)", 
                                      NA, `Missing (Treatment)`),
         `Missing (Overall)` = ifelse(`Missing (Overall)` == "0 (0%)", 
                                      NA, `Missing (Overall)`))
```


```{r, results = 'asis', echo = FALSE}
cat("\\begin{landscape}\n")

print(
  xtable(
    final_baseline_red_table,
    caption = "Characteristics by treatment group after exclusions",
    label = "tab:cluster_summary"
  ),
  type = "latex",
  include.rownames = FALSE,
  comment = FALSE
)

cat("\\end{landscape}\n")
```

\newpage


## VMMC vs. MC

```{r, eval = FALSE}
mc_order <- c("Yes", "No", "Female", "Missing")

mc_table <- modelDat %>%
  dplyr::select(Y_ik, X1_ik) %>%
  mutate(X1_ik = ifelse(is.na(X1_ik), "Missing", X1_ik)) %>%
  mutate(Y_ik = ifelse(Y_ik == 1, "Yes", "No")) %>%
  group_by(Y_ik, X1_ik) %>%
  dplyr::summarize(n = n()) %>%
  ungroup() %>%
  pivot_wider(values_from = n, names_from = Y_ik) %>%
  mutate(MC = factor(X1_ik, levels = mc_order)) %>%
  dplyr::select(MC, Yes, No) %>%
  mutate(Yes = ifelse(is.na(Yes), 0, Yes)) %>%
  mutate(No = ifelse(is.na(No), 0, No)) %>%
  arrange(MC)

vmmc_table <- modelDat %>%
  dplyr::select(Y_ik, X1_ik_vmmc) %>%
  mutate(X1_ik_vmmc = ifelse(is.na(X1_ik_vmmc), "Missing", X1_ik_vmmc)) %>%
  mutate(Y_ik = ifelse(Y_ik == 1, "Yes", "No")) %>%
  group_by(Y_ik, X1_ik_vmmc) %>%
  dplyr::summarize(n = n()) %>%
  ungroup() %>%
  pivot_wider(values_from = n, names_from = Y_ik) %>%
  mutate(VMMC = factor(X1_ik_vmmc, levels = mc_order)) %>%
  dplyr::select(VMMC, Yes, No) %>%
  mutate(Yes = ifelse(is.na(Yes), 0, Yes)) %>%
  mutate(No = ifelse(is.na(No), 0, No)) %>%
  arrange(VMMC)
```



\newpage 

# MODELING RESULTS

## Overall Effects

### A. Overall Intervention Village Effect

The overall effect of being in an intervention village can be calculated by just fitting the following model on the overall dataset of HIV-negative individuals (at the start of the study, n = `r nrow(modelDat)`), without controlling for any other causal pathways. 

$$logit(Y_{ik}) = \beta_0^{\text{Overall}} + \beta_1^{\text{Overall}}(T_{k})$$

```{r}
# Overall Effects of T_k on Y_ik

# Model not accounting for clustering
model_overall <- glm(Y_ik ~ T_k,
                     family = binomial(link = 'logit'),
                     data = modelDat) # Everyone

# Model accounting for clustering using GLMM
model_overall_glmm <- glmer(Y_ik ~ T_k + (1|cluster_id),# Uses exchangeable
                            data = modelDat,
                            family = binomial(link = "logit"))

# Model accounting for clustering using GEE
model_overall_gee <- geeglm(Y_ik ~ T_k,
                            family = binomial(link = "logit"),
                            id = cluster_id,
                            data = modelDat,
                            corstr = "exchangeable") # working correlation
```

```{r, echo = FALSE}
# GlM Model
model_overall_summary <- summary(model_overall) # Save model summary

exp_beta_overall_0 <- exp(model_overall_summary$coefficients[1,1]) # Intercept
exp_beta_overall_1 <- exp(model_overall_summary$coefficients[2,1]) # T_k Coefficient

tidy_overall <- broom::tidy(model_overall, conf.int = TRUE, exponentiate = TRUE) %>%
  dplyr::select(term, estimate, std.error, p.value, conf.low, conf.high) %>%
  mutate(Model = "GLM",
         Term = term,
         `OR [95% CI]` = paste0(round(estimate, 3), " [", 
                            round(conf.low, 3), ", ", 
                            round(conf.high, 3), "]"),
         `p-value` = round(p.value, 3)) %>%
  dplyr::select(Model, Term, `OR [95% CI]`, `p-value`) %>%
  dplyr::filter(Term != "(Intercept)") %>%
  mutate(ICC = NA)

# GLMM Model
model_overall_summary_glmm <- summary(model_overall_glmm) # Save model summary

exp_beta_overall_0_glmm <- exp(model_overall_summary_glmm$coefficients[1,1]) # Intercept
exp_beta_overall_1_glmm <- exp(model_overall_summary_glmm$coefficients[2,1]) # T_k Coefficient

tidy_overall_glmm <- broom.mixed::tidy(model_overall_glmm, effects = "fixed", 
                  conf.int = TRUE, exponentiate = TRUE) %>%
  dplyr::select(term, estimate, std.error, p.value, conf.low, conf.high) %>%
  mutate(Model = "GLMM",
         Term = term,
         `OR [95% CI]` = paste0(round(estimate, 3), " [", 
                            round(conf.low, 3), ", ", 
                            round(conf.high, 3), "]"),
         `p-value` = round(p.value, 3)) %>%
  dplyr::select(Model, Term, `OR [95% CI]`, `p-value`) %>%
  dplyr::filter(Term != "(Intercept)") %>%
  mutate(ICC = c(round(performance::icc(model_overall_glmm)$ICC_adjusted[[1]], 3)))

# GEE Model
model_overall_summary_gee <- summary(model_overall_gee) # Save model summary

exp_beta_overall_0_gee <- exp(model_overall_summary_gee$coefficients[1,1]) # Intercept
exp_beta_overall_1_gee <- exp(model_overall_summary_gee$coefficients[2,1]) # T_k Coefficient

tidy_overall_gee <- broom::tidy(model_overall_gee, conf.int = TRUE, 
                            exponentiate = TRUE) %>%
  dplyr::select(term, estimate, std.error, p.value, conf.low, conf.high) %>%
  mutate(Model = "GEE",
         Term = term,
         `OR [95% CI]` = paste0(round(estimate, 3), " [", 
                            round(conf.low, 3), ", ", 
                            round(conf.high, 3), "]"),
         `p-value` = round(p.value, 3)) %>%
  dplyr::select(Model, Term, `OR [95% CI]`, `p-value`) %>%
  dplyr::filter(Term != "(Intercept)") %>%
  mutate(ICC = c(round(model_overall_gee$geese$alpha[[1]], 3)))

# Overall Output Table for SpW
overall_Model_Table <- rbind(tidy_overall, tidy_overall_glmm) %>%
  rbind(tidy_overall_gee)
```

```{r, results = 'asis', echo = FALSE}
print(xtable(overall_Model_Table, 
             caption = "Overall Effect of Treatment Assignment on HIV Model Output"), 
      type = 'latex', include.rownames = FALSE, comment = FALSE)
```

Thus, the OR is `r round(exp_beta_overall_1, 2)`, meaning that for HIV-negative individuals at baseline, living in an intervention village is associated with a `r (1 - round(exp_beta_overall_1, 2))*100`% reduction in the odds of seroconversion during follow-up compared with living in a control village. This single odds ratio blends every causal pathway, thus resulting in an overall effect. It is the total impact of the intervention environment on an average resident. 


## Within-Village Spillover


\underline{Setup}

- In this analysis, we include everyone in the study (who began the study HIV-negative) who DID NOT receive any part of the treatment. 

- This setup will allow us to estimate

    a. Total Within-Cluster Spillover Effect of the Intervention
    b. Within-Cluster Spillover of the Intervention Effect Not through Voluntary Medical Male Circumcision
    c. Proportion of Within-Intervention Village Spillover Effect Mediated by Voluntary Medical Male Circumcision
    
\underline{Dataset}

```{r}
# Only include those in treatment group who DID NOT receive any part of the treatment
# Only include those in control group who DID NOT receive any part of treatment
modelDat_SpW <- modelDat %>%
  filter(X1_ik_vmmc != "Yes", X2_ik == 0) # Exclude anyone who got any part of the treatment
```

The total sample size for this analysis is `r nrow(modelDat_SpW)`, meaning that `r nrow(modelDat) - nrow(modelDat_SpW)` individuals are excluded. 

\underline{Data Characteristics}

```{r, include = FALSE}
var_order_SpW <- c("Gender", "HIV Status at Start", "Treatment Component: MC",
                   "Treatment Component: VMMC",
                    "Treatment Component: HTC", "Treatment Component: Full",
                    "Outcome: HIV Seroconversion (3-year period)")
level_order_SpW <- c("Male", "Yes", "No", "Began study circumcised", "Female",
                      "HIV-uninfected", "HIV-infected", "Refused HIV testing",
                      "Began study HIV-infected")

baseline_SpW <- modelDat_SpW %>%
  mutate(endpoint_coverage_vmmc = ifelse(endpoint_coverage_mc == "Yes", "Yes", 
                       ifelse(endpoint_coverage_mc %in% c("Began study circumcised", "No"), "No",
                              ifelse(endpoint_coverage_mc == "Female", "Female", NA)))) %>%
  dplyr::select(`Treatment Group` = random_arm,
                `Cluster Size` = cluster_size,
                `Gender` = gender,
                `HIV Status at Start` = hiv_status_current,
                `Treatment Component: MC` = endpoint_coverage_mc,
                `Treatment Component: VMMC` = endpoint_coverage_vmmc,
                `Treatment Component: HTC` = endpoint_coverage_htc,
                `Treatment Component: Full` = endpoint_coverage_full,
                `Outcome: HIV Seroconversion (3-year period)` = endpoint_seroconvert) %>%
  mutate(across(
    where(~ !is.numeric(.x)),
    ~ ifelse(is.na(.x), "Missing", as.character(.x))
  ))

# No missing observed
# baseline_missing_SpW <- baseline_SpW %>%
#   dplyr::select(-`Cluster Size`) %>%
#   filter(if_any(everything(), ~ .x == "Missing")) %>%
#   mutate(across(
#     .cols = -c(`Treatment Group`),  # replace col1 and col2 with your actual column names
#     .fns = ~ if_else(.x == "Missing", 1, 0)
#   )) %>%
#   group_by(`Treatment Group`) %>%
#   summarise(across(
#     everything(),  # No need to exclude the grouping var here
#     sum,
#     .names = "{.col}"
#   )) %>%
#   dplyr::select(-Gender) %>%
#   ungroup() %>%
#   pivot_longer(
#     cols = -`Treatment Group`,  # gather all variables except the group
#     names_to = "Variable",
#     values_to = "Missing"
#   ) %>%
#   pivot_wider(
#     names_from = `Treatment Group`,
#     values_from = Missing
#   ) %>%
#   mutate(Overall = Control + Treatment) %>%
#   rename(`Missing (Control)` = Control,
#          `Missing (Treatment)` = Treatment,
#          `Missing (Overall)` = Overall)

cluster_size_SpW <- tibble(Variable = c("Number of Individuals", 
                                    "Number of Clusters", 
                                    "Mean Cluster Size"),
                       Level = c(NA, NA, NA),
                       Control = c(nrow(dplyr::filter(modelDat_SpW, random_arm == "Control")),
                                   length(unique(dplyr::filter(modelDat_SpW, random_arm == "Control")$cluster_id)),
                                   mean(filter(modelDat_SpW, random_arm == "Control")$cluster_size)),
                       Treatment = c(nrow(dplyr::filter(modelDat_SpW, random_arm == "Treatment")),
                                     length(unique(dplyr::filter(modelDat_SpW, random_arm == "Treatment")$cluster_id)),
                                     mean(filter(modelDat_SpW, random_arm == "Treatment")$cluster_size))) %>%
  mutate(Control = as.integer(Control), Treatment = as.integer(Treatment)) %>%
  mutate(Overall = ifelse(Variable != "Mean Cluster Size", Treatment + Control, round((Treatment + Control) / 2, 1)))

baseline_tab_SpW <- baseline_SpW %>%
  dplyr::select(-`Cluster Size`) %>%
  pivot_longer(!`Treatment Group`, 
               names_to = "Variable", values_to = "Level") %>%
  arrange(`Treatment Group`, Variable, Level) %>%
  group_by(`Treatment Group`, Variable, Level) %>%
  dplyr::summarize(n = n()) %>%
  ungroup() %>%
  filter(Level != "Missing") %>%
  group_by(`Treatment Group`, `Variable`) %>%
  mutate(Overall = sum(n)) %>%
  ungroup() %>%
  rowwise() %>%
  mutate(percentage = paste0("(", round(n/Overall, 2)*100, "%)")) %>%
  mutate(n = paste(n, percentage)) %>%
  dplyr::select(-Overall, -percentage) %>%
  pivot_wider(
    names_from = `Treatment Group`,
    values_from = n
  ) %>%
  mutate(
    Overall = parse_number(Control) + parse_number(Treatment)
  ) %>%
  group_by(Variable) %>%
  mutate(Sum = sum(Overall)) %>%
  mutate(Overall = paste0(Overall, " (", round(Overall/Sum, 2)*100, "%)")) %>%
  dplyr::select(-Sum) %>%
  mutate(Variable = factor(Variable, levels = var_order_full),
         Level = factor(Level, levels = level_order_full)) %>%
  arrange(Variable, Level)

n_treat_SpW <- nrow(filter(modelDat_SpW, random_arm == "Treatment"))
n_control_SpW <- nrow(filter(modelDat_SpW, random_arm == "Control"))
n_overall_SpW <- nrow(modelDat_SpW)

final_baseline_SpW_table <- rbind(cluster_size_SpW, baseline_tab_SpW) %>%
  #left_join(baseline_missing_SpW, by = "Variable") %>% No missing observed
  group_by(Variable) %>%
  mutate(
    Variable = if_else(row_number() == 1, Variable, NA_character_)
  #   `Missing (Control)` = if_else(row_number() == 1, `Missing (Control)`, NA_integer_),
  #   `Missing (Treatment)` = if_else(row_number() == 1, `Missing (Treatment)`, NA_integer_),
  #   `Missing (Overall)` = if_else(row_number() == 1, `Missing (Overall)`, NA_integer_)
  ) 
  # ungroup() %>%
  # mutate(`Missing (Control)` = as.integer(`Missing (Control)`),
  #        `Missing (Treatment)` = as.integer(`Missing (Treatment)`),
  #        `Missing (Overall)` = as.integer(`Missing (Overall)`)) %>%
  # rowwise() %>%
  # mutate(`Missing (Control)` = ifelse(!is.na(`Missing (Control)`), 
  #                                     paste0(`Missing (Control)`, " (", 
  #                                            round(`Missing (Control)`/n_control_full, 2)*100, "%)"), NA),
  #        `Missing (Treatment)` = ifelse(!is.na(`Missing (Treatment)`), 
  #                                       paste0(`Missing (Treatment)`, " (", 
  #                                              round(`Missing (Treatment)`/n_treat_full, 2)*100, "%)"), NA),
  #        `Missing (Overall)` = ifelse(!is.na(`Missing (Overall)`), 
  #                                     paste0(`Missing (Overall)`, " (", 
  #                                            round(`Missing (Overall)`/n_overall_full, 2)*100, "%)"), NA))

```



```{r, results = 'asis', echo = FALSE}
cat("\\begin{landscape}\n")

print(
  xtable(
    final_baseline_SpW_table,
    caption = "Characteristics of Spillover Effects Analysis Data",
  ),
  type = "latex",
  include.rownames = FALSE,
  comment = FALSE
)

cat("\\end{landscape}\n")
```

\newpage

### B. Total Within-Cluster Spillover Effect of the Intervention

"SpW" denotes total spillover within intervention clusters. This compares participants in intervention villages who received neither relevant intervention component to people in the control villages (who also did not receive any part of the intervention component)

Then, under certain assumptions, the only way for an intervention village participant to have lower HIV risk is by association with others in the village with lower HIV risk because of their exposure to the intervention. 

$$logit(Y_{ik}) = \beta_0^{\text{SpW}} + \beta_1^{\text{SpW}}(T_{k})$$

Then $\exp\left( \beta_1^{\text{SpW}} \right)$ is a within-village spillover OR, and estimates the causal effect of living in a CP village, despite receiving no components oneself, on the odds of seroconversion. This is total within-village spillover effect. 

```{r}
# Total Within-Cluster Spillover Effect of the Intervention Model

# Model not accounting for clustering
model_SpW <- glm(Y_ik ~ T_k,
                 family = binomial(link = 'logit'),
                 data = modelDat_SpW) # Exclude those who received full trt

# Model accounting for clustering using GLMM
model_SpW_glmm <- glmer(Y_ik ~ T_k + (1|cluster_id), # Uses exchangeable structure
                        data = modelDat_SpW, 
                        family = binomial(link = "logit"))

# Model accounting for clustering using GEE
model_SpW_gee <- geeglm(Y_ik ~ T_k,
                        family = binomial(link = "logit"), # logit link
                        id = cluster_id, # clustering variable
                        data = modelDat_SpW,
                        corstr  = "exchangeable") # working correlation
```

```{r, echo = FALSE}
# GLM Model
model_SpW_summary <- summary(model_SpW) # Save model summary

exp_beta_SpW_0 <- exp(model_SpW_summary$coefficients[1,1]) # Intercept
exp_beta_SpW_1 <- exp(model_SpW_summary$coefficients[2,1]) # T_k Coefficient

tidy_SpW <- broom::tidy(model_SpW, conf.int = TRUE, exponentiate = TRUE) %>%
  dplyr::select(term, estimate, std.error, p.value, conf.low, conf.high) %>%
  mutate(Model = "GLM",
         Term = term,
         `OR [95% CI]` = paste0(round(estimate, 3), " [", 
                            round(conf.low, 3), ", ", 
                            round(conf.high, 3), "]"),
         `p-value` = round(p.value, 3)) %>%
  dplyr::select(Model, Term, `OR [95% CI]`, `p-value`) %>%
  dplyr::filter(Term != "(Intercept)") %>%
  mutate(ICC = NA)

# GLMM Model
model_SpW_summary_glmm <- summary(model_SpW_glmm) # Save model summary

exp_beta_SpW_0_glmm <- exp(model_SpW_summary_glmm$coefficients[1,1]) # Intercept
exp_beta_SpW_1_glmm <- exp(model_SpW_summary_glmm$coefficients[2,1]) # T_k Coefficient

tidy_SpW_glmm <- broom.mixed::tidy(model_SpW_glmm, effects = "fixed", 
                  conf.int = TRUE, exponentiate = TRUE) %>%
  dplyr::select(term, estimate, std.error, p.value, conf.low, conf.high) %>%
  mutate(Model = "GLMM",
         Term = term,
         `OR [95% CI]` = paste0(round(estimate, 3), " [", 
                            round(conf.low, 3), ", ", 
                            round(conf.high, 3), "]"),
         `p-value` = round(p.value, 3)) %>%
  dplyr::select(Model, Term, `OR [95% CI]`, `p-value`) %>%
  dplyr::filter(Term != "(Intercept)") %>%
  mutate(ICC = round(performance::icc(model_SpW_glmm)$ICC_adjusted[[1]], 3))

# GEE Model
model_SpW_summary_gee <- summary(model_SpW_gee) # Save model summary

exp_beta_SpW_0_gee <- exp(model_SpW_summary_gee$coefficients[1,1]) # Intercept
exp_beta_SpW_1_gee <- exp(model_SpW_summary_gee$coefficients[2,1]) # T_k Coefficient

tidy_SpW_gee <- broom::tidy(model_SpW_gee, conf.int = TRUE, 
                            exponentiate = TRUE) %>%
  dplyr::select(term, estimate, std.error, p.value, conf.low, conf.high) %>%
  mutate(Model = "GEE",
         Term = term,
         `OR [95% CI]` = paste0(round(estimate, 3), " [", 
                            round(conf.low, 3), ", ", 
                            round(conf.high, 3), "]"),
         `p-value` = round(p.value, 3)) %>%
  dplyr::select(Model, Term, `OR [95% CI]`, `p-value`) %>%
  dplyr::filter(Term != "(Intercept)") %>%
  mutate(ICC = round(model_SpW_gee$geese$alpha[[1]], 3))

# Overall Output Table for SpW
SpW_Model_Table <- rbind(tidy_SpW, tidy_SpW_glmm) %>%
  rbind(tidy_SpW_gee)
```

```{r, results = 'asis', echo = FALSE}
print(xtable(SpW_Model_Table, 
             caption = "Spillover Within Intervention Clusters Model Output"), 
      type = 'latex', include.rownames = FALSE, comment = FALSE)
```

Thus, among people who received none of the intervention components, those living in CP villages had `r (1-round(exp_beta_SpW_1, 2))*100`% lower odds of HIV seroconversion than otherwise comparable untreated people in control villages. Since every individual in this analytic set is personally untreated, any difference in their HIV risk can only arise from indirect protection, and thus, `r round(exp_beta_SpW_1, 2)` is interpreted as the within-village spillover effect of CP.

\newpage

### C. Within-Cluster Spillover of the Intervention Effect Not through Male Circumcision

"SpWR" denotes all the remaining spillover that affects one's outcome that exists when we block the mediated spillover path that exists through male circumcision. 

$$logit(Y_{ik}) = \beta_0^{\text{SpWR}} + \beta_1^{\text{SpWR}}(T_{k}) + \beta_2^{\text{SpWR}}(Z_k^{(1, \text{VMMC})})$$

Here, $\exp\left(\beta_1^{\text{SpWR}} \right)$ compares untreated individuals in CP villages with untreated individuals in control villages after we hold the village's male-circumcision coverage fixed at the same value for both groups. So, it's the OR for the remaining within-village spillover - whatever protection (or risk) is left once the male-circumcision pathway has been accounted for. 

```{r}
test <- glm(Y_ik ~ Z1_k_vmmc,
                  family = binomial(link = 'logit'),
                  data = modelDat_SpW)

summary(test)
```


```{r}
# Within-Cluster Spillover of the Intervention Not Through MC

# Model not accounting for clustering
model_SpWR <- glm(Y_ik ~ T_k + Z1_k_vmmc,
                  family = binomial(link = 'logit'),
                  data = modelDat_SpW)

# Model accounting for clustering using GLMM
model_SpWR_glmm <- glmer(Y_ik ~ T_k + Z1_k_vmmc + (1|cluster_id), # Uses exchangeable
                         data = modelDat_SpW, 
                         family = binomial(link = "logit"))

# Model accounting for clustering using GEE
model_SpWR_gee <- geeglm(Y_ik ~ T_k + Z1_k_vmmc,
                         family = binomial(link = "logit"),
                         id = cluster_id,
                         data = modelDat_SpW,
                         corstr = "exchangeable") # working correlation
```

```{r, echo = FALSE}
# GlM Model
model_SpWR_summary <- summary(model_SpWR) # Save model summary

exp_beta_SpWR_0 <- exp(model_SpWR_summary$coefficients[1,1]) # Intercept
exp_beta_SpWR_1 <- exp(model_SpWR_summary$coefficients[2,1]) # T_k Coefficient
exp_beta_SpWR_2 <- exp(model_SpWR_summary$coefficients[3,1]) # Z1_k_vmmc Coefficient

tidy_SpWR <- broom::tidy(model_SpWR, conf.int = TRUE, exponentiate = TRUE) %>%
  dplyr::select(term, estimate, std.error, p.value, conf.low, conf.high) %>%
  mutate(Model = "GLM",
         Term = term,
         `OR [95% CI]` = paste0(round(estimate, 3), " [", 
                            round(conf.low, 3), ", ", 
                            round(conf.high, 3), "]"),
         `p-value` = round(p.value, 3)) %>%
  dplyr::select(Model, Term, `OR [95% CI]`, `p-value`) %>%
  dplyr::filter(Term != "(Intercept)") %>%
  mutate(ICC = NA)

# GLMM Model
model_SpWR_summary_glmm <- summary(model_SpWR_glmm) # Save model summary
exp_beta_SpWR_0_glmm <- exp(model_SpWR_summary_glmm$coefficients[1,1]) # Intercept
exp_beta_SpWR_1_glmm <- exp(model_SpWR_summary_glmm$coefficients[2,1]) # T_k Coefficient
exp_beta_SpWR_2_glmm <- exp(model_SpWR_summary_glmm$coefficients[3,1]) # Z1_k_vmmc Coefficient

tidy_SpWR_glmm <- broom.mixed::tidy(model_SpWR_glmm, effects = "fixed", 
                  conf.int = TRUE, exponentiate = TRUE) %>%
  dplyr::select(term, estimate, std.error, p.value, conf.low, conf.high) %>%
  mutate(Model = "GLMM",
         Term = term,
         `OR [95% CI]` = paste0(round(estimate, 3), " [", 
                            round(conf.low, 3), ", ", 
                            round(conf.high, 3), "]"),
         `p-value` = round(p.value, 3)) %>%
  dplyr::select(Model, Term, `OR [95% CI]`, `p-value`) %>%
  dplyr::filter(Term != "(Intercept)") %>%
  mutate(ICC = c(round(performance::icc(model_SpW_glmm)$ICC_adjusted[[1]], 3), NA))

# GEE Model
model_SpWR_summary_gee <- summary(model_SpWR_gee) # Save model summary

exp_beta_SpWR_0_gee <- exp(model_SpWR_summary_gee$coefficients[1,1]) # Intercept
exp_beta_SpWR_1_gee <- exp(model_SpWR_summary_gee$coefficients[2,1]) # T_k Coefficient
exp_beta_SpWR_2_gee <- exp(model_SpWR_summary_gee$coefficients[3,1]) # Z1_k_vmmc Coefficient

tidy_SpWR_gee <- broom::tidy(model_SpWR_gee, conf.int = TRUE, 
                            exponentiate = TRUE) %>%
  dplyr::select(term, estimate, std.error, p.value, conf.low, conf.high) %>%
  mutate(Model = "GEE",
         Term = term,
         `OR [95% CI]` = paste0(round(estimate, 3), " [", 
                            round(conf.low, 3), ", ", 
                            round(conf.high, 3), "]"),
         `p-value` = round(p.value, 3)) %>%
  dplyr::select(Model, Term, `OR [95% CI]`, `p-value`) %>%
  dplyr::filter(Term != "(Intercept)") %>%
  mutate(ICC = c(round(model_SpWR_gee$geese$alpha[[1]], 3), NA))

# Overall Output Table for SpW
SpWR_Model_Table <- rbind(tidy_SpWR, tidy_SpWR_glmm) %>%
  rbind(tidy_SpWR_gee)
```

```{r, results = 'asis', echo = FALSE}
print(xtable(SpWR_Model_Table, 
             caption = "Spillover Not Due to Male Circumcision Model Output"), 
      type = 'latex', include.rownames = FALSE, comment = FALSE)
```

After we hold village circumcision coverage fixed, untreated residence of CP villages will still have a `r (1 - round(exp_beta_SpWR_1, 2))*100`% lower odds of seroconversion than untreated residence of control villages. This is spillover that operates through pathways other than male-circumcision coverage (e.g. HTC uptake, general behavior change, program outreach). 

Then, moving from a 0% to 100% male circumcised coverage in a village multiplies an untreated person's odds of seroconversion by `r round(exp_beta_SpWR_2, 2)`. This means `r (1 - round(exp_beta_SpWR_2, 2))*100`% lower odds of HIV acquisition for an untreated person when their village goes from zero to complete male-circumcision coverage.  
\newpage


### D. Indirect Spillover Effects Through VMMC


```{r, echo = FALSE}
SpW_DirectIndirect_Table <- tibble(
  Model = c("GLM", "GLMM", "GEE")) %>%
  mutate(
    `Direct Effect` = c(exp_beta_SpWR_1, 
                       exp_beta_SpWR_1_glmm,
                       exp_beta_SpWR_1_gee),
    `Indirect Effect` = c(exp(log(exp_beta_SpW_1)-log(exp_beta_SpWR_1)), 
                       exp(log(exp_beta_SpW_1_glmm)-log(exp_beta_SpWR_1_glmm)),
                       exp(log(exp_beta_SpW_1_gee) - log(exp_beta_SpWR_1_gee))),
    `Total Effect` = c(exp_beta_SpW_1, 
                       exp_beta_SpW_1_glmm,
                       exp_beta_SpW_1_gee), 
  ) %>%
  mutate(across(where(is.numeric), ~ round(.x, 3)))
```

```{r, results = 'asis', echo = FALSE}
print(xtable(SpW_DirectIndirect_Table, 
             caption = "Direct, Indirect, and Total Spillover Effects of Treatment Assignment (Shown as ORs)"), 
      type = 'latex', include.rownames = FALSE, comment = FALSE)
```



\newpage

### E. Proportion of Within-Intervention Village Spillover Effect Mediated by Circumcision

Then, the proportion of within-intervention village spillover effect mediated by circumcision is

$$\frac{\beta_1^{\text{SpW}} - \beta_1^{\text{SpWR}}}{\beta_1^{\text{SpW}}}$$

Essentially, this is the total spillover minus the spillover that exists except through the circumcision component, divided by spillover total. 

```{r, include = FALSE}
# Proportion of within-intervention village spillover effect mediated by MC
proportion_SpW <- tibble(Model = c("GLM", "GLMM", "GEE"),
                         `Proportion of Spillover Mediated by MC` = c((log(exp_beta_SpW_1) - log(exp_beta_SpWR_1)) / log(exp_beta_SpW_1),
                                                                      (log(exp_beta_SpW_1_glmm) - log(exp_beta_SpWR_1_glmm)) / log(exp_beta_SpW_1_glmm),
                                                                      (log(exp_beta_SpW_1_gee) - log(exp_beta_SpWR_1_gee)) / log(exp_beta_SpW_1_gee))) %>%
  mutate(`95 CI` = c("(0.003, 0.189)", "(0.003, 0.188)", "(0.004, 0.187)"))
```

```{r, results = 'asis', echo = FALSE}
print(xtable(proportion_SpW, 
             caption = "Proportion of Within-Cluster Spillover Due to Male Circumcision"), 
      type = 'latex', include.rownames = FALSE, comment = FALSE)
```

Thus, about `r round((log(exp_beta_SpW_1) - log(exp_beta_SpWR_1)) / log(exp_beta_SpW_1), 2)*100`% of within-village spillover protection experienced by untreated people in CP villages is explained by the higher male-circumcision coverage in those villages. The remaining spillover benefit must come through other village-level channels (e.g. HTC uptake, community health behavior change, program outreach, etc.)

#### Calculating the Confidence Interval for Proportion Mediated

Delta Method: First-order Taylor approximation for the variance of a smooth function $g(\hat{\theta})$ of estimators, where 
$$\text{Var} \left\{ g(\hat{\theta}) \right\} \approx \nabla g(\hat{\theta})^T \hat{\text{Var}}(\hat{\theta}) \nabla g(\hat{\theta})$$
where $\nabla g$ is the gradient of $g$ with respects to $\theta$ evaluated at the estimates.

To simplify notation, let $a = \beta_1^{\text{SpW}}$ and $c = \beta_1^{\text{SpWR}}$. On the log-odds scale, the proportion of spillover mediated by VMMC is
$$\text{PSM} = \frac{a - c}{a} = 1 - \frac{c}{a}$$

Using the Delta Method, define $g(a, c) = 1 - \frac{c}{a}$. The gradient at $(a, c)$ is
$$\nabla g(a, c) = \left( \frac{c}{a^2}, -\frac{1}{a} \right)$$

Let $\theta = (a, c)^T$ and let $\Sigma = \text{Var}(\hat{\theta})$ be the joint $2 \times 2$ covariance matrix of $(\hat{a}, \hat{c})$. The delta-method variance of $\hat{\text{PSM}} = g(\hat{a}, \hat{c})$ is
$$\text{Var}(\hat{\text{PSM}}) \approx \nabla g(\hat{a}, \hat{c})^T \Sigma \nabla g(\hat{a}, \hat{c})$$

Expanding the quadratic form gives the following form:
$$\text{Var}(\hat{\text{PSM}}) \approx \frac{c^2}{a^4} \text{Var}(\hat{a}) + \frac{1}{a^2} \text{Var}(\hat{c}) - \frac{2c}{a^3} \text{Cov}(\hat{a}, \hat{c})$$

and the normal-approximation CI is
$$\hat{\text{PSM}} \pm z_{1-\alpha/2} \sqrt{\text{Var}(\hat{\text{PSM}})}$$

In each bootstrap $b$, we can refit the models on the same resampled clusters to get $(\hat{a}^{(c)}, \hat{c}^{(b)})$, and then
$$\hat{\Sigma} = \text{Cov}_{\text{boot}}(\hat{a}^{(b)}, \hat{c}^{(b)})$$

GLM CI for PSM

```{r, echo = FALSE, include = FALSE}
# ------------------------------------------------------------
# Spillover proportion mediated (GLM) with cluster bootstrap + delta CI
#   SpW  model:  Y_ik ~ T_k
#   SpWR model:  Y_ik ~ T_k + Z1_k_vmmc
#
# PM_spill = (a - c) / a = 1 - c/a,
#   where a = beta_T from SpW, c = beta_T from SpWR (logit scale).
#
# Bootstrap design (no penalization):
#   * Resample clusters with replacement (size = # unique clusters)
#   * Force-in ALL clusters with any Y_ik = 1 at least once (stability)
#   * Stratify by treatment so treated/control cluster counts match original
#   * Allow event clusters to be drawn again in the fill step (adds variability)
#
# Returns point estimate, percentile CI for PM, and delta-method CI using
# the bootstrapped joint covariance of (a, c). Plain glm() with higher maxit.
# ------------------------------------------------------------
pm_spill_boot_with_delta_glm <- function(dat, id = "cluster_id",
                                         B = 1000, level = 0.95,
                                         force_event_once = TRUE,
                                         allow_dup_events = TRUE,
                                         seed = NULL, verbose = TRUE) {
  if (!is.null(seed)) set.seed(seed)
  stopifnot(is.data.frame(dat))

  # --- sanity: required columns
  req <- c(id, "Y_ik", "T_k", "Z1_k_vmmc")
  miss <- setdiff(req, names(dat))
  if (length(miss)) stop("Missing columns: ", paste(miss, collapse = ", "))

  # --- formulas
  f_SpW  <- stats::as.formula("Y_ik ~ T_k")
  f_SpWR <- stats::as.formula("Y_ik ~ T_k + Z1_k_vmmc")

  # --- cluster-level treatment & event flags
  cl_T <- tapply(dat$T_k, dat[[id]], function(x) {
    u <- unique(x); if (length(u) == 1) u else as.numeric(mean(x, na.rm = TRUE) >= 0.5)
  })
  cl_event <- tapply(dat$Y_ik, dat[[id]], function(y) any(y == 1, na.rm = TRUE))

  cl_t1 <- names(cl_T)[cl_T == 1]
  cl_t0 <- names(cl_T)[cl_T == 0]
  n1 <- length(cl_t1); n0 <- length(cl_t0)

  evt_t1 <- intersect(cl_t1, names(cl_event)[cl_event])
  evt_t0 <- intersect(cl_t0, names(cl_event)[cl_event])

  # pools to fill from (optionally include event clusters again)
  pool_t1 <- if (allow_dup_events) cl_t1 else setdiff(cl_t1, evt_t1)
  pool_t0 <- if (allow_dup_events) cl_t0 else setdiff(cl_t0, evt_t0)

  # helper: draw one set of cluster IDs (stratified; force-in events)
  make_sample_ids <- function() {
    base <- if (force_event_once) c(evt_t1, evt_t0) else character(0)
    fill_t1 <- if (n1 - length(evt_t1) > 0) sample(pool_t1, n1 - length(evt_t1), replace = TRUE) else character(0)
    fill_t0 <- if (n0 - length(evt_t0) > 0) sample(pool_t0, n0 - length(evt_t0), replace = TRUE) else character(0)
    c(base, fill_t1, fill_t0)
  }

  # --- point estimates on full data
  ctrl <- stats::glm.control(maxit = 50)
  fit_SpW  <- stats::glm(f_SpW,  family = stats::binomial(), data = dat, control = ctrl)
  fit_SpWR <- stats::glm(f_SpWR, family = stats::binomial(), data = dat, control = ctrl)

  a0 <- unname(stats::coef(fit_SpW )["T_k"])     # beta_T from SpW
  c0 <- unname(stats::coef(fit_SpWR)["T_k"])     # beta_T from SpWR

  PM0 <- if (is.finite(a0) && abs(a0) > .Machine$double.eps) 1 - c0/a0 else NA_real_

  # --- bootstrap draws: store theta = (a, c) and PM
  theta <- matrix(NA_real_, nrow = B, ncol = 2, dimnames = list(NULL, c("a","c")))
  PM    <- rep(NA_real_, B)
  if (verbose) msg_every <- max(1, floor(B/10))

  for (b in seq_len(B)) {
    samp_ids <- make_sample_ids()
    boot_dat <- do.call(rbind, lapply(samp_ids, function(k) dat[dat[[id]] == k, , drop = FALSE]))

    fitW  <- suppressWarnings(stats::glm(f_SpW,  family = stats::binomial(), data = boot_dat, control = ctrl))
    fitWR <- suppressWarnings(stats::glm(f_SpWR, family = stats::binomial(), data = boot_dat, control = ctrl))

    a <- suppressWarnings(unname(stats::coef(fitW )["T_k"]))
    c <- suppressWarnings(unname(stats::coef(fitWR)["T_k"]))

    if (all(is.finite(c(a, c)))) {
      theta[b, ] <- c(a = a, c = c)
      PM[b] <- if (abs(a) > .Machine$double.eps) 1 - c/a else NA_real_
    } else {
      PM[b] <- NA_real_
    }

    if (verbose && b %% msg_every == 0) message("bootstrap: ", b, "/", B)
  }

  # --- percentile CI for PM (pure bootstrap)
  alpha <- (1 - level)/2
  ci_boot <- stats::quantile(PM, probs = c(alpha, 1 - alpha), na.rm = TRUE)

  # --- delta-method CI using bootstrapped joint covariance of (a, c)
  # gradient of g(a,c)=1 - c/a  ⇒  (∂g/∂a, ∂g/∂c) = (c/a^2,  -1/a)
  if (is.finite(PM0) && abs(a0) > .Machine$double.eps) {
    g1 <-  c0 / (a0^2)
    g2 <- -1  /  a0
    grad <- c(g1, g2)

    Sigma_hat <- stats::cov(theta, use = "pairwise.complete.obs")  # 2x2 joint cov of (a,c)
    var_PM    <- as.numeric(t(grad) %*% Sigma_hat %*% grad)
    se_PM     <- sqrt(var_PM)
    z         <- stats::qnorm(1 - alpha)
    ci_delta  <- PM0 + c(-1, 1) * z * se_PM
  } else {
    ci_delta <- c(NA_real_, NA_real_)
  }

  list(
    point_PM      = PM0,
    ci_boot_PM    = ci_boot,
    ci_delta_PM   = ci_delta,
    boot_draws_PM = PM,
    boot_theta    = theta,               # columns: a, c
    Sigma_hat     = if (exists("Sigma_hat")) Sigma_hat else NULL,
    settings      = list(B = B, level = level,
                         force_event_once = force_event_once,
                         allow_dup_events  = allow_dup_events)
  )
}

```

```{r, echo = FALSE, include = FALSE, eval = FALSE}
set.seed(123)
res_sp_glm <- pm_spill_boot_with_delta_glm(modelDat_SpW, id = "cluster_id",
                                           B = 1000, verbose = TRUE)
res_sp_glm$point_PM
res_sp_glm$ci_boot_PM
res_sp_glm$ci_delta_PM
```


GLMM CI for PSM

```{r, echo = FALSE, include = FALSE}
# ------------------------------------------------------------
# Spillover proportion mediated (GLMM) with cluster bootstrap + delta CI
#   SpW  (GLMM):  Y_ik ~ T_k + (1 | cluster_id)
#   SpWR (GLMM):  Y_ik ~ T_k + Z1_k_vmmc + (1 | cluster_id)
#
# PM_spill = (a - c) / a = 1 - c/a,
#   where a = beta_T from SpW, c = beta_T from SpWR (logit scale).
#
# Bootstrap design (no penalization):
#   * Resample clusters with replacement (size = # unique clusters)
#   * Force-in ALL clusters with any Y_ik = 1 at least once (stability)
#   * Stratify by treatment so treated/control cluster counts match original
#   * For GLMM, duplicate draws are given NEW random-effect labels (.boot_id)
#
# Returns: PM point estimate, percentile CI, delta-method CI using boot Sigma.
# ------------------------------------------------------------
pm_spill_boot_with_delta_glmm <- function(dat, id = "cluster_id",
                                          B = 500, level = 0.95,
                                          force_event_once = TRUE,
                                          allow_dup_events = TRUE,
                                          seed = NULL, verbose = TRUE) {
  if (!is.null(seed)) set.seed(seed)
  if (!requireNamespace("lme4", quietly = TRUE)) {
    stop("Package 'lme4' is required. Please install it.")
  }
  stopifnot(is.data.frame(dat))
  req <- c(id, "Y_ik", "T_k", "Z1_k_vmmc")
  miss <- setdiff(req, names(dat))
  if (length(miss)) stop("Missing columns: ", paste(miss, collapse = ", "))

  # --- GLMM controls (help convergence a bit)
  ctrl <- lme4::glmerControl(optimizer = "bobyqa",
                             optCtrl = list(maxfun = 2e5),
                             check.conv.grad = "ignore",
                             check.conv.singular = "ignore")

  # --- Full-data fits -> point estimates
  fW_full  <- stats::as.formula(paste0("Y_ik ~ T_k + (1|", id, ")"))
  fWR_full <- stats::as.formula(paste0("Y_ik ~ T_k + Z1_k_vmmc + (1|", id, ")"))

  fitW  <- suppressWarnings(lme4::glmer(fW_full,  family = stats::binomial(), data = dat, control = ctrl))
  fitWR <- suppressWarnings(lme4::glmer(fWR_full, family = stats::binomial(), data = dat, control = ctrl))

  a0 <- as.numeric(lme4::fixef(fitW )["T_k"])   # beta_T from SpW
  c0 <- as.numeric(lme4::fixef(fitWR)["T_k"])   # beta_T from SpWR

  PM0 <- if (is.finite(a0) && abs(a0) > .Machine$double.eps) 1 - c0/a0 else NA_real_

  # --- Cluster-level treatment & event flags for stratified resampling
  cl_T <- tapply(dat$T_k, dat[[id]], function(x) {
    u <- unique(x); if (length(u) == 1) u else as.numeric(mean(x, na.rm = TRUE) >= 0.5)
  })
  cl_event <- tapply(dat$Y_ik, dat[[id]], function(y) any(y == 1, na.rm = TRUE))

  cl_t1 <- names(cl_T)[cl_T == 1];  cl_t0 <- names(cl_T)[cl_T == 0]
  n1 <- length(cl_t1);              n0 <- length(cl_t0)

  evt_t1 <- intersect(cl_t1, names(cl_event)[cl_event])
  evt_t0 <- intersect(cl_t0, names(cl_event)[cl_event])

  pool_t1 <- if (allow_dup_events) cl_t1 else setdiff(cl_t1, evt_t1)
  pool_t0 <- if (allow_dup_events) cl_t0 else setdiff(cl_t0, evt_t0)

  # --- Build one bootstrap dataset with new random-effect IDs
  make_boot_df <- function() {
    base    <- if (force_event_once) c(evt_t1, evt_t0) else character(0)
    fill_t1 <- if (n1 - length(evt_t1) > 0) sample(pool_t1, n1 - length(evt_t1), replace = TRUE) else character(0)
    fill_t0 <- if (n0 - length(evt_t0) > 0) sample(pool_t0, n0 - length(evt_t0), replace = TRUE) else character(0)
    samp_ids <- c(base, fill_t1, fill_t0)

    parts <- vector("list", length(samp_ids))
    for (j in seq_along(samp_ids)) {
      k <- samp_ids[j]
      d <- dat[dat[[id]] == k, , drop = FALSE]
      d[[".boot_id"]] <- paste0("C", j, "_", k)   # NEW random-effect label for this copy
      parts[[j]] <- d
    }
    out <- do.call(rbind, parts)
    out[[".boot_id"]] <- factor(out[[".boot_id"]])
    out
  }

  # --- Bootstrap storage
  theta <- matrix(NA_real_, nrow = B, ncol = 2, dimnames = list(NULL, c("a","c")))
  PM     <- rep(NA_real_, B)
  if (verbose) msg_every <- max(1, floor(B/10))

  # --- GLMM formulas using .boot_id as grouping factor
  fW_boot  <- stats::as.formula("Y_ik ~ T_k + (1|.boot_id)")
  fWR_boot <- stats::as.formula("Y_ik ~ T_k + Z1_k_vmmc + (1|.boot_id)")

  for (b in seq_len(B)) {
    boot_dat <- make_boot_df()

    fitWb  <- try(suppressWarnings(lme4::glmer(fW_boot,  family = stats::binomial(), data = boot_dat, control = ctrl)), silent = TRUE)
    fitWRb <- try(suppressWarnings(lme4::glmer(fWR_boot, family = stats::binomial(), data = boot_dat, control = ctrl)), silent = TRUE)

    if (!inherits(fitWb, "try-error") && !inherits(fitWRb, "try-error")) {
      feW  <- try(lme4::fixef(fitWb),  silent = TRUE)
      feWR <- try(lme4::fixef(fitWRb), silent = TRUE)
      if (!inherits(feW, "try-error") && !inherits(feWR, "try-error")) {
        a <- as.numeric(feW ["T_k"])
        c <- as.numeric(feWR["T_k"])
        if (all(is.finite(c(a, c)))) {
          theta[b, ] <- c(a = a, c = c)
          PM[b] <- if (abs(a) > .Machine$double.eps) 1 - c/a else NA_real_
        }
      }
    }

    if (verbose && b %% msg_every == 0) message("bootstrap: ", b, "/", B)
  }

  # --- Percentile CI for PM (pure bootstrap)
  alpha   <- (1 - level) / 2
  ci_boot <- stats::quantile(PM, probs = c(alpha, 1 - alpha), na.rm = TRUE)

  # --- Delta-method CI using bootstrapped joint covariance of (a, c)
  if (is.finite(PM0) && abs(a0) > .Machine$double.eps) {
    g1 <-  c0 / (a0^2)      # ∂PM/∂a
    g2 <- -1  /  a0         # ∂PM/∂c
    grad <- c(g1, g2)

    Sigma_hat <- stats::cov(theta, use = "pairwise.complete.obs")  # 2x2 cov of (a,c)
    var_PM    <- as.numeric(t(grad) %*% Sigma_hat %*% grad)
    se_PM     <- sqrt(var_PM)
    z         <- stats::qnorm(1 - alpha)
    ci_delta  <- PM0 + c(-1, 1) * z * se_PM
  } else {
    Sigma_hat <- NULL
    ci_delta  <- c(NA_real_, NA_real_)
  }

  list(
    point_PM      = PM0,
    ci_boot_PM    = ci_boot,
    ci_delta_PM   = ci_delta,
    boot_draws_PM = PM,
    boot_theta    = theta,   # columns: a (SpW T_k), c (SpWR T_k)
    Sigma_hat     = Sigma_hat,
    settings      = list(B = B, level = level,
                         force_event_once = force_event_once,
                         allow_dup_events  = allow_dup_events,
                         optimizer = "bobyqa", maxfun = 2e5)
  )
}
```

```{r, eval = FALSE, include = FALSE, eval = FALSE}
set.seed(123)
res_sp_glmm <- pm_spill_boot_with_delta_glmm(modelDat_SpW, id = "cluster_id",
                                             B = 400, verbose = TRUE)
res_sp_glmm$point_PM
res_sp_glmm$ci_boot_PM
res_sp_glmm$ci_delta_PM
```


GEE CI for PSM

```{r, echo = FALSE, include = FALSE}
# ------------------------------------------------------------
# Spillover proportion mediated (GEE) with cluster bootstrap + delta CI
#   SpW  (GEE):  Y_ik ~ T_k
#   SpWR (GEE):  Y_ik ~ T_k + Z1_k_vmmc
#
# PM_spill = (a - c) / a = 1 - c/a,
#   where a = beta_T from SpW, c = beta_T from SpWR (logit scale).
#
# Bootstrap design (no penalties):
#   * Resample clusters with replacement (size = # unique clusters)
#   * Force-in ALL clusters with any Y_ik = 1 at least once (stability)
#   * Stratify by treatment so treated/control cluster counts match original
#   * For GEE, duplicate draws get NEW IDs (.boot_id) so they are separate
#     working-correlation groups in each replicate.
# Returns: PM point estimate, percentile CI, delta-method CI using boot Sigma.
# ------------------------------------------------------------
pm_spill_boot_with_delta_gee <- function(dat, id = "cluster_id",
                                         B = 1000, level = 0.95,
                                         corstr = "exchangeable",
                                         force_event_once = TRUE,
                                         allow_dup_events = TRUE,
                                         seed = NULL, verbose = TRUE) {
  if (!is.null(seed)) set.seed(seed)
  if (!requireNamespace("geepack", quietly = TRUE)) {
    stop("Package 'geepack' is required. Please install it.")
  }
  stopifnot(is.data.frame(dat))
  req <- c(id, "Y_ik", "T_k", "Z1_k_vmmc")
  miss <- setdiff(req, names(dat))
  if (length(miss)) stop("Missing columns: ", paste(miss, collapse = ", "))

  # --- Formulas
  fW  <- stats::as.formula("Y_ik ~ T_k")                 # SpW
  fWR <- stats::as.formula("Y_ik ~ T_k + Z1_k_vmmc")     # SpWR

  # --- Point estimates (full data, original IDs)
  id_full <- dat[[id]]
  fitW  <- suppressWarnings(geepack::geeglm(fW,  id = id_full, data = dat,
                                            family = stats::binomial(), corstr = corstr))
  fitWR <- suppressWarnings(geepack::geeglm(fWR, id = id_full, data = dat,
                                            family = stats::binomial(), corstr = corstr))

  a0 <- as.numeric(stats::coef(fitW )["T_k"])   # beta_T from SpW
  c0 <- as.numeric(stats::coef(fitWR)["T_k"])   # beta_T from SpWR
  PM0 <- if (is.finite(a0) && abs(a0) > .Machine$double.eps) 1 - c0/a0 else NA_real_

  # --- Cluster-level treatment & event flags for stratified resampling
  cl_T <- tapply(dat$T_k, dat[[id]], function(x) {
    u <- unique(x); if (length(u) == 1) u else as.numeric(mean(x, na.rm = TRUE) >= 0.5)
  })
  cl_event <- tapply(dat$Y_ik, dat[[id]], function(y) any(y == 1, na.rm = TRUE))

  cl_t1 <- names(cl_T)[cl_T == 1];  cl_t0 <- names(cl_T)[cl_T == 0]
  n1 <- length(cl_t1);              n0 <- length(cl_t0)

  evt_t1 <- intersect(cl_t1, names(cl_event)[cl_event])
  evt_t0 <- intersect(cl_t0, names(cl_event)[cl_event])

  pool_t1 <- if (allow_dup_events) cl_t1 else setdiff(cl_t1, evt_t1)
  pool_t0 <- if (allow_dup_events) cl_t0 else setdiff(cl_t0, evt_t0)

  # --- One bootstrap dataset with NEW GEE IDs
  make_boot_df <- function() {
    base    <- if (force_event_once) c(evt_t1, evt_t0) else character(0)
    fill_t1 <- if (n1 - length(evt_t1) > 0) sample(pool_t1, n1 - length(evt_t1), replace = TRUE) else character(0)
    fill_t0 <- if (n0 - length(evt_t0) > 0) sample(pool_t0, n0 - length(evt_t0), replace = TRUE) else character(0)
    samp_ids <- c(base, fill_t1, fill_t0)

    parts <- vector("list", length(samp_ids))
    for (j in seq_along(samp_ids)) {
      k <- samp_ids[j]
      d <- dat[dat[[id]] == k, , drop = FALSE]
      d[[".boot_id"]] <- paste0("G", j, "_", k)  # unique working-corr group
      parts[[j]] <- d
    }
    out <- do.call(rbind, parts)
    out[[".boot_id"]] <- factor(out[[".boot_id"]])
    out
  }

  # --- Bootstrap storage
  theta <- matrix(NA_real_, nrow = B, ncol = 2, dimnames = list(NULL, c("a","c")))
  PM     <- rep(NA_real_, B)
  if (verbose) msg_every <- max(1, floor(B/10))

  for (b in seq_len(B)) {
    boot_dat <- make_boot_df()
    idB <- boot_dat[[".boot_id"]]

    fitWb  <- try(suppressWarnings(
      geepack::geeglm(fW,  id = idB, data = boot_dat, family = stats::binomial(), corstr = corstr)
    ), silent = TRUE)
    fitWRb <- try(suppressWarnings(
      geepack::geeglm(fWR, id = idB, data = boot_dat, family = stats::binomial(), corstr = corstr)
    ), silent = TRUE)

    if (!inherits(fitWb, "try-error") && !inherits(fitWRb, "try-error")) {
      a <- suppressWarnings(as.numeric(stats::coef(fitWb )["T_k"]))
      c <- suppressWarnings(as.numeric(stats::coef(fitWRb)["T_k"]))
      if (all(is.finite(c(a, c)))) {
        theta[b, ] <- c(a = a, c = c)
        PM[b] <- if (abs(a) > .Machine$double.eps) 1 - c/a else NA_real_
      } else {
        PM[b] <- NA_real_
      }
    } else {
      PM[b] <- NA_real_
    }

    if (verbose && b %% msg_every == 0) message("bootstrap: ", b, "/", B)
  }

  # --- Percentile CI for PM (pure bootstrap)
  alpha   <- (1 - level)/2
  ci_boot <- stats::quantile(PM, probs = c(alpha, 1 - alpha), na.rm = TRUE)

  # --- Delta-method CI using bootstrapped joint covariance of (a, c)
  if (is.finite(PM0) && abs(a0) > .Machine$double.eps) {
    g1 <-  c0 / (a0^2)   # ∂PM/∂a
    g2 <- -1  /  a0      # ∂PM/∂c
    grad <- c(g1, g2)

    Sigma_hat <- stats::cov(theta, use = "pairwise.complete.obs")  # 2x2 cov of (a,c)
    var_PM    <- as.numeric(t(grad) %*% Sigma_hat %*% grad)
    se_PM     <- sqrt(var_PM)
    z         <- stats::qnorm(1 - alpha)
    ci_delta  <- PM0 + c(-1, 1) * z * se_PM
  } else {
    Sigma_hat <- NULL
    ci_delta  <- c(NA_real_, NA_real_)
  }

  list(
    point_PM      = PM0,
    ci_boot_PM    = ci_boot,
    ci_delta_PM   = ci_delta,
    boot_draws_PM = PM,
    boot_theta    = theta,     # columns: a (SpW T_k), c (SpWR T_k)
    Sigma_hat     = Sigma_hat,
    settings      = list(B = B, level = level, corstr = corstr,
                         force_event_once = force_event_once,
                         allow_dup_events  = allow_dup_events)
  )
}

```

```{r, echo = FALSE, include = FALSE, eval = FALSE}
set.seed(123)
res_sp_gee <- pm_spill_boot_with_delta_gee(modelDat_SpW, id = "cluster_id",
                                           B = 300, corstr = "exchangeable")
res_sp_gee$point_PM
res_sp_gee$ci_boot_PM
res_sp_gee$ci_delta_PM
```



\newpage

## Individual Effects

\underline{Setup}

- In this analysis, we include only males in the study.

- Here, we will estimate the effects of the intervention assignment on the outcome. In the mediation model, we will account for if they actually received the circumcision component or not.

- This setup will allow us to estimate

    d. Total Individual Effect of Treatment Assignment
    e. Individual Direct Effects of Treatment Assignment
    f. Indirect Individual Effect of Treatment Assignment
    g. Proportion of Individual Effect of Treatment Assignment Mediated by Circumcision

```{r}
# Alternative to fix data availability
  # Include only those who were circumcised in the treatment
  # Include everyone in the control
modelDat_Ind <- modelDat %>%
  filter(gender == "Male") %>%
  filter(!is.na(X1_ik_vmmc))
```

The total sample size for this analysis is `r nrow(modelDat_Ind)`, meaning that `r nrow(modelDat) - nrow(modelDat_Ind)` individuals are excluded (`r nrow(filter(modelDat, gender == "Female"))` females and `r nrow(filter(modelDat, is.na(X1_ik_vmmc)))` with missing data for VMMC).

\underline{Data Characteristics}

```{r, include = FALSE}
var_order_Ind <- c("Gender", "HIV Status at Start", "Treatment Component: MC",
                   "Treatment Component: VMMC",
                    "Treatment Component: HTC", "Treatment Component: Full",
                    "Outcome: HIV Seroconversion (3-year period)")
level_order_Ind <- c("Male", "Yes", "No", "Began study circumcised", "Female",
                      "HIV-uninfected", "HIV-infected", "Refused HIV testing",
                      "Began study HIV-infected")

baseline_Ind <- modelDat_Ind %>%
  mutate(endpoint_coverage_vmmc = ifelse(endpoint_coverage_mc == "Yes", "Yes", 
                       ifelse(endpoint_coverage_mc %in% c("Began study circumcised", "No"), "No",
                              ifelse(endpoint_coverage_mc == "Female", "Female", NA)))) %>%
  dplyr::select(`Treatment Group` = random_arm,
                `Cluster Size` = cluster_size,
                `Gender` = gender,
                `HIV Status at Start` = hiv_status_current,
                `Treatment Component: MC` = endpoint_coverage_mc,
                `Treatment Component: VMMC` = endpoint_coverage_vmmc,
                `Treatment Component: HTC` = endpoint_coverage_htc,
                `Treatment Component: Full` = endpoint_coverage_full,
                `Outcome: HIV Seroconversion (3-year period)` = endpoint_seroconvert) %>%
  mutate(across(
    where(~ !is.numeric(.x)),
    ~ ifelse(is.na(.x), "Missing", as.character(.x))
  ))

# baseline_missing_Ind <- baseline_Ind %>%
#   dplyr::select(-`Cluster Size`) %>%
#   filter(if_any(everything(), ~ .x == "Missing")) %>%
#   mutate(across(
#     .cols = -c(`Treatment Group`),  # replace col1 and col2 with your actual column names
#     .fns = ~ if_else(.x == "Missing", 1, 0)
#   )) %>%
#   group_by(`Treatment Group`) %>%
#   summarise(across(
#     everything(),  # No need to exclude the grouping var here
#     sum,
#     .names = "{.col}"
#   )) %>%
#   dplyr::select(-Gender) %>%
#   ungroup() %>%
#   pivot_longer(
#     cols = -`Treatment Group`,  # gather all variables except the group
#     names_to = "Variable",
#     values_to = "Missing"
#   ) %>%
#   pivot_wider(
#     names_from = `Treatment Group`,
#     values_from = Missing
#   ) %>%
#   mutate(Overall = Control + Treatment) %>%
#   rename(`Missing (Control)` = Control,
#          `Missing (Treatment)` = Treatment,
#          `Missing (Overall)` = Overall)

cluster_size_Ind <- tibble(Variable = c("Number of Individuals", 
                                    "Number of Clusters", 
                                    "Mean Cluster Size"),
                       Level = c(NA, NA, NA),
                       Control = c(nrow(dplyr::filter(modelDat_Ind, random_arm == "Control")),
                                   length(unique(dplyr::filter(modelDat_Ind, random_arm == "Control")$cluster_id)),
                                   mean(filter(modelDat_Ind, random_arm == "Control")$cluster_size)),
                       Treatment = c(nrow(dplyr::filter(modelDat_Ind, random_arm == "Treatment")),
                                     length(unique(dplyr::filter(modelDat_Ind, random_arm == "Treatment")$cluster_id)),
                                     mean(filter(modelDat_Ind, random_arm == "Treatment")$cluster_size))) %>%
  mutate(Control = as.integer(Control), Treatment = as.integer(Treatment)) %>%
  mutate(Overall = ifelse(Variable != "Mean Cluster Size", Treatment + Control, round((Treatment + Control) / 2, 1)))

baseline_tab_Ind <- baseline_Ind %>%
  dplyr::select(-`Cluster Size`) %>%
  pivot_longer(!`Treatment Group`, 
               names_to = "Variable", values_to = "Level") %>%
  arrange(`Treatment Group`, Variable, Level) %>%
  group_by(`Treatment Group`, Variable, Level) %>%
  dplyr::summarize(n = n()) %>%
  ungroup() %>%
  filter(Level != "Missing") %>%
  group_by(`Treatment Group`, `Variable`) %>%
  mutate(Overall = sum(n)) %>%
  ungroup() %>%
  rowwise() %>%
  mutate(percentage = paste0("(", round(n/Overall, 2)*100, "%)")) %>%
  mutate(n = paste(n, percentage)) %>%
  dplyr::select(-Overall, -percentage) %>%
  pivot_wider(
    names_from = `Treatment Group`,
    values_from = n
  ) %>%
  mutate(
    Overall = parse_number(Control) + parse_number(Treatment)
  ) %>%
  group_by(Variable) %>%
  mutate(Sum = sum(Overall)) %>%
  mutate(Overall = paste0(Overall, " (", round(Overall/Sum, 2)*100, "%)")) %>%
  dplyr::select(-Sum) %>%
  mutate(Variable = factor(Variable, levels = var_order_full),
         Level = factor(Level, levels = level_order_full)) %>%
  arrange(Variable, Level)

n_treat_Ind <- nrow(filter(modelDat_Ind, random_arm == "Treatment"))
n_control_Ind <- nrow(filter(modelDat_Ind, random_arm == "Control"))
n_overall_Ind <- nrow(modelDat_Ind)

final_baseline_Ind_table <- rbind(cluster_size_Ind, baseline_tab_Ind) %>%
  #left_join(baseline_missing_Ind, by = "Variable") %>%
  group_by(Variable) %>%
  mutate(
    Variable = if_else(row_number() == 1, Variable, NA_character_))
  #   `Missing (Control)` = if_else(row_number() == 1, `Missing (Control)`, NA_integer_),
  #   `Missing (Treatment)` = if_else(row_number() == 1, `Missing (Treatment)`, NA_integer_),
  #   `Missing (Overall)` = if_else(row_number() == 1, `Missing (Overall)`, NA_integer_)
  # ) %>%
  # ungroup() %>%
  # mutate(`Missing (Control)` = as.integer(`Missing (Control)`),
  #        `Missing (Treatment)` = as.integer(`Missing (Treatment)`),
  #        `Missing (Overall)` = as.integer(`Missing (Overall)`)) %>%
  # rowwise() %>%
  # mutate(`Missing (Control)` = ifelse(!is.na(`Missing (Control)`), 
  #                                     paste0(`Missing (Control)`, " (", 
  #                                            round(`Missing (Control)`/n_control_full, 2)*100, "%)"), NA),
  #        `Missing (Treatment)` = ifelse(!is.na(`Missing (Treatment)`), 
  #                                       paste0(`Missing (Treatment)`, " (", 
  #                                              round(`Missing (Treatment)`/n_treat_full, 2)*100, "%)"), NA),
  #        `Missing (Overall)` = ifelse(!is.na(`Missing (Overall)`), 
  #                                     paste0(`Missing (Overall)`, " (", 
  #                                            round(`Missing (Overall)`/n_overall_full, 2)*100, "%)"), NA)) %>%
  # mutate(`Missing (Control)` = ifelse(`Missing (Control)` == "0 (0%)", 
  #                                     NA, `Missing (Control)`),
  #        `Missing (Treatment)` = ifelse(`Missing (Treatment)` == "0 (0%)", 
  #                                     NA, `Missing (Treatment)`),
  #        `Missing (Overall)` = ifelse(`Missing (Overall)` == "0 (0%)", 
  #                                     NA, `Missing (Overall)`))

```

```{r, results = 'asis', echo = FALSE}
cat("\\begin{landscape}\n")

print(
  xtable(
    final_baseline_Ind_table,
    caption = "Characteristics of Individual Effects Analysis Data",
  ),
  type = "latex",
  include.rownames = FALSE,
  comment = FALSE
)

cat("\\end{landscape}\n")
```

\newpage

### F. Total Individual Effect Model

"Ind" denotes individual effects, i.e. effects of a male's own treatment assignment on their own outcome. Here, we use the difference method to calculate the direct and indirect effects, with the outcome being $Y_{ik}$, treatment being $T_k$, and mediator being $X_{ik}^{(1, \text{VMMC})}$, whether or not a male has VMMC. The abbreviation "Ind" refers to the total individual effects model, shown below.



$$logit(Y_{ik}) = \beta_0^{\text{Ind}} + \beta_1^{\text{Ind}}(T_{k})$$

```{r, message = FALSE}
# Total individual effects model
modelDat_Ind <- modelDat_Ind %>%
  mutate(X1_ik_vmmc = ifelse(X1_ik_vmmc == "Yes", 1, 
                             ifelse(X1_ik_vmmc == "No", 0, NA)))

# Model not accounting for clustering
model_Ind <- glm(Y_ik ~ T_k,
                 family = binomial(link = 'logit'),
                 data = modelDat_Ind)

# Model accounting for clustering using GLMM
model_Ind_glmm <- glmer(Y_ik ~ T_k + (1|cluster_id), # Uses exchangeable
                        data = modelDat_Ind,
                        family = binomial(link = "logit"))

# Model accounting for clustering using GEE
model_Ind_gee <- geeglm(Y_ik ~ T_k,
                        family = binomial(link = "logit"),
                        id = cluster_id,
                        data = modelDat_Ind,
                        corstr = "exchangeable") # working correlation
```

```{r, echo = FALSE}
# GLM Model
model_Ind_summary <- summary(model_Ind) # Save model summary

exp_beta_Ind_0 <- exp(model_Ind_summary$coefficients[1,1]) # Intercept
exp_beta_Ind_1 <- exp(model_Ind_summary$coefficients[2,1]) # T_k Coefficient

tidy_Ind <- broom::tidy(model_Ind, conf.int = TRUE, exponentiate = TRUE) %>%
  dplyr::select(term, estimate, std.error, p.value, conf.low, conf.high) %>%
  mutate(Model = "GLM",
         Term = term,
         `OR [95% CI]` = paste0(round(estimate, 3), " [", 
                            round(conf.low, 3), ", ", 
                            round(conf.high, 3), "]"),
         `p-value` = round(p.value, 3)) %>%
  dplyr::select(Model, Term, `OR [95% CI]`, `p-value`) %>%
  dplyr::filter(Term != "(Intercept)") %>%
  mutate(ICC = NA)

# GLMM Model
model_Ind_summary_glmm <- summary(model_Ind_glmm) # Save model summary

exp_beta_Ind_0_glmm <- exp(model_Ind_summary_glmm$coefficients[1,1]) # Intercept
exp_beta_Ind_1_glmm <- exp(model_Ind_summary_glmm$coefficients[2,1]) # T_k Coefficient

tidy_Ind_glmm <- broom.mixed::tidy(model_Ind_glmm, effects = "fixed", 
                  conf.int = TRUE, exponentiate = TRUE) %>%
  dplyr::select(term, estimate, std.error, p.value, conf.low, conf.high) %>%
  mutate(Model = "GLMM",
         Term = term,
         `OR [95% CI]` = paste0(round(estimate, 3), " [", 
                            round(conf.low, 3), ", ", 
                            round(conf.high, 3), "]"),
         `p-value` = round(p.value, 3)) %>%
  dplyr::select(Model, Term, `OR [95% CI]`, `p-value`) %>%
  dplyr::filter(Term != "(Intercept)") %>%
  mutate(ICC = round(performance::icc(model_Ind_glmm)$ICC_adjusted[[1]], 3))

# GEE Model
model_Ind_summary_gee <- summary(model_Ind_gee) # Save model summary

exp_beta_Ind_0_gee <- exp(model_Ind_summary_gee$coefficients[1,1]) # Intercept
exp_beta_Ind_1_gee <- exp(model_Ind_summary_gee$coefficients[2,1]) # T_k Coefficient

tidy_Ind_gee <- broom::tidy(model_Ind_gee, conf.int = TRUE, 
                            exponentiate = TRUE) %>%
  dplyr::select(term, estimate, std.error, p.value, conf.low, conf.high) %>%
  mutate(Model = "GEE",
         Term = term,
         `OR [95% CI]` = paste0(round(estimate, 3), " [", 
                            round(conf.low, 3), ", ", 
                            round(conf.high, 3), "]"),
         `p-value` = round(p.value, 3)) %>%
  dplyr::select(Model, Term, `OR [95% CI]`, `p-value`) %>%
  dplyr::filter(Term != "(Intercept)") %>%
  mutate(ICC = round(model_Ind_gee$geese$alpha[[1]], 3))

# Overall Output Table for SpW
Ind_Model_Table <- rbind(tidy_Ind, tidy_Ind_glmm) %>%
  rbind(tidy_Ind_gee)
```

```{r, results = 'asis', echo = FALSE}
print(xtable(Ind_Model_Table, 
             caption = "Total Individual Effects Model Output"), 
      type = 'latex', include.rownames = FALSE, comment = FALSE)
```


### G. Direct Individual Effects Model

Now, we regress the outcome, $Y_{ik}$ on the treatment assignment $T_k$ and VMMC mediator $X_{ik}^{(1, \text{VMMC})}$. The abbreviation "IndD" refers to this model, shown below.

$$logit(Y_{ik}) = \beta_0^{\text{IndD}} + \beta_1^{\text{IndD}}(T_{k}) + \beta_2^{\text{IndD}} (X_{ik}^{(1, \text{VMMC})})$$

```{r, warning = FALSE, message = FALSE}
# Outcome Model for Individual Effect of Treatment Assignment

# Model not accounting for clustering
model_IndD <- glm(Y_ik ~ T_k + X1_ik_vmmc,
                  family = binomial(link = 'logit'),
                  data = modelDat_Ind)

# Model accounting for clustering using GLMM
model_IndD_glmm <- glmer(Y_ik ~ T_k + X1_ik_vmmc + (1|cluster_id), # Uses exchangeable
                         data = modelDat_Ind,
                         family = binomial(link = "logit"))

# Model accounting for clustering using GEE
model_IndD_gee <- geeglm(Y_ik ~ T_k + X1_ik_vmmc,
                         family = binomial(link = "logit"),
                         id = cluster_id,
                         data = modelDat_Ind,
                         corstr = "exchangeable") # working correlation
```

```{r, echo = FALSE}
# GLM Model
model_IndD_summary <- summary(model_IndD) # Save model summary

exp_beta_IndD_0 <- exp(model_IndD_summary$coefficients[1,1]) # Intercept
exp_beta_IndD_1 <- exp(model_IndD_summary$coefficients[2,1]) # T_k Coefficient
exp_beta_IndD_2 <- exp(model_IndD_summary$coefficients[3,1]) # X1_vmmc Coefficient

tidy_IndD <- broom::tidy(model_IndD, conf.int = TRUE, exponentiate = TRUE) %>%
  dplyr::select(term, estimate, std.error, p.value, conf.low, conf.high) %>%
  mutate(Model = "GLM",
         Term = term,
         `OR [95% CI]` = paste0(round(estimate, 3), " [", 
                            round(conf.low, 3), ", ", 
                            round(conf.high, 3), "]"),
         `p-value` = round(p.value, 3)) %>%
  dplyr::select(Model, Term, `OR [95% CI]`, `p-value`) %>%
  dplyr::filter(Term != "(Intercept)") %>%
  mutate(ICC = NA)

# GLMM Model
model_IndD_summary_glmm <- summary(model_IndD_glmm) # Save model summary

exp_beta_IndD_0_glmm <- exp(model_IndD_summary_glmm$coefficients[1,1]) # Intercept
exp_beta_IndD_1_glmm <- exp(model_IndD_summary_glmm$coefficients[2,1]) # T_k Coefficient
exp_beta_IndD_2_glmm <- exp(model_IndD_summary_glmm$coefficients[3,1]) # X1_vmmc Coefficient

tidy_IndD_glmm <- broom.mixed::tidy(model_IndD_glmm, effects = "fixed", 
                  conf.int = TRUE, exponentiate = TRUE) %>%
  dplyr::select(term, estimate, std.error, p.value, conf.low, conf.high) %>%
  mutate(Model = "GLMM",
         Term = term,
         `OR [95% CI]` = paste0(round(estimate, 3), " [", 
                            round(conf.low, 3), ", ", 
                            round(conf.high, 3), "]"),
         `p-value` = round(p.value, 3)) %>%
  dplyr::select(Model, Term, `OR [95% CI]`, `p-value`) %>%
  dplyr::filter(Term != "(Intercept)") %>%
  mutate(ICC = round(performance::icc(model_IndD_glmm)$ICC_adjusted[[1]], 3))

# GEE Model
model_IndD_summary_gee <- summary(model_IndD_gee) # Save model summary

exp_beta_IndD_0_gee <- exp(model_IndD_summary_gee$coefficients[1,1]) # Intercept
exp_beta_IndD_1_gee <- exp(model_IndD_summary_gee$coefficients[2,1]) # T_k Coefficient
exp_beta_IndD_2_gee <- exp(model_IndD_summary_gee$coefficients[3,1]) # X1_vmmc Coefficient

tidy_IndD_gee <- broom::tidy(model_IndD_gee, conf.int = TRUE, 
                            exponentiate = TRUE) %>%
  dplyr::select(term, estimate, std.error, p.value, conf.low, conf.high) %>%
  mutate(Model = "GEE",
         Term = term,
         `OR [95% CI]` = paste0(round(estimate, 3), " [", 
                            round(conf.low, 3), ", ", 
                            round(conf.high, 3), "]"),
         `p-value` = round(p.value, 3)) %>%
  dplyr::select(Model, Term, `OR [95% CI]`, `p-value`) %>%
  dplyr::filter(Term != "(Intercept)") %>%
  mutate(ICC = abs(round(model_IndD_gee$geese$alpha[[1]], 3)))

# Overall Output Table for SpW
IndD_Model_Table <- rbind(tidy_IndD, tidy_IndD_glmm) %>%
  rbind(tidy_IndD_gee)
```

```{r, results = 'asis', echo = FALSE}
print(xtable(IndD_Model_Table, 
             caption = "Direct Individual Effects Model Output"), 
      type = 'latex', include.rownames = FALSE, comment = FALSE)
```

### H. Direct and Indirect Individual Effects of Treatment Assignment

The direct individual effect of treatment assignment on HIV seroconversion is $\beta_1^{\text{IndD}}$. The indirect individual effect of treatment assignment on HIV seroconversion is $\beta_1^{\text{IndM}} \times \beta_2^{\text{IndD}}$. Then, the total effect is the sum of these, namely $\beta_1^{\text{IndD}} + \beta_1^{\text{IndM}} \times \beta_2^{\text{IndD}}$.

```{r, echo = FALSE}
Ind_DirectIndirect_Table <- tibble(
  Model = c("GLM", "GLMM", "GEE")) %>%
  mutate(
    `Direct Effect` = c(exp_beta_IndD_1, 
                       exp_beta_IndD_1_glmm,
                       exp_beta_IndD_1_gee),
    `Indirect Effect` = c(exp(log(exp_beta_Ind_1)-log(exp_beta_IndD_1)), 
                       exp(log(exp_beta_Ind_1_glmm)-log(exp_beta_IndD_1_glmm)),
                       exp(log(exp_beta_Ind_1_gee) - log(exp_beta_IndD_1_gee))),
    `Total Effect` = c(exp_beta_Ind_1, 
                       exp_beta_Ind_1_glmm,
                       exp_beta_Ind_1_gee), 
  ) %>%
  mutate(across(where(is.numeric), ~ round(.x, 3)))
```

```{r, results = 'asis', echo = FALSE}
print(xtable(Ind_DirectIndirect_Table, 
             caption = "Direct, Indirect, and Total Individual Effects of Treatment Assignment (Shown as ORs)"), 
      type = 'latex', include.rownames = FALSE, comment = FALSE)
```


### I. Proportion of Individual Effect of Treatment Assignment Mediated by Circumcision

The proportion of the total individual effect that is mediated by circumcision can be calculated as:

$$\frac{\beta_1^{\text{Ind}} - \beta_2^{\text{IndD}}}{\beta_1^{\text{Ind}}}$$

This is the indirect effect (i.e. effect of treatment assignment through the MC mediator on the outcome) divided by the total effect of the treatment assignment on the outcome (both through and not through the mediator). 

```{r, include = FALSE}
Ind_PropMediated <- tibble(
  Model = c("GLM", "GLMM", "GEE"),
  `Proportion Mediated` = c((log(exp_beta_Ind_1) - log(exp_beta_IndD_1))/log(exp_beta_Ind_1),
                            (log(exp_beta_Ind_1_glmm) - log(exp_beta_IndD_1_glmm))/log(exp_beta_Ind_1_glmm),
              (log(exp_beta_Ind_1_gee) - log(exp_beta_IndD_1_gee))/log(exp_beta_Ind_1_gee))) %>%
  mutate(across(where(is.numeric), ~ round(.x, 3)))
```

```{r, results = 'asis', echo = FALSE}
print(xtable(Ind_PropMediated, 
             caption = "Proportion of Individual Effect of Treatment Assignment Mediated by Circumcision"), 
      type = 'latex', include.rownames = FALSE, comment = FALSE)
```


#### Calculating the Confidence Interval for Proportion Mediated

Delta Method: First-order Taylor approximation for the variance of a smooth function $g(\hat{\theta})$ of estimators, where 
$$\text{Var} \left\{ g(\hat{\theta}) \right\} \approx \nabla g(\hat{\theta})^T \hat{\text{Var}}(\hat{\theta}) \nabla g(\hat{\theta})$$
where $\nabla g$ is the gradient of $g$ with respects to $\theta$ evaluated at the estimates.

Follows same procedure as for difference method with spillover analysis.

GLM CI for PM

```{r, echo = FALSE, include = FALSE}
# Proportion mediated (DIFFERENCE method, GLM) with cluster bootstrap
#   Total model : Y ~ T
#   Direct model: Y ~ T + X
#
# PM_diff = 1 - c/a, where:
#   a = beta_T from Y ~ T         (total effect on log-odds scale)
#   c = beta_T from Y ~ T + X     (direct effect on log-odds scale)
#
# We:
#   * Fit both models on full data to get (a0, c0) and PM0.
#   * Cluster-bootstrap the data (stratified by treatment; force-in all event clusters).
#   * From bootstrap draws of (a, c), compute Sigma_hat = cov((a, c)).
#   * Use Delta method with gradient (c/a^2, -1/a) to get a CI for PM_diff.
#
# Returns: point estimate, delta-method CI, plus bootstrap diagnostics.
# ------------------------------------------------------------
pm_diff_boot_with_delta_glm <- function(dat, id = "cluster_id",
                                        B = 1000, level = 0.95,
                                        force_event_once = TRUE,
                                        allow_dup_events  = TRUE,
                                        seed = NULL, verbose = TRUE) {
  if (!is.null(seed)) set.seed(seed)
  stopifnot(is.data.frame(dat))
  req <- c(id, "Y_ik", "T_k", "X1_ik_vmmc")
  miss <- setdiff(req, names(dat))
  if (length(miss)) stop("Missing columns: ", paste(miss, collapse = ", "))

  # --- Fit controls
  ctrl <- stats::glm.control(maxit = 50)

  # --- Full-data fits (same sample for both models)
  f_total  <- stats::as.formula("Y_ik ~ T_k")
  f_direct <- stats::as.formula("Y_ik ~ T_k + X1_ik_vmmc")

  fit_total  <- stats::glm(f_total,  family = stats::binomial(link = "logit"), data = dat, control = ctrl)
  fit_direct <- stats::glm(f_direct, family = stats::binomial(link = "logit"), data = dat, control = ctrl)

  a0 <- unname(stats::coef(fit_total )["T_k"])      # total (log-odds)
  c0 <- unname(stats::coef(fit_direct)["T_k"])      # direct (log-odds)

  PM0 <- if (is.finite(a0) && abs(a0) > .Machine$double.eps) 1 - c0 / a0 else NA_real_

  # --- Build cluster strata & event flags for stratified bootstrap
  cl_trt <- tapply(dat$T_k, dat[[id]], function(x) {
    u <- unique(x); if (length(u) == 1) u else as.numeric(mean(x, na.rm = TRUE) >= 0.5)
  })
  cl_evt <- tapply(dat$Y_ik, dat[[id]], function(y) any(y == 1, na.rm = TRUE))

  cl_t1 <- names(cl_trt)[cl_trt == 1]
  cl_t0 <- names(cl_trt)[cl_trt == 0]
  n1 <- length(cl_t1); n0 <- length(cl_t0)

  evt_t1 <- intersect(cl_t1, names(cl_evt)[cl_evt])
  evt_t0 <- intersect(cl_t0, names(cl_evt)[cl_evt])

  pool_t1 <- if (allow_dup_events) cl_t1 else setdiff(cl_t1, evt_t1)
  pool_t0 <- if (allow_dup_events) cl_t0 else setdiff(cl_t0, evt_t0)

  # Helper: one stratified cluster sample (force-in event clusters once)
  make_sample_ids <- function() {
    base    <- if (force_event_once) c(evt_t1, evt_t0) else character(0)
    fill_t1 <- if (n1 - length(evt_t1) > 0) sample(pool_t1, n1 - length(evt_t1), replace = TRUE) else character(0)
    fill_t0 <- if (n0 - length(evt_t0) > 0) sample(pool_t0, n0 - length(evt_t0), replace = TRUE) else character(0)
    c(base, fill_t1, fill_t0)
  }

  # --- Bootstrap: store theta = (a, c)
  theta <- matrix(NA_real_, nrow = B, ncol = 2, dimnames = list(NULL, c("a","c")))
  if (verbose) msg_every <- max(1, floor(B/10))

  for (b in seq_len(B)) {
    samp_ids <- make_sample_ids()
    boot_dat <- do.call(rbind, lapply(samp_ids, function(k) dat[dat[[id]] == k, , drop = FALSE]))

    fit_t  <- try(suppressWarnings(stats::glm(f_total,  family = stats::binomial(link = "logit"), data = boot_dat, control = ctrl)), silent = TRUE)
    fit_d  <- try(suppressWarnings(stats::glm(f_direct, family = stats::binomial(link = "logit"), data = boot_dat, control = ctrl)), silent = TRUE)

    if (!inherits(fit_t, "try-error") && !inherits(fit_d, "try-error")) {
      a <- suppressWarnings(unname(stats::coef(fit_t)["T_k"]))
      c <- suppressWarnings(unname(stats::coef(fit_d)["T_k"]))
      if (all(is.finite(c(a, c)))) theta[b, ] <- c(a = a, c = c)
    }

    if (verbose && b %% msg_every == 0) message("bootstrap: ", b, "/", B)
  }

  # --- Joint covariance from bootstrap draws
  Sigma_hat <- stats::cov(theta, use = "pairwise.complete.obs")

  # --- Delta-method CI for PM_diff
  alpha <- (1 - level)/2
  if (is.finite(PM0) && abs(a0) > .Machine$double.eps && all(is.finite(Sigma_hat))) {
    g1 <-  c0 / (a0^2)         # ∂(1 - c/a)/∂a
    g2 <- -1  /  a0            # ∂(1 - c/a)/∂c
    grad <- c(g1, g2)

    var_PM <- as.numeric(t(grad) %*% Sigma_hat %*% grad)
    se_PM  <- sqrt(var_PM)
    z      <- stats::qnorm(1 - alpha)
    ci     <- PM0 + c(-1, 1) * z * se_PM
  } else {
    se_PM <- NA_real_; ci <- c(NA_real_, NA_real_)
  }

  list(
    point_PM    = PM0,                 # PM_diff point estimate
    ci_delta_PM = ci,                  # delta-method CI using boot Sigma
    Sigma_hat   = Sigma_hat,           # joint cov of (a, c) from bootstrap
    a0 = a0, c0 = c0,                  # total & direct log-odds estimates
    settings = list(B = B, level = level,
                    force_event_once = force_event_once,
                    allow_dup_events  = allow_dup_events)
  )
}
```

```{r, echo = FALSE, include = FALSE}
set.seed(123)
res_ind_diff_glm <- pm_diff_boot_with_delta_glm(modelDat_Ind, id = "cluster_id",
                                                B = 800, verbose = TRUE)

res_ind_diff_glm$point_PM      # PM_diff estimate (can be negative on logit scale)
res_ind_diff_glm$ci_delta_PM   # delta-method CI using bootstrapped Sigma
```


GLMM CI for PM

```{r, echo = FALSE, include = FALSE}
# ------------------------------------------------------------
# Proportion mediated (DIFFERENCE method, GLMM) with cluster bootstrap + delta CI
#   Total model : Y_ik ~ T_k + (1 | cluster)
#   Direct model: Y_ik ~ T_k + X1_ik_vmmc + (1 | cluster)
#
# PM_diff = 1 - c/a, where:
#   a = beta_T from total model   (log-odds)
#   c = beta_T from direct model  (log-odds)
#
# We:
#  * Fit both GLMMs on full data to get (a0, c0).
#  * Cluster-bootstrap the data (stratified by treatment; force-in all event clusters).
#  * In each replicate, duplicates get a NEW random-effect ID (.boot_id) so glmer treats
#    them as distinct groups.
#  * From bootstrap draws of (a, c), compute Sigma_hat = cov((a, c)).
#  * Use Delta method with gradient (c/a^2, -1/a) to get CI for PM_diff.
# ------------------------------------------------------------
pm_diff_boot_with_delta_glmm <- function(dat, id = "cluster_id",
                                         B = 500, level = 0.95,
                                         force_event_once = TRUE,
                                         allow_dup_events  = TRUE,
                                         seed = NULL, verbose = TRUE) {
  if (!is.null(seed)) set.seed(seed)
  if (!requireNamespace("lme4", quietly = TRUE)) {
    stop("Package 'lme4' is required. Please install it.")
  }
  stopifnot(is.data.frame(dat))
  req <- c(id, "Y_ik", "T_k", "X1_ik_vmmc")
  miss <- setdiff(req, names(dat))
  if (length(miss)) stop("Missing columns: ", paste(miss, collapse = ", "))

  # --- Controls to help glmer converge with sparse events
  ctrl <- lme4::glmerControl(optimizer = "bobyqa",
                             optCtrl   = list(maxfun = 2e5),
                             check.conv.grad = "ignore",
                             check.conv.singular = "ignore")

  # --- Full-data fits (point estimates)
  f_total_full  <- stats::as.formula(paste0("Y_ik ~ T_k + (1|", id, ")"))
  f_direct_full <- stats::as.formula(paste0("Y_ik ~ T_k + X1_ik_vmmc + (1|", id, ")"))

  fit_total  <- suppressWarnings(lme4::glmer(f_total_full,  family = stats::binomial(link = "logit"), data = dat, control = ctrl))
  fit_direct <- suppressWarnings(lme4::glmer(f_direct_full, family = stats::binomial(link = "logit"), data = dat, control = ctrl))

  a0 <- as.numeric(lme4::fixef(fit_total )["T_k"])  # total (log-odds)
  c0 <- as.numeric(lme4::fixef(fit_direct)["T_k"])  # direct (log-odds)

  PM0 <- if (is.finite(a0) && abs(a0) > .Machine$double.eps) 1 - c0 / a0 else NA_real_

  # --- Cluster strata & event flags for stratified bootstrap
  cl_T <- tapply(dat$T_k, dat[[id]], function(x) {
    u <- unique(x); if (length(u) == 1) u else as.numeric(mean(x, na.rm = TRUE) >= 0.5)
  })
  cl_event <- tapply(dat$Y_ik, dat[[id]], function(y) any(y == 1, na.rm = TRUE))

  cl_t1 <- names(cl_T)[cl_T == 1];  cl_t0 <- names(cl_T)[cl_T == 0]
  n1 <- length(cl_t1);              n0 <- length(cl_t0)

  evt_t1 <- intersect(cl_t1, names(cl_event)[cl_event])
  evt_t0 <- intersect(cl_t0, names(cl_event)[cl_event])

  pool_t1 <- if (allow_dup_events) cl_t1 else setdiff(cl_t1, evt_t1)
  pool_t0 <- if (allow_dup_events) cl_t0 else setdiff(cl_t0, evt_t0)

  # --- Build one bootstrap dataset with NEW random-effect IDs (.boot_id)
  make_boot_df <- function() {
    base    <- if (force_event_once) c(evt_t1, evt_t0) else character(0)
    fill_t1 <- if (n1 - length(evt_t1) > 0) sample(pool_t1, n1 - length(evt_t1), replace = TRUE) else character(0)
    fill_t0 <- if (n0 - length(evt_t0) > 0) sample(pool_t0, n0 - length(evt_t0), replace = TRUE) else character(0)
    samp_ids <- c(base, fill_t1, fill_t0)

    parts <- vector("list", length(samp_ids))
    for (j in seq_along(samp_ids)) {
      k <- samp_ids[j]
      d <- dat[dat[[id]] == k, , drop = FALSE]
      d[[".boot_id"]] <- paste0("C", j, "_", k)  # unique RE label for this copy
      parts[[j]] <- d
    }
    out <- do.call(rbind, parts)
    out[[".boot_id"]] <- factor(out[[".boot_id"]])
    out
  }

  # --- Bootstrap storage
  theta <- matrix(NA_real_, nrow = B, ncol = 2, dimnames = list(NULL, c("a","c")))
  if (verbose) msg_every <- max(1, floor(B/10))

  # --- Boot formulas using .boot_id as grouping factor
  f_total_boot  <- stats::as.formula("Y_ik ~ T_k + (1|.boot_id)")
  f_direct_boot <- stats::as.formula("Y_ik ~ T_k + X1_ik_vmmc + (1|.boot_id)")

  for (b in seq_len(B)) {
    boot_dat <- make_boot_df()

    fit_t  <- try(suppressWarnings(lme4::glmer(f_total_boot,  family = stats::binomial(link = "logit"), data = boot_dat, control = ctrl)), silent = TRUE)
    fit_d  <- try(suppressWarnings(lme4::glmer(f_direct_boot, family = stats::binomial(link = "logit"), data = boot_dat, control = ctrl)), silent = TRUE)

    if (!inherits(fit_t, "try-error") && !inherits(fit_d, "try-error")) {
      fe_t <- try(lme4::fixef(fit_t), silent = TRUE)
      fe_d <- try(lme4::fixef(fit_d), silent = TRUE)
      if (!inherits(fe_t, "try-error") && !inherits(fe_d, "try-error")) {
        a <- as.numeric(fe_t["T_k"])
        c <- as.numeric(fe_d["T_k"])
        if (all(is.finite(c(a, c)))) theta[b, ] <- c(a = a, c = c)
      }
    }

    if (verbose && b %% msg_every == 0) message("bootstrap: ", b, "/", B)
  }

  # --- Joint covariance from bootstrap draws
  Sigma_hat <- stats::cov(theta, use = "pairwise.complete.obs")

  # --- Delta-method CI for PM_diff
  alpha <- (1 - level) / 2
  if (is.finite(PM0) && abs(a0) > .Machine$double.eps && all(is.finite(Sigma_hat))) {
    g1 <-  c0 / (a0^2)  # ∂(1 - c/a)/∂a
    g2 <- -1  /  a0     # ∂(1 - c/a)/∂c
    grad <- c(g1, g2)

    var_PM <- as.numeric(t(grad) %*% Sigma_hat %*% grad)
    se_PM  <- sqrt(var_PM)
    z      <- stats::qnorm(1 - alpha)
    ci     <- PM0 + c(-1, 1) * z * se_PM
  } else {
    se_PM <- NA_real_; ci <- c(NA_real_, NA_real_)
  }

  list(
    point_PM    = PM0,                 # PM_diff point estimate
    ci_delta_PM = ci,                  # delta-method CI using boot Sigma
    Sigma_hat   = Sigma_hat,           # joint cov of (a, c) from bootstrap
    a0 = a0, c0 = c0,                  # total & direct log-odds estimates
    settings = list(B = B, level = level,
                    force_event_once = force_event_once,
                    allow_dup_events  = allow_dup_events,
                    optimizer = "bobyqa", maxfun = 2e5)
  )
}

# pm_boot_with_delta_glmm <- pm_diff_boot_with_delta_glmm
```

```{r, echo = FALSE, include = FALSE}
set.seed(123)
res_ind_diff_glmm <- pm_diff_boot_with_delta_glmm(modelDat_Ind, id = "cluster_id",
                                                  B = 500, verbose = TRUE)
res_ind_diff_glmm$point_PM
res_ind_diff_glmm$ci_delta_PM
```




GEE CI for PM

```{r, echo = FALSE, include = FALSE}
# ------------------------------------------------------------
# Proportion mediated (DIFFERENCE method, GEE) with cluster bootstrap + delta CI
#   Total model : Y_ik ~ T_k
#   Direct model: Y_ik ~ T_k + X1_ik_vmmc
#
# PM_diff = 1 - c/a, where:
#   a = beta_T from total model   (log-odds)
#   c = beta_T from direct model  (log-odds)
#
# Bootstrap design:
#   * Resample clusters with replacement (stratified by T_k),
#     force-in all clusters with any Y_ik = 1 at least once per draw.
#   * When a cluster is drawn multiple times, assign a NEW working-corr ID
#     (.boot_id) so geeglm treats duplicates as distinct groups.
#   * Fit both GEE models on each boot sample, store (a, c), then
#     Sigma_hat = cov(cbind(a, c)) and delta-method CI.
# ------------------------------------------------------------
pm_diff_boot_with_delta_gee <- function(dat, id = "cluster_id",
                                        B = 400, level = 0.95,
                                        corstr = "exchangeable",
                                        force_event_once = TRUE,
                                        allow_dup_events  = TRUE,
                                        seed = NULL, verbose = TRUE) {
  if (!is.null(seed)) set.seed(seed)
  if (!requireNamespace("geepack", quietly = TRUE)) {
    stop("Package 'geepack' is required. Please install it.")
  }
  stopifnot(is.data.frame(dat))
  req <- c(id, "Y_ik", "T_k", "X1_ik_vmmc")
  miss <- setdiff(req, names(dat))
  if (length(miss)) stop("Missing columns: ", paste(miss, collapse = ", "))

  # --- Formulas
  f_total  <- stats::as.formula("Y_ik ~ T_k")
  f_direct <- stats::as.formula("Y_ik ~ T_k + X1_ik_vmmc")

  # --- Full-data fits (point estimates)
  id_full <- dat[[id]]
  fit_total  <- suppressWarnings(geepack::geeglm(f_total,  id = id_full, data = dat,
                                                 family = stats::binomial(link = "logit"), corstr = corstr))
  fit_direct <- suppressWarnings(geepack::geeglm(f_direct, id = id_full, data = dat,
                                                 family = stats::binomial(link = "logit"), corstr = corstr))

  a0 <- as.numeric(stats::coef(fit_total )["T_k"])  # total (log-odds)
  c0 <- as.numeric(stats::coef(fit_direct)["T_k"])  # direct (log-odds)

  PM0 <- if (is.finite(a0) && abs(a0) > .Machine$double.eps) 1 - c0 / a0 else NA_real_

  # --- Cluster-level T and event flags for stratified resampling
  cl_T <- tapply(dat$T_k, dat[[id]], function(x) {
    u <- unique(x); if (length(u) == 1) u else as.numeric(mean(x, na.rm = TRUE) >= 0.5)
  })
  cl_event <- tapply(dat$Y_ik, dat[[id]], function(y) any(y == 1, na.rm = TRUE))

  cl_t1 <- names(cl_T)[cl_T == 1];  cl_t0 <- names(cl_T)[cl_T == 0]
  n1 <- length(cl_t1);              n0 <- length(cl_t0)

  evt_t1 <- intersect(cl_t1, names(cl_event)[cl_event])
  evt_t0 <- intersect(cl_t0, names(cl_event)[cl_event])

  pool_t1 <- if (allow_dup_events) cl_t1 else setdiff(cl_t1, evt_t1)
  pool_t0 <- if (allow_dup_events) cl_t0 else setdiff(cl_t0, evt_t0)

  # --- Build one bootstrap dataset with NEW GEE IDs (.boot_id)
  make_boot_df <- function() {
    base    <- if (force_event_once) c(evt_t1, evt_t0) else character(0)
    fill_t1 <- if (n1 - length(evt_t1) > 0) sample(pool_t1, n1 - length(evt_t1), replace = TRUE) else character(0)
    fill_t0 <- if (n0 - length(evt_t0) > 0) sample(pool_t0, n0 - length(evt_t0), replace = TRUE) else character(0)
    samp_ids <- c(base, fill_t1, fill_t0)

    parts <- vector("list", length(samp_ids))
    for (j in seq_along(samp_ids)) {
      k <- samp_ids[j]
      d <- dat[dat[[id]] == k, , drop = FALSE]
      d[[".boot_id"]] <- paste0("G", j, "_", k)  # unique working-corr group
      parts[[j]] <- d
    }
    out <- do.call(rbind, parts)
    out[[".boot_id"]] <- factor(out[[".boot_id"]])
    out
  }

  # --- Bootstrap storage
  theta <- matrix(NA_real_, nrow = B, ncol = 2, dimnames = list(NULL, c("a","c")))
  if (verbose) msg_every <- max(1, floor(B/10))

  for (b in seq_len(B)) {
    boot_dat <- make_boot_df()
    idB <- boot_dat[[".boot_id"]]

    fit_t <- try(suppressWarnings(
      geepack::geeglm(f_total,  id = idB, data = boot_dat,
                      family = stats::binomial(link = "logit"), corstr = corstr)
    ), silent = TRUE)

    fit_d <- try(suppressWarnings(
      geepack::geeglm(f_direct, id = idB, data = boot_dat,
                      family = stats::binomial(link = "logit"), corstr = corstr)
    ), silent = TRUE)

    if (!inherits(fit_t, "try-error") && !inherits(fit_d, "try-error")) {
      a <- suppressWarnings(as.numeric(stats::coef(fit_t)["T_k"]))
      c <- suppressWarnings(as.numeric(stats::coef(fit_d)["T_k"]))
      if (all(is.finite(c(a, c)))) theta[b, ] <- c(a = a, c = c)
    }

    if (verbose && b %% msg_every == 0) message("bootstrap: ", b, "/", B)
  }

  # --- Joint covariance from bootstrap draws
  Sigma_hat <- stats::cov(theta, use = "pairwise.complete.obs")

  # --- Delta-method CI for PM_diff
  alpha <- (1 - level)/2
  if (is.finite(PM0) && abs(a0) > .Machine$double.eps && all(is.finite(Sigma_hat))) {
    g1 <-  c0 / (a0^2)   # ∂(1 - c/a)/∂a
    g2 <- -1  /  a0      # ∂(1 - c/a)/∂c
    grad <- c(g1, g2)

    var_PM <- as.numeric(t(grad) %*% Sigma_hat %*% grad)
    se_PM  <- sqrt(var_PM)
    z      <- stats::qnorm(1 - alpha)
    ci     <- PM0 + c(-1, 1) * z * se_PM
  } else {
    ci <- c(NA_real_, NA_real_)
  }

  list(
    point_PM    = PM0,                 # PM_diff point estimate
    ci_delta_PM = ci,                  # delta-method CI using boot Sigma
    Sigma_hat   = Sigma_hat,           # joint cov of (a, c) from bootstrap
    a0 = a0, c0 = c0,                  # total & direct log-odds estimates
    settings = list(B = B, level = level, corstr = corstr,
                    force_event_once = force_event_once,
                    allow_dup_events  = allow_dup_events)
  )
}
```

```{r, echo = FALSE, include = FALSE}
set.seed(123)
res_ind_diff_gee <- pm_diff_boot_with_delta_gee(modelDat_Ind, id = "cluster_id",
                                                B = 350, corstr = "exchangeable",
                                                verbose = TRUE)
res_ind_diff_gee$point_PM
res_ind_diff_gee$ci_delta_PM
```

```{r, echo = FALSE}
# Summarize PM across GLM / GLMM / GEE into one tidy table
summarize_pm_results <- function(res_glm = NULL, res_glmm = NULL, res_gee = NULL,
                                 digits = 2) {
  rows <- list()

  add_row <- function(res, label) {
    if (is.null(res)) return(NULL)
    B   <- if (!is.null(res$settings$B)) res$settings$B else NA_integer_
    use <- if (!is.null(res$boot_draws_PM)) sum(is.finite(res$boot_draws_PM)) else NA_integer_
    boot <- res$ci_boot_PM
    delt <- res$ci_delta_PM
    data.frame(
      Method        = label,
      PM_Estimate   = res$point_PM,
      PM_Boot_Lower = as.numeric(boot[1]),
      PM_Boot_Upper = as.numeric(boot[2]),
      PM_Delta_Lower= as.numeric(delt[1]),
      PM_Delta_Upper= as.numeric(delt[2]),
      Boot_Used     = use,
      Boot_B        = B,
      stringsAsFactors = FALSE
    )
  }

  if (!is.null(res_glm))  rows <- c(rows, list(add_row(res_glm,  "GLM")))
  if (!is.null(res_glmm)) rows <- c(rows, list(add_row(res_glmm, "GLMM")))
  if (!is.null(res_gee))  {
    # include corstr in label if available
    lbl <- if (!is.null(res_gee$settings$corstr)) paste0("GEE (", res_gee$settings$corstr, ")") else "GEE"
    rows <- c(rows, list(add_row(res_gee, lbl)))
  }

  out <- do.call(rbind, rows)

  # Pretty, presentation-friendly columns (optional)
  fmt <- function(x) formatC(x, format = "f", digits = digits)
  out$`PM (boot CI)`  <- paste0(fmt(out$PM_Estimate), " [",
                                fmt(out$PM_Boot_Lower), ", ",
                                fmt(out$PM_Boot_Upper), "]")
  out$`PM (delta CI)` <- paste0(fmt(out$PM_Estimate), " [",
                                fmt(out$PM_Delta_Lower), ", ",
                                fmt(out$PM_Delta_Upper), "]")

  # Reorder & return
  out[, c("Method", "PM (boot CI)", "PM (delta CI)", "Boot_Used", "Boot_B")]
}

pm_table <- summarize_pm_results(res, res_glmm, res_gee, digits = 2)
#pm_table
```

```{r, results = 'asis', echo = FALSE}
print(xtable::xtable(dplyr::select(pm_table, Method, `PM (delta CI)`),
       caption = "Proportion mediated (PM) with bootstrap and delta-method CIs"),
      include.rownames = FALSE, comment = FALSE)
```



\newpage

## Total Proportion Mediated

#### J. Proportion of total effect mediated by male circumcision

The proportion of total effect mediated by male circumcision is

(Total Individual - Direct Individual) + (Total Spillover - Spillover Not Mediated by MC)
/ 
Overall 
(Or Total Individual + Total Spillover)

$$\frac{[(\beta_1^{\text{Ind}} - \beta_1^{\text{IndD}}) + (\beta_1^{\text{SpW}} - \beta_1^{\text{SpWR}})]}{(\beta_1^{\text{Overall}})}$$

```{r, include = FALSE}
Overall_PropMediated <- tibble(
  Model = c("GLM", "GLMM", "GEE"),
  `Proportion of Overall Effect Mediated by Circumcision` = 
    c(((log(exp_beta_Ind_1) - log(exp_beta_IndD_1)) + (log(exp_beta_SpW_1) - log(exp_beta_SpWR_1)))/(log(exp_beta_overall_1)),
      ((log(exp_beta_Ind_1_glmm) - log(exp_beta_IndD_1_glmm)) + (log(exp_beta_SpW_1_glmm) - log(exp_beta_SpWR_1_glmm)))/(log(exp_beta_overall_1_glmm)),
      ((log(exp_beta_Ind_1_gee) - log(exp_beta_IndD_1_gee)) + (log(exp_beta_SpW_1_gee) - log(exp_beta_SpWR_1_gee)))/(log(exp_beta_overall_1_gee))))
```

```{r, results = 'asis', echo = FALSE}
print(xtable(Overall_PropMediated, 
             caption = "Proportion of Overall Effect of Treatment Assignment Mediated by VMMC"), 
      type = 'latex', include.rownames = FALSE, comment = FALSE)
```


$$\frac{[(\beta_1^{\text{Ind}} - \beta_1^{\text{IndD}}) + (\beta_1^{\text{SpW}} - \beta_1^{\text{SpWR}})]}{\beta_1^\text{Ind}+\beta_1^{\text{SpW}}}$$

```{r, include = FALSE}
total_glm <- log(exp_beta_Ind_1) + log(exp_beta_SpW_1)
total_glmm <- log(exp_beta_Ind_1_glmm) + log(exp_beta_SpW_1_glmm)
total_gee <- log(exp_beta_Ind_1_gee) + log(exp_beta_SpW_1_gee)

Overall_PropMediated_Alt <- tibble(
  Model = c("GLM", "GLMM", "GEE"),
  `Proportion of Overall Effect Mediated by Circumcision` = 
    c(((log(exp_beta_Ind_1) - log(exp_beta_IndD_1)) + (log(exp_beta_SpW_1) - log(exp_beta_SpWR_1)))/(total_glm),
      ((log(exp_beta_Ind_1_glmm) - log(exp_beta_IndD_1_glmm)) + (log(exp_beta_SpW_1_glmm) - log(exp_beta_SpWR_1_glmm)))/(total_glmm),
      ((log(exp_beta_Ind_1_gee) - log(exp_beta_IndD_1_gee)) + (log(exp_beta_SpW_1_gee) - log(exp_beta_SpWR_1_gee)))/(total_gee)))
```

```{r, results = 'asis', echo = FALSE}
print(xtable(Overall_PropMediated_Alt, 
             caption = "Proportion of Overall Effect of Treatment Assignment Mediated by VMMC"), 
      type = 'latex', include.rownames = FALSE, comment = FALSE)
```

```{r include = FALSE}
# Proportion of total effect mediated by male circumcision
#((beta_Ind_1 - beta_IndM_1) + (beta_SpW_1 - beta_SpWM_1))/(beta_Ind_1 + beta_SpW_1) 
# Proportion of total effect mediated by male circumcision firth model
# ((log(exp_beta_Ind_1) - log(exp_beta_IndD_1_firth)) + (log(exp_beta_SpW_1) - log(exp_beta_SpWR_1)))/(log(exp_beta_Ind_1) + log(exp_beta_SpW_1))
# 
# exp(((log(exp_beta_Ind_1) - log(exp_beta_IndD_1_firth)) + (log(exp_beta_SpW_1) - log(exp_beta_SpWR_1)))/(log(exp_beta_Ind_1) + log(exp_beta_SpW_1)))
```

```{r include = FALSE}
# ((log(exp_beta_Ind_1) - log(exp_beta_IndD_1_firth)) + (log(exp_beta_SpW_1) - log(exp_beta_SpWR_1)))/(log(exp_beta_overall_1))
# 
# exp(((log(exp_beta_Ind_1) - log(exp_beta_IndD_1_firth)) + (log(exp_beta_SpW_1) - log(exp_beta_SpWR_1)))/(log(exp_beta_overall_1)))
```




```{r include = FALSE, eval = FALSE}
### J. Proportion of intervention village total effect due to spillover within intervention villages

#The proportion of intervention village total effect due to spillover within intervention villages is 

#$$\frac{\beta_1^{\text{SpW}}}{(\beta_1^{\text{Ind}} + \beta_1^{\text{SpW}})}$$
# Proportion of intervention village total effect due to spillover within intervention villages
#log(exp_beta_SpW_1)/(log(exp_beta_Ind_1) + log(exp_beta_SpW_1))
#log(exp_beta_SpW_1)/(log(exp_beta_overall_1))
```


# Exact Logistic Regression for VMMC

Fisher

```{r}
tab <- with(modelDat_Ind, table(Y_ik, X1_ik_vmmc))
tab
fisher.test(tab, alternative = "two.sided")
```

Exact Logistic Regression

```{r}
# install.packages("elrm")
library(elrm)

# Aggregate to counts by (T, VMMC)
ag <- modelDat_Ind %>%
  count(T_k, X1_ik_vmmc, Y_ik, name = "n") %>%
  pivot_wider(names_from = Y_ik, values_from = n, values_fill = 0) %>%
  rename(y = `1`, n0 = `0`) %>%
  mutate(n = y + n0)

# Exact logistic via elrm: y successes out of n trials
set.seed(123)
fit_ex <- elrm(formula  = y / n ~ T_k + X1_ik_vmmc,
               interest = ~ X1_ik_vmmc,          # parameter of interest
               iter     = 200000, burnIn = 5000,  # bump if chain is noisy
               dataset  = ag)

summary(fit_ex)
```




\newpage

# CURRENT ISSUES AND NOTES

## Ashley's email:

1. It would be helpful to write out the estimands for each effect. Are these the same as Tyler's paper? Does it matter that your mediator is part of the intervention package, while Tyler's is another covariate? https://pmc.ncbi.nlm.nih.gov/articles/PMC3753117/

2. Are the meditators at the individual level, group level or both? If group level, are you using an exposure mapping function? 

3. Can the spillover effect itself be mediated? In the case of just two people in a cluster, I believe the spillover problem can be exactly described as meditation.

4. How are the other package components handled? Could treat as confounders, averaging over them. 

5. For the OR =22, I would check the table of village assignment, VMMC exposure and outcome, probably a zero or small cell. Ke, any other ideas here?

6. Are you concerned about mediator confounding in this case? How is the correlation within cluster modeled? 

7. I think the positivity assumption is OK - as you have a three level exposure (women, male cirm, male unicorn) and fairly sure there are no gender restrictions on the covariates., but the "woman" status is not an intervention like VMMC is. 


## Notes from Laura

1. what we are doing is first estimating the total effect (which is a sum of the direct and indirect effects) by regressing on T.

    a. Laura's response: If regressing on T, this is the overall (total) effect, that is the overall effect of being in an intervention cluster compared to control. It's total because it's regardless of mediation.

2. then we are adjusting for x1 (vmmc) to get the direct effect of CP (assuming perfect compliance) and we can get the indirect effect through vmmc through the usual method we have in the slides.

    a. This is the overall indirect effect, that is the effect of cluster assignment through individual VMMC.

the new suggestion allows for imperfect compliance and this uses X12 in place of T. 

    a. What is the new suggestion?

## Other Notes

1. Circumcision that is done locally, not for medical purposes but for cultural purposes, is incomplete and may not be effective for preventing HIV. So at some point later in the analysis, it would be of interest to assess the effects of circumcision before the study started, with circumcision after.

2. Positivity assumption was mentioned as a possible issue because women can't have VMMC

3. Add a dag for mediation, and a dag for spillover - has anybody ever done this?

4. Do we have data on death? We can combine HIV and death as another outcome to have more events

5. There is a variable called hiv_status_time that gives HIV status by each visit, with status already positive, new positive, negative. Do you see this? And then there is a variable hiv_results_days that is days from enrollment to that test. That could give us 1 year incidence when/if we want that (for survival data analysis for example). These should add up to the number of cases in total.

6. If we want to create a combined variable, death or seroconversion, which could give us more cases and more power, if all or most of the deaths are due to HIV.

7. Time from enrollment to death is death_days. There is also a variable death_cause (can we take a look at this? It might be possible to delete deaths that are obviously not HIV related, such as accidents). And then there is another variable death_primary, which is the primary cause of death.



\newpage

# MC and VMMC

Evidence that VMMC and MC has no individual effect on HIV incidence and therefore cannot mediate the intervention

```{r echo = FALSE}
mcDat <- modelDat %>%
  filter(gender == "Male") %>%
  filter(!is.na(X1_ik)) %>%
  mutate(X1_ik = ifelse(X1_ik == "Yes", 1, 
                        ifelse(X1_ik == "No", 0, NA)))

vmmcDat <- modelDat %>%
  filter(gender == "Male") %>%
  filter(!is.na(X1_ik_vmmc)) %>%
  mutate(X1_ik_vmmc = ifelse(X1_ik_vmmc == "Yes", 1, 
                ifelse(X1_ik_vmmc == "No", 0, NA)))
```

```{r, include = FALSE}
mc_freq_table <- modelDat %>%
  filter(gender == "Male") %>%
  dplyr::select(X1_ik, Y_ik) %>%
  mutate(X1_ik = ifelse(is.na(X1_ik), "Missing", X1_ik),
         Y_ik = ifelse(Y_ik == 1, "Yes",
                       ifelse(Y_ik == 0, "No", "Missing"))) %>%
  mutate(Y_ik = paste0("Y_ik = ", Y_ik)) %>%
  mutate(X1_ik = paste0("X1_ik = ", X1_ik)) %>%
  group_by(X1_ik, Y_ik) %>%
  dplyr::summarize(n = n()) %>%
  ungroup() %>%
  pivot_wider(names_from = Y_ik, values_from = n) %>%
  mutate(across(everything(), ~replace_na(.x, 0))) %>%
  dplyr::select(`X1_ik`, `Y_ik = Yes`, `Y_ik = No`) %>%
  arrange(desc(`X1_ik`))
```

```{r, results = 'asis', echo = FALSE}
print(xtable(mc_freq_table,
             caption = "Counts of HIV Seroconversion (Y) by Male Circumcision (X1)"), 
      type = 'latex', include.rownames = FALSE, comment = FALSE)
```

```{r, include = FALSE}
vmmc_freq_table <- modelDat %>%
  filter(gender == "Male") %>%
  dplyr::select(X1_ik_vmmc, Y_ik) %>%
  mutate(X1_ik_vmmc = ifelse(is.na(X1_ik_vmmc), "Missing", X1_ik_vmmc),
         Y_ik = ifelse(Y_ik == 1, "Yes",
                       ifelse(Y_ik == 0, "No", "Missing"))) %>%
  mutate(Y_ik = paste0("Y_ik = ", Y_ik)) %>%
  mutate(X1_ik_vmmc = paste0("X1_ik_vmmc = ", X1_ik_vmmc)) %>%
  group_by(X1_ik_vmmc, Y_ik) %>%
  dplyr::summarize(n = n()) %>%
  ungroup() %>%
  pivot_wider(names_from = Y_ik, values_from = n) %>%
  mutate(across(everything(), ~replace_na(.x, 0))) %>%
  dplyr::select(`X1_ik_vmmc`, `Y_ik = Yes`, `Y_ik = No`) %>%
  arrange(desc(`X1_ik_vmmc`))
```

```{r, results = 'asis', echo = FALSE}
print(xtable(vmmc_freq_table,
             caption = "Counts of HIV Seroconversion (Y) by VMMC (X1)"), 
      type = 'latex', include.rownames = FALSE, comment = FALSE)
```

```{r, echo = FALSE, include = FALSE}
tally(~X1_ik, data = mcDat)
tally(~X1_ik_vmmc, data = vmmcDat)
```



```{r echo = FALSE}
# MC
# Model not accounting for clustering
model_mc <- glm(Y_ik ~ X1_ik,
                 family = binomial(link = 'logit'),
                 data = mcDat) # Exclude those who received full trt

# Model accounting for clustering using GLMM
model_mc_glmm <- glmer(Y_ik ~ X1_ik + (1|cluster_id), # Uses exchangeable structure
                        data = mcDat, 
                        family = binomial(link = "logit"))

# Model accounting for clustering using GEE
model_mc_gee <- geeglm(Y_ik ~ X1_ik,
                        family = binomial(link = "logit"), # logit link
                        id = cluster_id, # clustering variable
                        data = mcDat,
                        corstr  = "exchangeable") # working correlation


# VMMC
# Model not accounting for clustering
model_vmmc <- glm(Y_ik ~ X1_ik_vmmc,
                 family = binomial(link = 'logit'),
                 data = vmmcDat) # Exclude those who received full trt

# Model accounting for clustering using GLMM
model_vmmc_glmm <- glmer(Y_ik ~ X1_ik_vmmc + (1|cluster_id), # Uses exchangeable structure
                        data = vmmcDat, 
                        family = binomial(link = "logit"))

# Model accounting for clustering using GEE
model_vmmc_gee <- geeglm(Y_ik ~ X1_ik_vmmc,
                        family = binomial(link = "logit"), # logit link
                        id = cluster_id, # clustering variable
                        data = vmmcDat,
                        corstr  = "exchangeable") # working correlation
```

```{r, echo = FALSE, warning = FALSE}
# GLM Model
model_mc_summary <- summary(model_mc) # Save model summary

exp_beta_mc_0 <- exp(model_mc_summary$coefficients[1,1]) # Intercept
exp_beta_mc_1 <- exp(model_mc_summary$coefficients[2,1]) # X1 Coefficient

tidy_mc <- broom::tidy(model_mc, conf.int = TRUE, exponentiate = TRUE) %>%
  dplyr::select(term, estimate, std.error, p.value, conf.low, conf.high) %>%
  mutate(Model = "GLM",
         Term = term,
         `OR [95% CI]` = paste0(round(estimate, 3), " [", 
                            round(conf.low, 3), ", ", 
                            round(conf.high, 3), "]"),
         `p-value` = round(p.value, 3)) %>%
  dplyr::select(Model, Term, `OR [95% CI]`, `p-value`) %>%
  dplyr::filter(Term != "(Intercept)") %>%
  mutate(ICC = NA)

# GLMM Model
model_mc_summary_glmm <- summary(model_mc_glmm) # Save model summary

exp_beta_mc_0_glmm <- exp(model_mc_summary_glmm$coefficients[1,1]) # Intercept
exp_beta_mc_1_glmm <- exp(model_mc_summary_glmm$coefficients[2,1]) # X1 Coefficient

tidy_mc_glmm <- broom.mixed::tidy(model_mc_glmm, effects = "fixed", 
                  conf.int = TRUE, exponentiate = TRUE) %>%
  dplyr::select(term, estimate, std.error, p.value, conf.low, conf.high) %>%
  mutate(Model = "GLMM",
         Term = term,
         `OR [95% CI]` = paste0(round(estimate, 3), " [", 
                            round(conf.low, 3), ", ", 
                            round(conf.high, 3), "]"),
         `p-value` = round(p.value, 3)) %>%
  dplyr::select(Model, Term, `OR [95% CI]`, `p-value`) %>%
  dplyr::filter(Term != "(Intercept)") %>%
  mutate(ICC = round(performance::icc(model_mc_glmm)$ICC_adjusted[[1]], 3))

# GEE Model
model_mc_summary_gee <- summary(model_mc_gee) # Save model summary

exp_beta_mc_0_gee <- exp(model_mc_summary_gee$coefficients[1,1]) # Intercept
exp_beta_mc_1_gee <- exp(model_mc_summary_gee$coefficients[2,1]) # X1 Coefficient

tidy_mc_gee <- broom::tidy(model_mc_gee, conf.int = TRUE, 
                            exponentiate = TRUE) %>%
  dplyr::select(term, estimate, std.error, p.value, conf.low, conf.high) %>%
  mutate(Model = "GEE",
         Term = term,
         `OR [95% CI]` = paste0(round(estimate, 3), " [", 
                            round(conf.low, 3), ", ", 
                            round(conf.high, 3), "]"),
         `p-value` = round(p.value, 3)) %>%
  dplyr::select(Model, Term, `OR [95% CI]`, `p-value`) %>%
  dplyr::filter(Term != "(Intercept)") %>%
  mutate(ICC = round(model_mc_gee$geese$alpha[[1]], 3))

# Overall Output Table for SpW
mc_Model_Table <- rbind(tidy_mc, tidy_mc_glmm) %>%
  rbind(tidy_mc_gee)
```

```{r, results = 'asis', echo = FALSE}
print(xtable(mc_Model_Table, 
             caption = "Effect of MC on HIV Incidence"), 
      type = 'latex', include.rownames = FALSE, comment = FALSE)
```
Fisher's exact test

```{r}
mat <- matrix(c(9, 1528,   # first row
                0, 1591),  # second row
              nrow = 2, byrow = TRUE)
fisher.test(mat, alternative = "two.sided")


vmmcmat <- matrix(c(6, 984,   # first row
                3, 2135),  # second row
              nrow = 2, byrow = TRUE)
fisher.test(vmmcmat, alternative = "two.sided")
```




```{r, echo = FALSE, warning = FALSE}
# GLM Model
model_vmmc_summary <- summary(model_vmmc) # Save model summary

exp_beta_vmmc_0 <- exp(model_vmmc_summary$coefficients[1,1]) # Intercept
exp_beta_vmmc_1 <- exp(model_vmmc_summary$coefficients[2,1]) # X1vmmc Coefficient

tidy_vmmc <- broom::tidy(model_vmmc, conf.int = TRUE, exponentiate = TRUE) %>%
  dplyr::select(term, estimate, std.error, p.value, conf.low, conf.high) %>%
  mutate(Model = "GLM",
         Term = term,
         `OR [95% CI]` = paste0(round(estimate, 3), " [", 
                            round(conf.low, 3), ", ", 
                            round(conf.high, 3), "]"),
         `p-value` = round(p.value, 3)) %>%
  dplyr::select(Model, Term, `OR [95% CI]`, `p-value`) %>%
  dplyr::filter(Term != "(Intercept)") %>%
  mutate(ICC = NA)

# GLMM Model
model_vmmc_summary_glmm <- summary(model_vmmc_glmm) # Save model summary

exp_beta_vmmc_0_glmm <- exp(model_vmmc_summary_glmm$coefficients[1,1]) # Intercept
exp_beta_vmmc_1_glmm <- exp(model_vmmc_summary_glmm$coefficients[2,1]) # X1vmmc Coefficient

tidy_vmmc_glmm <- broom.mixed::tidy(model_vmmc_glmm, effects = "fixed", 
                  conf.int = TRUE, exponentiate = TRUE) %>%
  dplyr::select(term, estimate, std.error, p.value, conf.low, conf.high) %>%
  mutate(Model = "GLMM",
         Term = term,
         `OR [95% CI]` = paste0(round(estimate, 3), " [", 
                            round(conf.low, 3), ", ", 
                            round(conf.high, 3), "]"),
         `p-value` = round(p.value, 3)) %>%
  dplyr::select(Model, Term, `OR [95% CI]`, `p-value`) %>%
  dplyr::filter(Term != "(Intercept)") %>%
  mutate(ICC = round(performance::icc(model_vmmc_glmm)$ICC_adjusted[[1]], 3))

# GEE Model
model_vmmc_summary_gee <- summary(model_vmmc_gee) # Save model summary

exp_beta_vmmc_0_gee <- exp(model_vmmc_summary_gee$coefficients[1,1]) # Intercept
exp_beta_vmmc_1_gee <- exp(model_vmmc_summary_gee$coefficients[2,1]) # X1 Coefficient

tidy_vmmc_gee <- broom::tidy(model_vmmc_gee, conf.int = TRUE, 
                            exponentiate = TRUE) %>%
  dplyr::select(term, estimate, std.error, p.value, conf.low, conf.high) %>%
  mutate(Model = "GEE",
         Term = term,
         `OR [95% CI]` = paste0(round(estimate, 3), " [", 
                            round(conf.low, 3), ", ", 
                            round(conf.high, 3), "]"),
         `p-value` = round(p.value, 3)) %>%
  dplyr::select(Model, Term, `OR [95% CI]`, `p-value`) %>%
  dplyr::filter(Term != "(Intercept)") %>%
  mutate(ICC = round(model_vmmc_gee$geese$alpha[[1]], 3))

# Overall Output Table for SpW
vmmc_Model_Table <- rbind(tidy_vmmc, tidy_vmmc_glmm) %>%
  rbind(tidy_vmmc_gee)
```

```{r, results = 'asis', echo = FALSE}
print(xtable(vmmc_Model_Table, 
             caption = "Effect of VMMC on HIV Incidence"), 
      type = 'latex', include.rownames = FALSE, comment = FALSE)
```

Evidence that village-level circumcision rates have a strong effect and mediate treatment effect in men.

Mediator Model:

$$Z_{k}^{(1)} = \beta_0^{\text{M}} + \beta_1^{\text{M}} (T_k)$$




```{r, echo = FALSE, warning = FALSE}
# Model not accounting for clustering
model_z_med <- lm(Z1_k ~ T_k,
                 data = modelDat) # Exclude those who received full trt

# Model accounting for clustering using GLMM
model_z_med_glmm <- lmer(Z1_k ~ T_k + (1 | cluster_id),
                         data = modelDat)

# Model accounting for clustering using GEE
model_z_med_gee <- geeglm(Z1_k ~ T_k,
                        family = gaussian(link = "identity"), # logit link
                        id = cluster_id, # clustering variable
                        data = modelDat,
                        corstr  = "exchangeable") # working correlation

# GLM Model
model_z_med_summary <- summary(model_z_med) # Save model summary

beta_z_med_0 <- (model_z_med_summary$coefficients[1,1]) # Intercept
beta_z_med_1 <- (model_z_med_summary$coefficients[2,1]) # X1vmmc Coefficient

tidy_z_med <- broom::tidy(model_z_med, conf.int = TRUE, exponentiate = FALSE) %>%
  dplyr::select(term, estimate, std.error, p.value, conf.low, conf.high) %>%
  mutate(Model = "LM",
         Term = term,
         `Beta [95% CI]` = paste0(round(estimate, 3), " [", 
                            round(conf.low, 3), ", ", 
                            round(conf.high, 3), "]"),
         `p-value` = round(p.value, 3)) %>%
  dplyr::select(Model, Term, `Beta [95% CI]`, `p-value`) %>%
  dplyr::filter(Term != "(Intercept)") %>%
  mutate(ICC = NA)

# GLMM Model
model_z_med_summary_glmm <- summary(model_z_med_glmm) # Save model summary

beta_z_med_0_glmm <- (model_z_med_summary_glmm$coefficients[1,1]) # Intercept
beta_z_med_1_glmm <- (model_z_med_summary_glmm$coefficients[2,1]) # X1vmmc Coefficient

tidy_z_med_glmm <- broom.mixed::tidy(model_z_med_glmm, effects = "fixed",
                                    conf.int = TRUE) %>%
  dplyr::mutate(p.value = 2 * pnorm(-abs(statistic)),   # z-approximation
                Model   = "LMM",
                Term    = term,
                `Beta [95% CI]` = sprintf("%.3f [%.3f, %.3f]",
                                      estimate, conf.low, conf.high)) %>%
  dplyr::select(Model, Term, `Beta [95% CI]`, `p-value` = p.value) %>%
  dplyr::filter(Term != "(Intercept)") %>%
  dplyr::mutate(ICC = round(performance::icc(model_z_med_glmm)$ICC_adjusted[[1]], 3))

# GEE Model
model_z_med_summary_gee <- summary(model_z_med_gee) # Save model summary

beta_z_med_0_gee <- (model_z_med_summary_gee$coefficients[1,1]) # Intercept
beta_z_med_1_gee <- (model_z_med_summary_gee$coefficients[2,1]) # X1 Coefficient

tidy_z_med_gee <- broom::tidy(model_z_med_gee, conf.int = TRUE, 
                            exponentiate = FALSE) %>%
  dplyr::select(term, estimate, std.error, p.value, conf.low, conf.high) %>%
  mutate(Model = "GEE",
         Term = term,
         `Beta [95% CI]` = paste0(round(estimate, 3), " [", 
                            round(conf.low, 3), ", ", 
                            round(conf.high, 3), "]"),
         `p-value` = round(p.value, 3)) %>%
  dplyr::select(Model, Term, `Beta [95% CI]`, `p-value`) %>%
  dplyr::filter(Term != "(Intercept)") %>%
  mutate(ICC = round(model_z_med_gee$geese$alpha[[1]], 3))

# Overall Output Table for SpW
z_med_Model_Table <- rbind(tidy_z_med, tidy_z_med_glmm) %>%
  rbind(tidy_z_med_gee) %>%
  dplyr::select(-ICC)
```

```{r, results = 'asis', echo = FALSE}
print(xtable(z_med_Model_Table, 
             caption = "Mediatior Model for Proportion VMMC"), 
      type = 'latex', include.rownames = FALSE, comment = FALSE)
```



Outcome Model: 


$$logit(Y_{ik}) = \beta_0^{\text{O}} + \beta_1^{\text{O}} (T_k) + \beta_2 (Z_{k}^{(1)})$$



```{r, echo = FALSE, warning = FALSE}
# Model not accounting for clustering
model_z_out <- glm(Y_ik ~ T_k + Z1_k,
                  family = binomial(link = "logit"),
                 data = modelDat) # Exclude those who received full trt

# Model accounting for clustering using GLMM
model_z_out_glmm <- glmer(Y_ik ~ T_k + Z1_k + (1|cluster_id), # Uses exchangeable structure
                        data = modelDat, 
                        family = binomial(link = "logit"))

# Model accounting for clustering using GEE
model_z_out_gee <- geeglm(Y_ik ~ T_k + Z1_k,
                        family = binomial(link = "logit"), # logit link
                        id = cluster_id, # clustering variable
                        data = modelDat,
                        corstr  = "exchangeable") # working correlation

# GLM Model
model_z_out_summary <- summary(model_z_out) # Save model summary

beta_z_out_0 <- (model_z_out_summary$coefficients[1,1]) # Intercept
beta_z_out_1 <- (model_z_out_summary$coefficients[2,1]) # T Coefficient
beta_z_out_2 <- (model_z_out_summary$coefficients[3,1]) # Z1 Coefficient

tidy_z_out <- broom::tidy(model_z_out, conf.int = TRUE, exponentiate = TRUE) %>%
  dplyr::select(term, estimate, std.error, p.value, conf.low, conf.high) %>%
  mutate(Model = "GLM",
         Term = term,
         `OR [95% CI]` = paste0(round(estimate, 3), " [", 
                            round(conf.low, 3), ", ", 
                            round(conf.high, 3), "]"),
         `Beta [95% CI]` = paste0(round(log(estimate), 3), " [", 
                            round(log(conf.low), 3), ", ", 
                            round(log(conf.high), 3), "]"),
         `p-value` = round(p.value, 3)) %>%
  dplyr::select(Model, Term, `OR [95% CI]`, `Beta [95% CI]`, `p-value`) %>%
  dplyr::filter(Term != "(Intercept)") %>%
  mutate(ICC = NA)

# GLMM Model
model_z_out_summary_glmm <- summary(model_z_out_glmm) # Save model summary

beta_z_out_0_glmm <- (model_z_out_summary_glmm$coefficients[1,1]) # Intercept
beta_z_out_1_glmm <- (model_z_out_summary_glmm$coefficients[2,1]) # T Coefficient
beta_z_out_2_glmm <- (model_z_out_summary_glmm$coefficients[3,1]) # Z1 Coefficient

tidy_z_out_glmm <- broom.mixed::tidy(model_z_out_glmm, effects = "fixed", 
                  conf.int = TRUE, exponentiate = TRUE) %>%
  dplyr::select(term, estimate, std.error, p.value, conf.low, conf.high) %>%
  mutate(Model = "GLMM",
         Term = term,
         `OR [95% CI]` = paste0(round(estimate, 3), " [", 
                            round(conf.low, 3), ", ", 
                            round(conf.high, 3), "]"),
         `Beta [95% CI]` = paste0(round(log(estimate), 3), " [", 
                            round(log(conf.low), 3), ", ", 
                            round(log(conf.high), 3), "]"),
         `p-value` = round(p.value, 3),
         `p-value` = round(p.value, 3)) %>%
  dplyr::select(Model, Term, `OR [95% CI]`, `Beta [95% CI]`, `p-value`) %>%
  dplyr::filter(Term != "(Intercept)") %>%
  mutate(ICC = round(performance::icc(model_z_out_glmm)$ICC_adjusted[[1]], 3))

# GEE Model
model_z_out_summary_gee <- summary(model_z_out_gee) # Save model summary

beta_z_out_0_gee <- (model_z_out_summary_gee$coefficients[1,1]) # Intercept
beta_z_out_1_gee <- (model_z_out_summary_gee$coefficients[2,1]) # T Coefficient
beta_z_out_2_gee <- (model_z_out_summary_gee$coefficients[3,1]) # Z1 Coefficient

tidy_z_out_gee <- broom::tidy(model_z_out_gee, conf.int = TRUE, 
                            exponentiate = TRUE) %>%
  dplyr::select(term, estimate, std.error, p.value, conf.low, conf.high) %>%
  mutate(Model = "GEE",
         Term = term,
         `OR [95% CI]` = paste0(round(estimate, 3), " [", 
                            round(conf.low, 3), ", ", 
                            round(conf.high, 3), "]"),
         `Beta [95% CI]` = paste0(round(log(estimate), 3), " [", 
                            round(log(conf.low), 3), ", ", 
                            round(log(conf.high), 3), "]"),
         `p-value` = round(p.value, 3)) %>%
  dplyr::select(Model, Term, `OR [95% CI]`, `Beta [95% CI]`, `p-value`) %>%
  dplyr::filter(Term != "(Intercept)") %>%
  mutate(ICC = round(model_z_out_gee$geese$alpha[[1]], 3))

# Overall Output Table for SpW
z_out_Model_Table <- rbind(tidy_z_out, tidy_z_out_glmm) %>%
  rbind(tidy_z_out_gee)
```

```{r, results = 'asis', echo = FALSE}
print(xtable(z_out_Model_Table, 
             caption = "Outcome Model for Proportion VMMC"), 
      type = 'latex', include.rownames = FALSE, comment = FALSE)
```




```{r, echo = FALSE}
Ind_DirectIndirect_Table <- tibble(
  Model = c("LM/GLM", "LMM/GLMM", "GEE"),
  `Direct Effect` = c(beta_z_out_1,
                      beta_z_out_1_glmm, 
                      beta_z_out_1_gee),
  `Indirect Effect` = c(beta_z_med_1*beta_z_out_2,
                        beta_z_med_1_glmm*beta_z_out_2_glmm,
                        beta_z_med_1_gee*beta_z_out_2_gee)
  ) %>%
  mutate(`Total Effect` = `Direct Effect`+`Indirect Effect`) %>%
  mutate(`Proportion Mediated` = `Indirect Effect`/`Total Effect`)
```

```{r, results = 'asis', echo = FALSE}
print(xtable(Ind_DirectIndirect_Table, 
             caption = "Direct, Indirect, Total, and Proportion Mediated Proportion VMMC"), 
      type = 'latex', include.rownames = FALSE, comment = FALSE)
```



