---
title: "BCPP Preliminary Analysis"
author: "Melody Owen"
date: "2025-05-30"
output:
  pdf_document:
    toc: true
    toc_depth: 3
    latex_engine: pdflatex  # or xelatex/lualatex if you're using those
    includes:
      in_header: preamble.tex
geometry: margin=0.5in
---

\newpage

# OVERVIEW

## The Botswana Combination Prevention Project (BCPP)

### Motivation

- \underline{Goal}: The primary goal of BCPP was to determine whether implementation of combination prevention package (CP) can significantly reduce population-level, cumulative HIV incidence

- \underline{Population}: Individuals in Botswana aged 16-64 years

- \underline{Timeline}: Study length was approximately 3 years

- \underline{Design}: 30 communities were selected and matched into pairs based on community characteristics thought to be associated with HIV incidence

### Treatment in BCPP

The Combination Prevention (CP) prevention package included the following four components:

1. \underline{VMMC}: Male circumcision (only for HIV-negative males)

2. \underline{HTC}: HIV Testing and Counseling (only for HIV-negative individuals)

3. \underline{ART}: Antiretroviral Therapy (only for HIV-positive individuals)

4. \underline{PMTCT}: Prevention of mother-to-child transmission (only for pregnant HIV-positive females)

Clusters (30 communities) were randomized to either:

- \underline{Treatment}: CP Package

- \underline{Control}: Standard of Care

Our analysis examines the impact of CP for HIV-negative individuals, so we consider the "entire" package components 1 and 2 only.

\newpage

## Terminology

\underline{Individual Effects}: Refers to an effect of one's own input on their own outcome

\underline{Spillover Effects}: Refers to an effect of others' inputs on one's outcome

\underline{Direct Effects}: Refers to an effect pathway that links directly from an input to an output with nothing else on the pathway

\underline{Indirect Effects}: Refers to an effect pathway that links indirectly from an input to an output through a node (mediator) on the pathway \newline

With these, we can define the following:

\underline{Individual Effects}

  - **Individual Direct Effect**: Path from one's own input to their own outcome with no other nodes on the pathway
  - **Individual Indirect Effect**: Path from one's own input to their own outcome through a node (mediator) on the pathway
  - **Total Individual Effect**: Total effect of one's input on their outcome through all pathways (Individual Direct + Individual Indirect)

\underline{Spillover Effects}

  - **Spillover Direct Effect**: Path from others' inputs to one's outcome with no other nodes on the pathway
  - **Spillover Indirect Effect**: Path from others' inputs to one's outcome through a node (mediator) on the pathway
  - **Total Spillover Effect**: Total effect of other's inputs on one's outcome through all pathways (Spillover Direct + Spillover Indirect)

\underline{Overall Effects}
  
  - **Overall Effect**: Total Individual Effect + Total Spillover Effect

## Questions of Interest

1. What is the direct individual effect of the CP intervention on HIV incidence?

2. To what extent is the total individual effect mediated by Voluntary Male Medical Circumcision (VMMC)?

3. What is the direct spillover effect of the CP intervention on HIV incidence?

4. To what extent is the total spillover effect mediated by VMMC? 

5. What is the overall effect of CP on HIV incidence? ("overall" includes both spillover and individual totals)

6. To what extent is the overall effect mediated by VMMC? 

\newpage

# NOTATION

$K$ is the total number of villages in the study, indexed as $k = 1,...,K$

$m_k$ is the total number of individuals in cluster $k$, indexed as $i = 1,...,m_k$

- $m_k^{(\text{male})}$ are the total number of males in cluster $k$
- $m_k^{(\text{female})}$ are the total number of females in cluster $k$
    
$Y_{ik}$ is the outcome of subject $i$ in cluster $k$, and is binary

- In BCPP, $Y_{ik} = 1$ if a subject seroconverted by the end of the study, $Y_{ik} = 0$ otherwise

$T_k$ is the cluster-level binary treatment assignment

- In BCPP, $T_k = 1$ if a cluster has been assigned to receive CP, and $T_k = 0$ otherwise

$X_{ik}^{(1)}$, $X_{ik}^{(2)}$ denotes each of the two components of the treatment, $T_k$. 

- In BCPP, the Combination Prevention (CP) package included the following:

    1. MC: Male Circumcision (available only for HIV-negative males)
    2. HTC: HIV Testing and Counseling (available only for HIV-negative individuals)
    3. ART: Antiretroviral Therapy (available only for HIV-positive individuals)
    4. PMTCT: Prevention of Mother-to-Child Transmission (available only for HIV-positive females)
    
- We are only considering the first two components as the entire treatment package, since the last two apply to HIV-positive individuals only.
- $X_{ik}^{(1)} = \text{"Yes"}$ if individual $i$ in cluster $k$ was circumcised before or during the study, $X_{ik}^{(1)} = \text{"No"}$ if they are male and not circumcised, and $X_{ik}^{(1)} = \text{"Female"}$ if they are female (three levels are included as to not exclude females)
- $X_{ik}^{(2)} = 1$ if individual $i$ in cluster $k$ received HTC at enrollment or thereafter, and $X_{ik}^{(2)} = 0$ otherwise

$X_{ik}^{(12)}$ denotes whether individual $i$ in cluster $k$ received the entire treatment

- For males in BCPP, $X_{ik}^{(12)} = X_{ik}^{(1)} \times X_{ik}^{(2)} = 1$ if they received both MC and HTC, $X_{ik}^{(12)} = 0$ otherwise
- For females in BCPP, $X_{ik}^{(12)} = X_{ik}^{(2)} = 1$ if they received HTC, $X_{ik}^{(12)} = 0$ otherwise

$Z_k^{(1)}$, $Z_k^{(2)}$ is the proportion of indivividuals in village $k$ who received the first component and second component of the treatment, respectively

- For males in BCPP, $Z_k^{(1)} = \sum_{i=1}^{m_k^{(\text{male})}} \frac{X_{ik}^{(1)}}{m_k^{(\text{male})}}$ is the proportion of males in village $k$ who are circumcised before or during the study

- For all individuals in BCPP, $Z_k^{(2)} = \sum_{i=1}^{m_k} \frac{X_{ik}^{(2)}}{m_k}$ is the proportion of all individuals in village $k$ who received HTC

$Z_{ik}^{(12)}$ is the proportion of individuals who received the full treatment

- For males in BCPP, $Z_{ik}^{(12)} = \sum_{i=1}^{m_k^{(\text{male})}} \frac{X_{ik}^{(1)} \times X_{ik}^{(2)}}{m_k^{(\text{male})}}$ is the proportion of males who are both circumcised and received HTC
- For females in BCPP, $Z_{ik}^{(12)} = Z_{ik}^{(2)} = \sum_{i=1}^{m_k^{(\text{female})}} \frac{X_{ik}^{(2)}}{m_k^{(\text{female})}}$ is the proprtion of females who received HTC

$\mathbf{C}_{ik} = (C_{1k}^{(1)}, ..., C_{m_k k}^{(1)}, C_{1k}^{(2)}, ..., C_{m_k k}^{(2)})$ are the individual level covariates

$\mathbf{V}_k = (V_k^{(1)}, ..., V_k^{(v)})$ are the cluster-level covariates

\newpage

```{r setup, include = FALSE}
# Package names
packages <- c("tidyverse", "lme4", "MASS", "Matrix", "matrixcalc", "latex2exp",
              "ICC", "nlme", "bindata", "gee", "crt2power", "mosaic", "haven",
              "tmvtnorm", "ggplot2", "latex2exp", "reshape2", "gridExtra",
              "table1", "broom", "xtable", "logistf", "kableExtra", "geepack",
              "elrm", "broom", "dplyr", "tibble", "lme4", "broom.mixed",
              "performance", "mice", "glmnet")

# Install packages not yet installed
installed_packages <- packages %in% rownames(installed.packages())
if (any(installed_packages == FALSE)) {
  install.packages(packages[!installed_packages])
}

# Packages loading
invisible(lapply(packages, library, character.only = TRUE))
```


```{r load_data, include = FALSE}
# Loading in original datasets
dat1 <- read_sas("~/Desktop/3. Causal Inference Mediation/BCPP data/BCPP data/longyr1_20samp_open.sas7bdat")
dat2 <- read_sas("~/Desktop/3. Causal Inference Mediation/BCPP data/BCPP data/longyr2_20samp_open.sas7bdat")
dat3 <- read_sas("~/Desktop/3. Causal Inference Mediation/BCPP data/BCPP data/longyr3_20samp_open.sas7bdat")
```


```{r column_names, include = FALSE}
# Create a dataframe for each set of column names
names1 <- tibble(colname = sort(colnames(dat1)), dataset = "dat1")
names2 <- tibble(colname = sort(colnames(dat2)), dataset = "dat2")
names3 <- tibble(colname = sort(colnames(dat3)), dataset = "dat3")

# Bind and pivot to wide
all_names <- bind_rows(names1, names2, names3) %>%
  mutate(present = colname) %>%
  pivot_wider(names_from = dataset, values_from = present) %>%
  arrange(colname)

all_names_filtered <- bind_rows(names1, names2, names3) %>%
  mutate(present = colname) %>%
  pivot_wider(names_from = dataset, values_from = present) %>%
  arrange(colname) %>%
  dplyr::filter(colname %in% c("de_subj_idC", # Subject identifier
                               "community", # Community identifier
                               
                               "random_arm", # Randomization arm (Treatment Assignment)
                               "gender", # Gender
                               
                               # At start of study? Unclear
                               "hiv_status_current", # Current HIV status
                               "circumcised", # Male circumcision
                               
                               # "Coverage Endpoint"
                               "endpoint_coverage_htc", # Coverage endpoint: HIV-tested or diagnosed HIV+
                               "endpoint_coverage_mc", # Coverage endpoint: male circumcision
                               
                               
                               # Outcome
                               "endpoint_seroconvert") # Incidence endpoint: seroconverted by study completion
  )

# Keeping subject ID the same name so I can match the data
dat1_renamed <- dat1 %>% rename_with(~ paste0(., "_dat1"), -de_subj_idC)
dat2_renamed <- dat2 %>% rename_with(~ paste0(., "_dat2"), -de_subj_idC)
dat3_renamed <- dat3 %>% rename_with(~ paste0(., "_dat3"), -de_subj_idC)
```


```{r merging_datasets, include = FALSE}
# Circumcision in all three datasets
combinedDat <- full_join(dat1_renamed, dat2_renamed, by = "de_subj_idC") %>%
  full_join(dat3_renamed, by = "de_subj_idC") %>%
  dplyr::select(de_subj_idC, starts_with("random_arm_dat"), 
                contains("community_dat"),
                starts_with("Gender_dat"), hiv_status_current_dat1,
                starts_with("circumcised_dat"), contains("endpoint_coverage_mc"),
                contains("endpoint_coverage_htc"), contains("seroconvert")) %>%
  mutate(random_arm = ifelse(!is.na(random_arm_dat1), random_arm_dat1,
                             ifelse(!is.na(random_arm_dat2), random_arm_dat2,
                                    random_arm_dat3))) %>%
  mutate(gender = ifelse(!is.na(gender_dat1), gender_dat1,
                         ifelse(!is.na(gender_dat2), gender_dat2,
                                gender_dat3))) %>%
  mutate(community = ifelse(!is.na(community_dat1), community_dat1,
                            ifelse(!is.na(community_dat2), community_dat2,
                                   community_dat3))) %>%
  dplyr::select(subject_ID = de_subj_idC, community, gender,
                random_arm, hiv_status_current = hiv_status_current_dat1,
                starts_with("circumcised"),
                contains("endpoint_coverage_mc"), 
                contains("endpoint_coverage_htc"),
                contains("seroconvert")) %>%
  mutate(gender = case_when(gender == "F" ~ "Female",
                            gender == "M" ~ "Male",
                            TRUE ~ NA_character_
  )) %>%
  mutate(circumcised_dat1 = ifelse(gender == "Female",
                                   "Female", circumcised_dat1),
         circumcised_dat2 = ifelse(gender == "Female",
                                   "Female", circumcised_dat2),
         circumcised_dat3 = ifelse(gender == "Female",
                                   "Female", circumcised_dat3)) %>%
  mutate(circumcised_dat2 = ifelse(circumcised_dat1 == "Yes", "Yes",
                                   circumcised_dat2)) %>%
  mutate(circumcised_dat3 = ifelse(circumcised_dat2 == "Yes", "Yes",
                                   ifelse(circumcised_dat1 == "Yes", "Yes",
                                          circumcised_dat3))) %>%
  mutate(across(everything(), ~ na_if(., ""))) %>%
  mutate(across(where(is.character), str_trim)) %>%
  mutate(endpoint_coverage_mc_dat1 = ifelse(gender == "Female", "Female", endpoint_coverage_mc_dat1),
         endpoint_coverage_mc_dat2 = ifelse(gender == "Female", "Female", endpoint_coverage_mc_dat2),
         endpoint_coverage_mc_dat3 = ifelse(gender == "Female", "Female", endpoint_coverage_mc_dat3)) %>%
  mutate(endpoint_coverage_mc = ifelse(circumcised_dat1 == "Yes",
                                       "Began study circumcised", NA)) %>%
  mutate(endpoint_coverage_mc = ifelse(gender == "Female", "Female",
                                       endpoint_coverage_mc)) %>%
  mutate(endpoint_coverage_mc = ifelse(is.na(endpoint_coverage_mc) & endpoint_coverage_mc_dat3 == "Yes",
                                       "Yes", endpoint_coverage_mc)) %>%
  mutate(endpoint_coverage_mc = ifelse(is.na(endpoint_coverage_mc) & endpoint_coverage_mc_dat2 == "Yes",
                                       "Yes", endpoint_coverage_mc)) %>%
  mutate(endpoint_coverage_mc = ifelse(is.na(endpoint_coverage_mc) & endpoint_coverage_mc_dat1 == "Yes",
                                       "Yes", endpoint_coverage_mc)) %>%
  mutate(endpoint_coverage_mc = ifelse(is.na(endpoint_coverage_mc) & circumcised_dat3 == "Yes",
                                       "Yes", endpoint_coverage_mc)) %>%
  mutate(endpoint_coverage_mc = ifelse(is.na(endpoint_coverage_mc) & circumcised_dat2 == "Yes",
                                       "Yes", endpoint_coverage_mc)) %>%
  mutate(endpoint_coverage_mc = ifelse(is.na(endpoint_coverage_mc) &
                                         rowSums(across(contains("dat"), ~ replace_na(. == "No", FALSE))) > 0 &
                                         rowSums(across(contains("dat"), ~ replace_na(. == "Yes", FALSE))) == 0,
                                       "No", endpoint_coverage_mc))
```


```{r cleaning_data, include = FALSE}
# This dataset is a cleaned version of the original dataset with NO ONE EXCLUDED YET
cleanDat <- combinedDat %>%
  dplyr::select(original_subject_id = subject_ID, 
                original_glmmter_id = community, 
                random_arm, gender, 
                hiv_status_current,
                endpoint_coverage_htc = endpoint_coverage_htc_dat1, 
                endpoint_coverage_mc, 
                endpoint_seroconvert = endpoint_seroconvert_dat1) %>%
  mutate(endpoint_coverage_full = ifelse(gender == "Male" & (endpoint_coverage_mc == "Yes" | endpoint_coverage_mc == "Began study circumcised") & endpoint_coverage_htc == "Yes", "Yes", 
                         ifelse(gender == "Female" & endpoint_coverage_htc == "Yes", "Yes", "No"))) %>%
  arrange(original_glmmter_id, original_subject_id) %>%
  mutate_if(is.character, list(~na_if(., ""))) %>% # change any blanks to NAs
  rowid_to_column("subject_id") %>%
  group_by(original_glmmter_id) %>%
  mutate(cluster_id = cur_group_id()) %>%
  mutate(subj_glmmter_id = row_number()) %>%
  ungroup() %>%
  add_count(cluster_id, name = "cluster_size") %>%
  relocate(subject_id, subj_glmmter_id, cluster_id, cluster_size) %>%
  ungroup() %>%
  dplyr::select(-original_subject_id, -original_glmmter_id) %>%
  mutate(random_arm = ifelse(random_arm == "Standard of Care", "Control",
                             ifelse(random_arm == "Intervention", "Treatment", NA))) %>%
  mutate(endpoint_seroconvert = ifelse(hiv_status_current == "HIV-infected",
                                       "Began study HIV-infected", endpoint_seroconvert))
```

```{r create_model_dat, include = FALSE}
# ModelDat is the clean dataset but with people excluded
# Only exclude people who already have HIV or refused testing
modelDat_full <- cleanDat %>%
  # Calculate proportions first
  mutate(T_k = ifelse(random_arm == "Treatment", 1, 
                      ifelse(random_arm == "Control", 0, NA))) %>%
  # 1 if circumcised before or during study, 0 if no, "Female" if female
  mutate(X1_ik = ifelse(endpoint_coverage_mc == "Yes" | endpoint_coverage_mc == "Began study circumcised", "Yes",
                        ifelse(endpoint_coverage_mc == "No", "No", endpoint_coverage_mc))) %>%
  # 1 if HTC yes, 0 if HTC no
  mutate(X2_ik = ifelse(endpoint_coverage_htc == "Yes", 1,
                        ifelse(endpoint_coverage_htc == "No", 0, NA))) %>%
  # 1 if Male, circumcised, and got HTC | 1 if female and got HTC, 0 otherwise
  mutate(X12_ik = ifelse(gender == "Male" & X1_ik == "Yes" & X2_ik == 1, 1, 
                         ifelse(gender == "Female" & X2_ik == 1, 1, 0))) %>%
  # Gender characteristic, 1 if Male, 0 if female
  mutate(C1_ik = ifelse(gender == "Male", 1, 
                        ifelse(gender == "Female", 0, NA))) %>%
  group_by(cluster_id) %>%
  # Count of all men in each cluster
  mutate(male_count = sum(gender == "Male", na.rm = TRUE)) %>%
  # Count of all male circumcised men in each cluster
  mutate(mc_count = sum(X1_ik == "Yes", na.rm = TRUE)) %>%
  # Count of those who received HTC in each cluster
  mutate(htc_count = sum(X2_ik == 1, na.rm = TRUE)) %>%
  # Count of those who received their full treatment in each cluster
  mutate(full_trt_count = sum(X12_ik == 1, na.rm = TRUE)) %>%
  # Count of those who started study HIV positive in each cluster
  mutate(hiv_infected_count = sum(hiv_status_current == "HIV-infected", na.rm = TRUE)) %>%
  mutate(hiv_refused_testing_count = sum(hiv_status_current == "Refused HIV testing", na.rm = TRUE)) %>%
  ungroup() %>%
  # Treatment related proportions
  mutate(Z1_k = mc_count/male_count, # Prop males circumcised
         Z2_k = htc_count/cluster_size,
         Z12_k = full_trt_count/cluster_size) %>%
  # Characteristic related proportions
  mutate(hiv_infected_prop = hiv_infected_count/cluster_size) %>%
  mutate(hiv_refused_testing_prop = hiv_refused_testing_count/cluster_size) %>%
  mutate(Y_ik = ifelse(endpoint_seroconvert == "Yes", 1,
                       ifelse(endpoint_seroconvert == "No", 0, NA)))

# Then filter out people who already have HIV or refused testing
modelDat <- modelDat_full %>% 
  dplyr::filter(hiv_status_current == "HIV-uninfected") %>%
  dplyr::filter(!is.na(Y_ik))

excludedDat <- modelDat_full %>%
  dplyr::filter(hiv_status_current != "HIV-uninfected" | is.na(hiv_status_current) | is.na(Y_ik))
```

# BASELINE CHARACTERISTICS

## Characteristics Before Exclusions

The original dataset has `r nrow(cleanDat)` total individuals in the study; `r nrow(dplyr::filter(cleanDat, random_arm == "Treatment"))` in the treatment group, and `r nrow(dplyr::filter(cleanDat, random_arm == "Control"))` in the control arm. 


```{r include = FALSE}
var_order_full <- c("Gender", "HIV Status at Start", "Treatment Component: MC",
                    "Treatment Component: HTC", "Treatment Component: Full",
                    "Outcome: HIV Seroconversion (3-year period)")
level_order_full <- c("Male", "Yes", "No", "Began study circumcised", "Female",
                      "HIV-uninfected", "HIV-infected", "Refused HIV testing",
                      "Began study HIV-infected")

baseline_full <- cleanDat %>%
  dplyr::select(`Treatment Group` = random_arm,
                `Cluster Size` = cluster_size,
                `Gender` = gender,
                `HIV Status at Start` = hiv_status_current,
                `Treatment Component: MC` = endpoint_coverage_mc,
                `Treatment Component: HTC` = endpoint_coverage_htc,
                `Treatment Component: Full` = endpoint_coverage_full,
                `Outcome: HIV Seroconversion (3-year period)` = endpoint_seroconvert) %>%
  mutate(across(
    where(~ !is.numeric(.x)),
    ~ ifelse(is.na(.x), "Missing", as.character(.x))
  ))

baseline_missing <- baseline_full %>%
  dplyr::select(-`Cluster Size`) %>%
  filter(if_any(everything(), ~ .x == "Missing")) %>%
  mutate(across(
    .cols = -c(`Treatment Group`),  # replace col1 and col2 with your actual column names
    .fns = ~ if_else(.x == "Missing", 1, 0)
  )) %>%
  group_by(`Treatment Group`) %>%
  summarise(across(
    everything(),  # No need to exclude the grouping var here
    sum,
    .names = "{.col}"
  )) %>%
  dplyr::select(-Gender) %>%
  ungroup() %>%
  pivot_longer(
    cols = -`Treatment Group`,  # gather all variables except the group
    names_to = "Variable",
    values_to = "Missing"
  ) %>%
  pivot_wider(
    names_from = `Treatment Group`,
    values_from = Missing
  ) %>%
  mutate(Overall = Control + Treatment) %>%
  rename(`Missing (Control)` = Control,
         `Missing (Treatment)` = Treatment,
         `Missing (Overall)` = Overall)

cluster_size <- tibble(Variable = c("Number of Individuals", 
                                    "Number of Clusters", 
                                    "Mean Cluster Size"),
                       Level = c(NA, NA, NA),
                       Control = c(nrow(dplyr::filter(cleanDat, random_arm == "Control")),
                                   length(unique(dplyr::filter(cleanDat, random_arm == "Control")$cluster_id)),
                                   mean(filter(cleanDat, random_arm == "Control")$cluster_size)),
                       Treatment = c(nrow(dplyr::filter(cleanDat, random_arm == "Treatment")),
                                     length(unique(dplyr::filter(cleanDat, random_arm == "Treatment")$cluster_id)),
                                     mean(filter(cleanDat, random_arm == "Treatment")$cluster_size))) %>%
  mutate(Control = as.integer(Control), Treatment = as.integer(Treatment)) %>%
  mutate(Overall = ifelse(Variable != "Mean Cluster Size", Treatment + Control, round((Treatment + Control) / 2, 1)))

baseline_tab <- baseline_full %>%
  dplyr::select(-`Cluster Size`) %>%
  pivot_longer(!`Treatment Group`, 
               names_to = "Variable", values_to = "Level") %>%
  arrange(`Treatment Group`, Variable, Level) %>%
  group_by(`Treatment Group`, Variable, Level) %>%
  summarize(n = n()) %>%
  ungroup() %>%
  filter(Level != "Missing") %>%
  group_by(`Treatment Group`, `Variable`) %>%
  mutate(Overall = sum(n)) %>%
  ungroup() %>%
  rowwise() %>%
  mutate(percentage = paste0("(", round(n/Overall, 2)*100, "%)")) %>%
  mutate(n = paste(n, percentage)) %>%
  dplyr::select(-Overall, -percentage) %>%
  pivot_wider(
    names_from = `Treatment Group`,
    values_from = n
  ) %>%
  mutate(
    Overall = parse_number(Control) + parse_number(Treatment)
  ) %>%
  group_by(Variable) %>%
  mutate(Sum = sum(Overall)) %>%
  mutate(Overall = paste0(Overall, " (", round(Overall/Sum, 2)*100, "%)")) %>%
  dplyr::select(-Sum) %>%
  mutate(Variable = factor(Variable, levels = var_order_full),
         Level = factor(Level, levels = level_order_full)) %>%
  arrange(Variable, Level)

n_treat_full <- nrow(filter(cleanDat, random_arm == "Treatment"))
n_control_full <- nrow(filter(cleanDat, random_arm == "Control"))
n_overall_full <- nrow(cleanDat)

final_baseline_full_table <- rbind(cluster_size, baseline_tab) %>%
  left_join(baseline_missing, by = "Variable") %>%
  group_by(Variable) %>%
  mutate(
    Variable = if_else(row_number() == 1, Variable, NA_character_),
    `Missing (Control)` = if_else(row_number() == 1, `Missing (Control)`, NA_integer_),
    `Missing (Treatment)` = if_else(row_number() == 1, `Missing (Treatment)`, NA_integer_),
    `Missing (Overall)` = if_else(row_number() == 1, `Missing (Overall)`, NA_integer_)
  ) %>%
  ungroup() %>%
  mutate(`Missing (Control)` = as.integer(`Missing (Control)`),
         `Missing (Treatment)` = as.integer(`Missing (Treatment)`),
         `Missing (Overall)` = as.integer(`Missing (Overall)`)) %>%
  rowwise() %>%
  mutate(`Missing (Control)` = ifelse(!is.na(`Missing (Control)`), 
                                      paste0(`Missing (Control)`, " (", 
                                             round(`Missing (Control)`/n_control_full, 2)*100, "%)"), NA),
         `Missing (Treatment)` = ifelse(!is.na(`Missing (Treatment)`), 
                                      paste0(`Missing (Treatment)`, " (", 
                                             round(`Missing (Treatment)`/n_treat_full, 2)*100, "%)"), NA),
         `Missing (Overall)` = ifelse(!is.na(`Missing (Overall)`), 
                                      paste0(`Missing (Overall)`, " (", 
                                             round(`Missing (Overall)`/n_overall_full, 2)*100, "%)"), NA))
```


```{r, results = 'asis', echo = FALSE}
cat("\\begin{landscape}\n")

print(
  xtable(
    final_baseline_full_table,
    caption = "Characteristics by treatment group before exclusions",
    label = "tab:cluster_summary"
  ),
  type = "latex",
  include.rownames = FALSE,
  comment = FALSE
)

cat("\\end{landscape}\n")
```


Table below displays the mean proportion, per cluster, of various characteristics, including mean proportion of HIV infected individuals per cluster at baseline, etc. These are calculated before any exclusions. Note that for the proportion of males circumcised in a given cluster, this includes both circumcision that occurred during and before the study. 

```{r include = FALSE}
proportion_dat <- modelDat %>%
  mutate(`Proportion of Males in Cluster` = male_count/cluster_size) %>%
  dplyr::select(cluster_id, 
                `Treatment Group` = random_arm,
                `Proportion of HIV Infected in Cluster` = hiv_infected_prop,
                #`Proportion of Refused HIV Testing in Cluster` = hiv_refused_testing_prop,
                `Proportion of Males in Cluster`,
                `Proportion of Males Circumcised in Cluster` = Z1_k, 
                `Proportion HTC in Cluster` = Z2_k,
                `Proportion Fully Treated in Cluster` = Z12_k) %>%
  distinct()

# Compute summary with Mean and SD
proportion_table_final <- proportion_dat %>%
  group_by(`Treatment Group`) %>%
  dplyr::select(-cluster_id) %>%
  summarize(across(
    everything(),
    list(
      Mean = ~mean(.x, na.rm = TRUE),
      SD = ~sd(.x, na.rm = TRUE)
    ),
    .names = "{.fn} | {.col}"
  )) %>%
  mutate(across(where(is.numeric), round, 2)) %>%
  pivot_longer(
    -`Treatment Group`,
    names_to = "Stat_Var",
    values_to = "Value"
  ) %>%
  separate(Stat_Var, into = c("Stat", "Variable"), sep = " \\| ") %>%
  pivot_wider(
    names_from = Stat,
    values_from = Value
  ) %>%
  mutate(
    Value = paste0(Mean, " (", SD, ")"),
    Variable = paste0(Variable, " (Mean, SD)")
  ) %>%
  dplyr::select(-Mean, -SD) %>%
  pivot_wider(
    names_from = `Treatment Group`,
    values_from = Value
  )

# View result
#proportion_table_final
#View(proportion_table_final)
```

```{r, results = 'asis', echo = FALSE}
print(
  xtable(
    proportion_table_final,
    caption = "Cluster-level proportions by treatment group before exclusions",
    label = "tab:cluster_summary"
  ),
  type = "latex",
  include.rownames = FALSE,
  comment = FALSE
)
```

## Characteristics After Exclusions

A total of `r nrow(excludedDat)` individuals were excluded from the analysis dataset. This is because these individuals either began the study as HIV-positive (n = `r nrow(filter(excludedDat, hiv_status_current == "HIV-infected"))`), refused HIV testing (n = `r nrow(filter(excludedDat, hiv_status_current == "Refused HIV testing"))`), or had a missing value (n = `r nrow(filter(excludedDat, is.na(hiv_status_current)))`). Or, if they began the study HIV-negative, if they had a missing value for seroconversion (the outcome), they were excluded (n = `r nrow(dplyr::filter(modelDat_full, hiv_status_current == "HIV-uninfected") %>% dplyr::filter(is.na(Y_ik)))`). 

Note that in our analyses, we evaluated whether the intervention reduced HIV incidence by modeling seroconversion among individuals who were HIV-negative at baseline (n = `r nrow(modelDat)`). Although the analysis was restricted to this at-risk subset, all cluster-level characteristics (e.g., proportion HIV-positive at baseline, proportion of men circumcised, etc.) were calculated using the full study population. This approach ensures that the covariates reflect the overall context and implementation environment of each cluster, rather than being limited to the analytic subset.

The following table shows the baseline characteristics of the new dataset that excludes these individuals (n = `r nrow(modelDat)`). 

```{r include = FALSE}
var_order_red <- c("Gender", "HIV Status at Start", "Treatment Component: MC",
                    "Treatment Component: HTC", "Treatment Component: Full",
                    "Outcome: HIV Seroconversion (3-year period)")
level_order_red <- c("Male", "Yes", "No", "Began study circumcised", "Female",
                      "HIV-uninfected", "HIV-infected", "Refused HIV testing",
                      "Began study HIV-infected")

baseline_red <- modelDat %>%
  dplyr::select(`Treatment Group` = random_arm,
                `Cluster Size` = cluster_size,
                `Gender` = gender,
                `HIV Status at Start` = hiv_status_current,
                `Treatment Component: MC` = endpoint_coverage_mc,
                `Treatment Component: HTC` = endpoint_coverage_htc,
                `Treatment Component: Full` = endpoint_coverage_full,
                `Outcome: HIV Seroconversion (3-year period)` = endpoint_seroconvert) %>%
  mutate(across(
    where(~ !is.numeric(.x)),
    ~ ifelse(is.na(.x), "Missing", as.character(.x))
  ))

baseline_missing_red <- baseline_red %>%
  dplyr::select(-`Cluster Size`) %>%
  filter(if_any(everything(), ~ .x == "Missing")) %>%
  mutate(across(
    .cols = -c(`Treatment Group`),  # replace col1 and col2 with your actual column names
    .fns = ~ if_else(.x == "Missing", 1, 0)
  )) %>%
  group_by(`Treatment Group`) %>%
  summarise(across(
    everything(),  # No need to exclude the grouping var here
    sum,
    .names = "{.col}"
  )) %>%
  dplyr::select(-Gender) %>%
  ungroup() %>%
  pivot_longer(
    cols = -`Treatment Group`,  # gather all variables except the group
    names_to = "Variable",
    values_to = "Missing"
  ) %>%
  pivot_wider(
    names_from = `Treatment Group`,
    values_from = Missing
  ) %>%
  mutate(Overall = Control + Treatment) %>%
  rename(`Missing (Control)` = Control,
         `Missing (Treatment)` = Treatment,
         `Missing (Overall)` = Overall)

cluster_size_red <- tibble(Variable = c("Number of Individuals", 
                                    "Number of Clusters", 
                                    "Mean Cluster Size"),
                       Level = c(NA, NA, NA),
                       Control = c(nrow(dplyr::filter(modelDat, random_arm == "Control")),
                                   length(unique(dplyr::filter(modelDat, random_arm == "Control")$cluster_id)),
                                   mean(filter(modelDat, random_arm == "Control")$cluster_size)),
                       Treatment = c(nrow(dplyr::filter(modelDat, random_arm == "Treatment")),
                                     length(unique(dplyr::filter(modelDat, random_arm == "Treatment")$cluster_id)),
                                     mean(filter(modelDat, random_arm == "Treatment")$cluster_size))) %>%
  mutate(Control = as.integer(Control), Treatment = as.integer(Treatment)) %>%
  mutate(Overall = ifelse(Variable != "Mean Cluster Size", Treatment + Control, round((Treatment + Control) / 2, 1)))

baseline_tab_red <- baseline_red %>%
  dplyr::select(-`Cluster Size`) %>%
  pivot_longer(!`Treatment Group`, 
               names_to = "Variable", values_to = "Level") %>%
  arrange(`Treatment Group`, Variable, Level) %>%
  group_by(`Treatment Group`, Variable, Level) %>%
  summarize(n = n()) %>%
  ungroup() %>%
  filter(Level != "Missing") %>%
  group_by(`Treatment Group`, `Variable`) %>%
  mutate(Overall = sum(n)) %>%
  ungroup() %>%
  rowwise() %>%
  mutate(percentage = paste0("(", round(n/Overall, 2)*100, "%)")) %>%
  mutate(n = paste(n, percentage)) %>%
  dplyr::select(-Overall, -percentage) %>%
  pivot_wider(
    names_from = `Treatment Group`,
    values_from = n
  ) %>%
  mutate(
    Overall = parse_number(Control) + parse_number(Treatment)
  ) %>%
  group_by(Variable) %>%
  mutate(Sum = sum(Overall)) %>%
  mutate(Overall = paste0(Overall, " (", round(Overall/Sum, 2)*100, "%)")) %>%
  dplyr::select(-Sum) %>%
  mutate(Variable = factor(Variable, levels = var_order_full),
         Level = factor(Level, levels = level_order_full)) %>%
  arrange(Variable, Level)

n_treat_red <- nrow(filter(modelDat, random_arm == "Treatment"))
n_control_red <- nrow(filter(modelDat, random_arm == "Control"))
n_overall_red <- nrow(modelDat)

final_baseline_red_table <- rbind(cluster_size_red, baseline_tab_red) %>%
  left_join(baseline_missing_red, by = "Variable") %>%
  group_by(Variable) %>%
  mutate(
    Variable = if_else(row_number() == 1, Variable, NA_character_),
    `Missing (Control)` = if_else(row_number() == 1, `Missing (Control)`, NA_integer_),
    `Missing (Treatment)` = if_else(row_number() == 1, `Missing (Treatment)`, NA_integer_),
    `Missing (Overall)` = if_else(row_number() == 1, `Missing (Overall)`, NA_integer_)
  ) %>%
  ungroup() %>%
  mutate(`Missing (Control)` = as.integer(`Missing (Control)`),
         `Missing (Treatment)` = as.integer(`Missing (Treatment)`),
         `Missing (Overall)` = as.integer(`Missing (Overall)`)) %>%
  rowwise() %>%
  mutate(`Missing (Control)` = ifelse(!is.na(`Missing (Control)`), 
                                      paste0(`Missing (Control)`, " (", 
                                             round(`Missing (Control)`/n_control_full, 2)*100, "%)"), NA),
         `Missing (Treatment)` = ifelse(!is.na(`Missing (Treatment)`), 
                                        paste0(`Missing (Treatment)`, " (", 
                                               round(`Missing (Treatment)`/n_treat_full, 2)*100, "%)"), NA),
         `Missing (Overall)` = ifelse(!is.na(`Missing (Overall)`), 
                                      paste0(`Missing (Overall)`, " (", 
                                             round(`Missing (Overall)`/n_overall_full, 2)*100, "%)"), NA)) %>%
  mutate(`Missing (Control)` = ifelse(`Missing (Control)` == "0 (0%)", 
                                      NA, `Missing (Control)`),
         `Missing (Treatment)` = ifelse(`Missing (Treatment)` == "0 (0%)", 
                                      NA, `Missing (Treatment)`),
         `Missing (Overall)` = ifelse(`Missing (Overall)` == "0 (0%)", 
                                      NA, `Missing (Overall)`))
```


```{r, results = 'asis', echo = FALSE}
cat("\\begin{landscape}\n")

print(
  xtable(
    final_baseline_red_table,
    caption = "Characteristics by treatment group after exclusions",
    label = "tab:cluster_summary"
  ),
  type = "latex",
  include.rownames = FALSE,
  comment = FALSE
)

cat("\\end{landscape}\n")
```



\newpage 

# MODELING RESULTS

## Within-Village Spillover


\underline{Setup}

- In this analysis, we include everyone in the study (who began the study HIV-negative) who DID NOT receive any part of the treatment. 

- This setup will allow us to estimate

    a. Total Within-Cluster Spillover Effect of the Intervention
    b. Within-Cluster Spillover of the Intervention Effect Not through Male Circumcision
    c. Proportion of Within-Intervention Village Spillover Effect Mediated by Circumcision
    
\underline{Dataset}

```{r}
# Only include those in treatment group who DID NOT receive any part of the treatment
# Only include those in control group who DID NOT receive any part of treatment
modelDat_SpW <- modelDat %>%
  filter(X1_ik != "Yes", X2_ik == 0) # Exclude anyone who got any part of the treatment
```

The total sample size for this analysis is `r nrow(modelDat_SpW)`, meaning that `r nrow(modelDat) - nrow(modelDat_SpW)` individuals are excluded. 

\underline{Data Characteristics}

```{r, include = FALSE}
var_order_SpW <- c("Gender", "HIV Status at Start", "Treatment Component: MC",
                    "Treatment Component: HTC", "Treatment Component: Full",
                    "Outcome: HIV Seroconversion (3-year period)")
level_order_SpW <- c("Male", "Yes", "No", "Began study circumcised", "Female",
                      "HIV-uninfected", "HIV-infected", "Refused HIV testing",
                      "Began study HIV-infected")

baseline_SpW <- modelDat_SpW %>%
  dplyr::select(`Treatment Group` = random_arm,
                `Cluster Size` = cluster_size,
                `Gender` = gender,
                `HIV Status at Start` = hiv_status_current,
                `Treatment Component: MC` = endpoint_coverage_mc,
                `Treatment Component: HTC` = endpoint_coverage_htc,
                `Treatment Component: Full` = endpoint_coverage_full,
                `Outcome: HIV Seroconversion (3-year period)` = endpoint_seroconvert) %>%
  mutate(across(
    where(~ !is.numeric(.x)),
    ~ ifelse(is.na(.x), "Missing", as.character(.x))
  ))

# No missing observed
# baseline_missing_SpW <- baseline_SpW %>%
#   dplyr::select(-`Cluster Size`) %>%
#   filter(if_any(everything(), ~ .x == "Missing")) %>%
#   mutate(across(
#     .cols = -c(`Treatment Group`),  # replace col1 and col2 with your actual column names
#     .fns = ~ if_else(.x == "Missing", 1, 0)
#   )) %>%
#   group_by(`Treatment Group`) %>%
#   summarise(across(
#     everything(),  # No need to exclude the grouping var here
#     sum,
#     .names = "{.col}"
#   )) %>%
#   dplyr::select(-Gender) %>%
#   ungroup() %>%
#   pivot_longer(
#     cols = -`Treatment Group`,  # gather all variables except the group
#     names_to = "Variable",
#     values_to = "Missing"
#   ) %>%
#   pivot_wider(
#     names_from = `Treatment Group`,
#     values_from = Missing
#   ) %>%
#   mutate(Overall = Control + Treatment) %>%
#   rename(`Missing (Control)` = Control,
#          `Missing (Treatment)` = Treatment,
#          `Missing (Overall)` = Overall)

cluster_size_SpW <- tibble(Variable = c("Number of Individuals", 
                                    "Number of Clusters", 
                                    "Mean Cluster Size"),
                       Level = c(NA, NA, NA),
                       Control = c(nrow(dplyr::filter(modelDat_SpW, random_arm == "Control")),
                                   length(unique(dplyr::filter(modelDat_SpW, random_arm == "Control")$cluster_id)),
                                   mean(filter(modelDat_SpW, random_arm == "Control")$cluster_size)),
                       Treatment = c(nrow(dplyr::filter(modelDat_SpW, random_arm == "Treatment")),
                                     length(unique(dplyr::filter(modelDat_SpW, random_arm == "Treatment")$cluster_id)),
                                     mean(filter(modelDat_SpW, random_arm == "Treatment")$cluster_size))) %>%
  mutate(Control = as.integer(Control), Treatment = as.integer(Treatment)) %>%
  mutate(Overall = ifelse(Variable != "Mean Cluster Size", Treatment + Control, round((Treatment + Control) / 2, 1)))

baseline_tab_SpW <- baseline_SpW %>%
  dplyr::select(-`Cluster Size`) %>%
  pivot_longer(!`Treatment Group`, 
               names_to = "Variable", values_to = "Level") %>%
  arrange(`Treatment Group`, Variable, Level) %>%
  group_by(`Treatment Group`, Variable, Level) %>%
  summarize(n = n()) %>%
  ungroup() %>%
  filter(Level != "Missing") %>%
  group_by(`Treatment Group`, `Variable`) %>%
  mutate(Overall = sum(n)) %>%
  ungroup() %>%
  rowwise() %>%
  mutate(percentage = paste0("(", round(n/Overall, 2)*100, "%)")) %>%
  mutate(n = paste(n, percentage)) %>%
  dplyr::select(-Overall, -percentage) %>%
  pivot_wider(
    names_from = `Treatment Group`,
    values_from = n
  ) %>%
  mutate(
    Overall = parse_number(Control) + parse_number(Treatment)
  ) %>%
  group_by(Variable) %>%
  mutate(Sum = sum(Overall)) %>%
  mutate(Overall = paste0(Overall, " (", round(Overall/Sum, 2)*100, "%)")) %>%
  dplyr::select(-Sum) %>%
  mutate(Variable = factor(Variable, levels = var_order_full),
         Level = factor(Level, levels = level_order_full)) %>%
  arrange(Variable, Level)

n_treat_SpW <- nrow(filter(modelDat_SpW, random_arm == "Treatment"))
n_control_SpW <- nrow(filter(modelDat_SpW, random_arm == "Control"))
n_overall_SpW <- nrow(modelDat_SpW)

final_baseline_SpW_table <- rbind(cluster_size_SpW, baseline_tab_SpW) %>%
  #left_join(baseline_missing_SpW, by = "Variable") %>% No missing observed
  group_by(Variable) %>%
  mutate(
    Variable = if_else(row_number() == 1, Variable, NA_character_)
  #   `Missing (Control)` = if_else(row_number() == 1, `Missing (Control)`, NA_integer_),
  #   `Missing (Treatment)` = if_else(row_number() == 1, `Missing (Treatment)`, NA_integer_),
  #   `Missing (Overall)` = if_else(row_number() == 1, `Missing (Overall)`, NA_integer_)
  ) 
  # ungroup() %>%
  # mutate(`Missing (Control)` = as.integer(`Missing (Control)`),
  #        `Missing (Treatment)` = as.integer(`Missing (Treatment)`),
  #        `Missing (Overall)` = as.integer(`Missing (Overall)`)) %>%
  # rowwise() %>%
  # mutate(`Missing (Control)` = ifelse(!is.na(`Missing (Control)`), 
  #                                     paste0(`Missing (Control)`, " (", 
  #                                            round(`Missing (Control)`/n_control_full, 2)*100, "%)"), NA),
  #        `Missing (Treatment)` = ifelse(!is.na(`Missing (Treatment)`), 
  #                                       paste0(`Missing (Treatment)`, " (", 
  #                                              round(`Missing (Treatment)`/n_treat_full, 2)*100, "%)"), NA),
  #        `Missing (Overall)` = ifelse(!is.na(`Missing (Overall)`), 
  #                                     paste0(`Missing (Overall)`, " (", 
  #                                            round(`Missing (Overall)`/n_overall_full, 2)*100, "%)"), NA))

```



```{r, results = 'asis', echo = FALSE}
cat("\\begin{landscape}\n")

print(
  xtable(
    final_baseline_SpW_table,
    caption = "Characteristics of Spillover Effects Analysis Data",
  ),
  type = "latex",
  include.rownames = FALSE,
  comment = FALSE
)

cat("\\end{landscape}\n")
```

\newpage

### A. Total Within-Cluster Spillover Effect of the Intervention

"SpW" denotes total spillover within intervention clusters. This compares participants in intervention villages who received neither relevant intervention component to people in the control villages (who also did not receive any part of the intervention component)

Then, under certain assumptions, the only way for an intervention village participant to have lower HIV risk is by association with others in the village with lower HIV risk because of their exposure to the intervention. 

$$logit(Y_{ik}) = \beta_0^{\text{SpW}} + \beta_1^{\text{SpW}}(T_{k})$$

Then $\exp\left( \beta_1^{\text{SpW}} \right)$ is a within-village spillover OR, and estimates the causal effect of living in a CP village, despite receiving no components oneself, on the odds of seroconversion. This is total within-village spillover effect. 

```{r}
# Total Within-Cluster Spillover Effect of the Intervention Model

# Model not accounting for clustering
model_SpW <- glm(Y_ik ~ T_k,
                 family = binomial(link = 'logit'),
                 data = modelDat_SpW) # Exclude those who received full trt

# Model accounting for clustering using GLMM
model_SpW_glmm <- glmer(Y_ik ~ T_k + (1|cluster_id), # Uses exchangeable structure
                        data = modelDat_SpW, 
                        family = binomial(link = "logit"))

# Model accounting for clustering using GEE
model_SpW_gee <- geeglm(Y_ik ~ T_k,
                        family = binomial(link = "logit"), # logit link
                        id = cluster_id, # clustering variable
                        data = modelDat_SpW,
                        corstr  = "exchangeable") # working correlation
```

```{r, echo = FALSE}
# GLM Model
model_SpW_summary <- summary(model_SpW) # Save model summary

exp_beta_SpW_0 <- exp(model_SpW_summary$coefficients[1,1]) # Intercept
exp_beta_SpW_1 <- exp(model_SpW_summary$coefficients[2,1]) # T_k Coefficient

tidy_SpW <- broom::tidy(model_SpW, conf.int = TRUE, exponentiate = TRUE) %>%
  dplyr::select(term, estimate, std.error, p.value, conf.low, conf.high) %>%
  mutate(Model = "GLM",
         Term = term,
         `OR [95% CI]` = paste0(round(estimate, 3), " [", 
                            round(conf.low, 3), ", ", 
                            round(conf.high, 3), "]"),
         `p-value` = round(p.value, 3)) %>%
  dplyr::select(Model, Term, `OR [95% CI]`, `p-value`) %>%
  dplyr::filter(Term != "(Intercept)") %>%
  mutate(ICC = NA)

# GLMM Model
model_SpW_summary_glmm <- summary(model_SpW_glmm) # Save model summary

exp_beta_SpW_0_glmm <- exp(model_SpW_summary_glmm$coefficients[1,1]) # Intercept
exp_beta_SpW_1_glmm <- exp(model_SpW_summary_glmm$coefficients[2,1]) # T_k Coefficient

tidy_SpW_glmm <- broom.mixed::tidy(model_SpW_glmm, effects = "fixed", 
                  conf.int = TRUE, exponentiate = TRUE) %>%
  dplyr::select(term, estimate, std.error, p.value, conf.low, conf.high) %>%
  mutate(Model = "GLMM",
         Term = term,
         `OR [95% CI]` = paste0(round(estimate, 3), " [", 
                            round(conf.low, 3), ", ", 
                            round(conf.high, 3), "]"),
         `p-value` = round(p.value, 3)) %>%
  dplyr::select(Model, Term, `OR [95% CI]`, `p-value`) %>%
  dplyr::filter(Term != "(Intercept)") %>%
  mutate(ICC = round(performance::icc(model_SpW_glmm)$ICC_adjusted[[1]], 3))

# GEE Model
model_SpW_summary_gee <- summary(model_SpW_gee) # Save model summary

exp_beta_SpW_0_gee <- exp(model_SpW_summary_gee$coefficients[1,1]) # Intercept
exp_beta_SpW_1_gee <- exp(model_SpW_summary_gee$coefficients[2,1]) # T_k Coefficient

tidy_SpW_gee <- broom::tidy(model_SpW_gee, conf.int = TRUE, 
                            exponentiate = TRUE) %>%
  dplyr::select(term, estimate, std.error, p.value, conf.low, conf.high) %>%
  mutate(Model = "GEE",
         Term = term,
         `OR [95% CI]` = paste0(round(estimate, 3), " [", 
                            round(conf.low, 3), ", ", 
                            round(conf.high, 3), "]"),
         `p-value` = round(p.value, 3)) %>%
  dplyr::select(Model, Term, `OR [95% CI]`, `p-value`) %>%
  dplyr::filter(Term != "(Intercept)") %>%
  mutate(ICC = round(model_SpW_gee$geese$alpha[[1]], 3))

# Overall Output Table for SpW
SpW_Model_Table <- rbind(tidy_SpW, tidy_SpW_glmm) %>%
  rbind(tidy_SpW_gee)
```

```{r, results = 'asis', echo = FALSE}
print(xtable(SpW_Model_Table, 
             caption = "Spillover Within Intervention Clusters Model Output"), 
      type = 'latex', include.rownames = FALSE, comment = FALSE)
```

Thus, among people who received none of the intervention components, those living in CP villages had `r (1-round(exp_beta_SpW_1, 2))*100`% lower odds of HIV seroconversion than otherwise comparable untreated people in control villages. Since every individual in this analytic set is personally untreated, any difference in their HIV risk can only arise from indirect protection, and thus, `r round(exp_beta_SpW_1, 2)` is interpreted as the within-village spillover effect of CP.

\newpage

### B. Within-Cluster Spillover of the Intervention Effect Not through Male Circumcision

"SpWR" denotes all the remaining spillover that affects one's outcome that exists when we block the mediated spillover path that exists through male circumcision. 

$$logit(Y_{ik}) = \beta_0^{\text{SpWR}} + \beta_1^{\text{SpWR}}(T_{k}) + \beta_2^{\text{SpWR}}(Z_k^{(1)})$$

Here, $\exp\left(\beta_1^{\text{SpWR}} \right)$ compares untreated individuals in CP villages with untreated individuals in control villages after we hold the village's male-circumcision coverage fixed at the same value for both groups. So, it's the OR for the remaining within-village spillover - whatever protection (or risk) is left once the male-circumcision pathway has been accounted for. 

```{r}
# Within-Cluster Spillover of the Intervention Not Through MC

# Model not accounting for clustering
model_SpWR <- glm(Y_ik ~ T_k + Z1_k,
                  family = binomial(link = 'logit'),
                  data = modelDat_SpW)

# Model accounting for clustering using GLMM
model_SpWR_glmm <- glmer(Y_ik ~ T_k + Z1_k + (1|cluster_id), # Uses exchangeable
                         data = modelDat_SpW, 
                         family = binomial(link = "logit"))

# Model accounting for clustering using GEE
model_SpWR_gee <- geeglm(Y_ik ~ T_k + Z1_k,
                         family = binomial(link = "logit"),
                         id = cluster_id,
                         data = modelDat_SpW,
                         corstr = "exchangeable") # working correlation
```

```{r, echo = FALSE}
# GlM Model
model_SpWR_summary <- summary(model_SpWR) # Save model summary

exp_beta_SpWR_0 <- exp(model_SpWR_summary$coefficients[1,1]) # Intercept
exp_beta_SpWR_1 <- exp(model_SpWR_summary$coefficients[2,1]) # T_k Coefficient
exp_beta_SpWR_2 <- exp(model_SpWR_summary$coefficients[3,1]) # Z1_k Coefficient

tidy_SpWR <- broom::tidy(model_SpWR, conf.int = TRUE, exponentiate = TRUE) %>%
  dplyr::select(term, estimate, std.error, p.value, conf.low, conf.high) %>%
  mutate(Model = "GLM",
         Term = term,
         `OR [95% CI]` = paste0(round(estimate, 3), " [", 
                            round(conf.low, 3), ", ", 
                            round(conf.high, 3), "]"),
         `p-value` = round(p.value, 3)) %>%
  dplyr::select(Model, Term, `OR [95% CI]`, `p-value`) %>%
  dplyr::filter(Term != "(Intercept)") %>%
  mutate(ICC = NA)

# GLMM Model
model_SpWR_summary_glmm <- summary(model_SpWR_glmm) # Save model summary
exp_beta_SpWR_0_glmm <- exp(model_SpWR_summary_glmm$coefficients[1,1]) # Intercept
exp_beta_SpWR_1_glmm <- exp(model_SpWR_summary_glmm$coefficients[2,1]) # T_k Coefficient
exp_beta_SpWR_2_glmm <- exp(model_SpWR_summary_glmm$coefficients[3,1]) # Z1_k Coefficient

tidy_SpWR_glmm <- broom.mixed::tidy(model_SpWR_glmm, effects = "fixed", 
                  conf.int = TRUE, exponentiate = TRUE) %>%
  dplyr::select(term, estimate, std.error, p.value, conf.low, conf.high) %>%
  mutate(Model = "GLMM",
         Term = term,
         `OR [95% CI]` = paste0(round(estimate, 3), " [", 
                            round(conf.low, 3), ", ", 
                            round(conf.high, 3), "]"),
         `p-value` = round(p.value, 3)) %>%
  dplyr::select(Model, Term, `OR [95% CI]`, `p-value`) %>%
  dplyr::filter(Term != "(Intercept)") %>%
  mutate(ICC = c(round(performance::icc(model_SpW_glmm)$ICC_adjusted[[1]], 3), NA))

# GEE Model
model_SpWR_summary_gee <- summary(model_SpWR_gee) # Save model summary

exp_beta_SpWR_0_gee <- exp(model_SpWR_summary_gee$coefficients[1,1]) # Intercept
exp_beta_SpWR_1_gee <- exp(model_SpWR_summary_gee$coefficients[2,1]) # T_k Coefficient
exp_beta_SpWR_2_gee <- exp(model_SpWR_summary_gee$coefficients[3,1]) # Z1_k Coefficient

tidy_SpWR_gee <- broom::tidy(model_SpWR_gee, conf.int = TRUE, 
                            exponentiate = TRUE) %>%
  dplyr::select(term, estimate, std.error, p.value, conf.low, conf.high) %>%
  mutate(Model = "GEE",
         Term = term,
         `OR [95% CI]` = paste0(round(estimate, 3), " [", 
                            round(conf.low, 3), ", ", 
                            round(conf.high, 3), "]"),
         `p-value` = round(p.value, 3)) %>%
  dplyr::select(Model, Term, `OR [95% CI]`, `p-value`) %>%
  dplyr::filter(Term != "(Intercept)") %>%
  mutate(ICC = c(round(model_SpWR_gee$geese$alpha[[1]], 3), NA))

# Overall Output Table for SpW
SpWR_Model_Table <- rbind(tidy_SpWR, tidy_SpWR_glmm) %>%
  rbind(tidy_SpWR_gee)
```

```{r, results = 'asis', echo = FALSE}
print(xtable(SpWR_Model_Table, 
             caption = "Spillover Not Due to Male Circumcision Model Output"), 
      type = 'latex', include.rownames = FALSE, comment = FALSE)
```

After we hold village circumcision coverage fixed, untreated residence of CP villages will still have a `r (1 - round(exp_beta_SpWR_1, 2))*100`% lower odds of seroconversion than untreated residence of control villages. This is spillover that operates through pathways other than male-circumcision coverage (e.g. HTC uptake, general behavior change, program outreach). 

Then, moving from a 0% to 100% male circumcised coverage in a village multiplies an untreated person's odds of seroconversion by `r round(exp_beta_SpWR_2, 2)`. This means `r (1 - round(exp_beta_SpWR_2, 2))*100`% lower odds of HIV acquisition for an untreated person when their village goes from zero to complete male-circumcision coverage.  

\newpage

### C. Proportion of Within-Intervention Village Spillover Effect Mediated by Circumcision

Then, the proportion of within-intervention village spillover effect mediated by circumcision is

$$\frac{\beta_1^{\text{SpW}} - \beta_1^{\text{SpWR}}}{\beta_1^{\text{SpW}}}$$

Essentially, this is the total spillover minus the spillover that exists except through the circumcision component, divided by spillover total. 

```{r, include = FALSE}
# Proportion of within-intervention village spillover effect mediated by MC
proportion_SpW <- tibble(Model = c("GLM", "GLMM", "GEE"),
                         `Proportion of Spillover Mediated by MC` = c((log(exp_beta_SpW_1) - log(exp_beta_SpWR_1)) / log(exp_beta_SpW_1),
                                                                      (log(exp_beta_SpW_1_glmm) - log(exp_beta_SpWR_1_glmm)) / log(exp_beta_SpW_1_glmm),
                                                                      (log(exp_beta_SpW_1_gee) - log(exp_beta_SpWR_1_gee)) / log(exp_beta_SpW_1_gee)))
```

```{r, results = 'asis', echo = FALSE}
print(xtable(proportion_SpW, 
             caption = "Proportion of Within-Cluster Spillover Due to Male Circumcision"), 
      type = 'latex', include.rownames = FALSE, comment = FALSE)
```

Thus, about `r round((log(exp_beta_SpW_1) - log(exp_beta_SpWR_1)) / log(exp_beta_SpW_1), 2)*100`% of within-village spillover protection experienced by untreated people in CP villages is explained by the higher male-circumcision coverage in those villages. The remaining spillover benefit must come through other village-level channels (e.g. HTC uptake, community health behavior change, program outreach, etc.)

```{r, eval = FALSE, include = FALSE}
# Use delta method to calculate variance and 95% confidence interval

```


\newpage

## Individual Effects

\underline{Setup}

- In this analysis, we include only males in the study.

- Here, we will estimate the effects of the intervention assignment on the outcome. In the mediation model, we will account for if they actually received the circumcision component or not.

- This setup will allow us to estimate

    d. Total Individual Effect of Treatment Assignment
    e. Individual Direct Effects of Treatment Assignment
    f. Indirect Individual Effect of Treatment Assignment
    g. Proportion of Individual Effect of Treatment Assignment Mediated by Circumcision

```{r}
# Alternative to fix data availability
  # Include only those who were circumcised in the treatment
  # Include everyone in the control
modelDat_Ind <- modelDat %>%
  filter(C1_ik == 1)
```

The total sample size for this analysis is `r nrow(modelDat_Ind)`, meaning that `r nrow(modelDat) - nrow(modelDat_Ind)` individuals are excluded.


\underline{Missing Data Imputation}

There are `r nrow(filter(modelDat_Ind, is.na(X1_ik)))` cases where a male has a missing value for his circumcision status ($X^{(1)}_{ik}$). Because this analysis is focused on calculating the mediated effect that circumcision has on HIV incidence, we will use missing data imputation methods for these cases. 

```{r, include = FALSE}
mc_Ind_table <- modelDat_Ind %>%
  dplyr::select(X1_ik, Y_ik) %>%
  mutate(X1_ik = ifelse(is.na(X1_ik), "Missing", X1_ik),
         Y_ik = ifelse(Y_ik == 1, "Yes",
                       ifelse(Y_ik == 0, "No", "Missing"))) %>%
  mutate(Y_ik = paste0("Y_ik = ", Y_ik)) %>%
  mutate(X1_ik = paste0("X1_ik = ", X1_ik)) %>%
  group_by(X1_ik, Y_ik) %>%
  summarize(n = n()) %>%
  ungroup() %>%
  pivot_wider(names_from = Y_ik, values_from = n) %>%
  mutate(across(everything(), ~replace_na(.x, 0))) %>%
  dplyr::select(`X1_ik`, `Y_ik = Yes`, `Y_ik = No`) %>%
  arrange(desc(`X1_ik`))
```

```{r, results = 'asis', echo = FALSE}
print(xtable(mc_Ind_table,
             caption = "Counts of HIV Seroconversion (Y) by Male Circumcision (X1)"), 
      type = 'latex', include.rownames = FALSE, comment = FALSE)
```

```{r, warning = FALSE, eval = FALSE, echo = FALSE}
# THIS APPROACH DOES NOT WORK
# It just predicts everything to be Y_ik = 0 so it does not help with the problem that we have only 9 observations where Y_ik = 1.
# So I had to use Ridge regression to make the imputation model a bit more flexible
# 1. Prepare data --------------------------------------------------------------
modelDat_Ind <- modelDat_Ind %>%
  mutate(X1_ik = ifelse(X1_ik == "Yes", 1, ifelse(X1_ik == "No", 0, NA)))

# Define variables
imp_vars <- c("cluster_id", "Y_ik", "X1_ik", "X2_ik", "T_k", "Z1_k", "Z2_k")

# Separate data into complete cases and missing cases
dat_complete <- filter(modelDat_Ind, !is.na(X1_ik))[, imp_vars]
dat_missing <- filter(modelDat_Ind, is.na(X1_ik))[, imp_vars]

# 2. Fit logistic model for missing variable X1_ik -----------------------------
lower_form <- X1_ik ~ Y_ik * T_k

upper_form <- X1_ik ~ Y_ik + T_k + X2_ik + Z1_k + Z2_k + 
  Y_ik:T_k + Y_ik:X2_ik + Y_ik:Z1_k + Y_ik:Z2_k + 
  T_k:Z1_k + T_k:Z2_k + T_k:X2_ik +
  X2_ik:Z1_k + X2_ik:Z2_k

# Start with the full model
glm_full <- glm(upper_form, data = dat_complete, 
                family = binomial(link = "logit"))

glm_step <- stepAIC(glm_full,
                    scope = list(lower = lower_form, upper = upper_form),
                    direction = "both",
                    k = 4.6,
                    trace = FALSE)

summary(glm_step)

# Function to complete one imputation
impute_once <- function(seed = NULL) {
  if(!is.null(seed)) set.seed(seed)
  p_hat <- predict(glm_step, newdata = dat_missing, type = "response")
  x_imp <- rbinom(length(p_hat), 1, p_hat)
  dat_imp <- modelDat_Ind
  dat_imp$X1_ik[is.na(dat_imp$X1_ik)] <- x_imp
  dat_imp
}

# 3. Generate datasets ---------------------------------------------------------
# Now generate m = 10 completed datasets
m <- 10
imp_list <- lapply(1:m, function(j) impute_once(seed = j))

tally(Y_ik ~ X1_ik, data = imp_list[[1]])
tally(Y_ik ~ X1_ik, data = imp_list[[2]])
tally(Y_ik ~ X1_ik, data = imp_list[[3]])
tally(Y_ik ~ X1_ik, data = imp_list[[4]])
tally(Y_ik ~ X1_ik, data = imp_list[[5]])
tally(Y_ik ~ X1_ik, data = imp_list[[6]])
tally(Y_ik ~ X1_ik, data = imp_list[[7]])
tally(Y_ik ~ X1_ik, data = imp_list[[8]])
tally(Y_ik ~ X1_ik, data = imp_list[[9]])
tally(Y_ik ~ X1_ik, data = imp_list[[10]])
```

```{r warning = FALSE}
# --------------------------------------------------------------------------
# impute_once_ridge()
# --------------------------------------------------------------------------
# Generates ONE completed data set by imputing missing X1_ik values.
# Workflow:
#     1)  complete‑case logistic with stepwise (alpha = 0.10) to pick predictors
#     2)  ridge‑penalised logistic on those predictors
#     3)  predict Pr(X1_ik = 1) for missing rows
#     4)  Bernoulli draw -> insert into a copy of the original data
#
# Arguments you might tweak:
#   seed          : reproducibility seed; NULL = no set.seed().
#   data          : data frame containing X1_ik and all predictors.
#   bootstrap     : TRUE = refit ridge on a bootstrap sample each call
#                   FALSE = use all complete rows (less between‑imp variation).
#   lambda_sel    : "lambda.1se" or "lambda.min" (from cv.glmnet()).
#   lambda_factor : MULTIPLIER on the chosen lambda.
#                   • 1   = default ridge strength (baseline).
#                   • >1  = STRONGER penalty → coefficients shrink more →
#                           lower predicted p when Y=1 →
#                           MORE chance you’ll impute X1_ik = 0
#                           (values 2–5 usually give the needed flexibility).
#                   • <1  = weaker penalty (approaches separation; rarely useful).
#
# --------------------------------------------------------------------------
impute_once_ridge <- function(seed       = NULL,
                              myData,
                              #dat_missing,
                              #dat_complete,
                              bootstrap  = TRUE,
                              lambda_sel = c("lambda.1se", "lambda.min"),
                              lambda_factor = 1,
                              verbose    = FALSE) {

  dat_missing <<- dplyr::filter(myData, is.na(X1_ik))
  dat_complete <<- dplyr::filter(myData, !is.na(X1_ik))
  
  if (!is.null(seed)) set.seed(seed)
  lambda_sel <- match.arg(lambda_sel)

  ## --- 0. split ---------------------------------------------------
  idx_miss     <- which(is.na(myData$X1_ik))
  if (length(idx_miss) == 0) {stop("No missing X1_ik values left!")}

  ## --- 1. stepwise -----------------------------------------------
  step_model <- suppressWarnings(
    stepAIC(glm(upper_form, family = binomial, data = dat_complete),
            scope = list(lower = lower_form, upper = upper_form),
            k = 4.6, trace = FALSE)
  )
  form_sel <- formula(step_model)

  # --- 2. design for complete rows -------------------------------
  X_full <- model.matrix(form_sel, dat_complete)   # include intercept
  y_full <- dat_complete$X1_ik

  ## --- 3. bootstrap sample ---------------------------------------
  if (bootstrap) {
    idx_b   <- sample(seq_len(nrow(dat_complete)), replace = TRUE)
    X_train <- X_full[idx_b, , drop = FALSE]
    y_train <- y_full[idx_b]
  } else {
    X_train <- X_full
    y_train <- y_full
  }
  #
  ## --- 4. ridge fit ----------------------------------------------
  cv_fit <- glmnet::cv.glmnet(X_train, y_train,
                              family = "binomial",
                              alpha  = 0,          # ridge
                              nfolds = 10,
                              type.measure = "deviance")
  
  ## pick lambda and allow user multiplier
  lambda_pick <- cv_fit[[lambda_sel]] * lambda_factor
  
  ## --- 5. model matrix for missing rows --------------------------
  terms_mis <- delete.response(stats::terms(step_model))
  attr(terms_mis, "na.action") <- NULL            # keep rows!
  X_mis <- model.matrix(terms_mis, dat_missing)
  
  need <- setdiff(colnames(X_train), colnames(X_mis))
  if (length(need) > 0) {
    X_mis <- cbind(
      X_mis,
      matrix(0, nrow = nrow(X_mis), ncol = length(need),
             dimnames = list(NULL, need))
    )
  }
  X_mis <- X_mis[ , colnames(X_train), drop = FALSE]
  
  if (verbose) {
    message("[INFO] rows in X_mis: ", nrow(X_mis),
            " | cols: ", ncol(X_mis),
            " | lambda used: ", signif(lambda_pick, 4))
  }
  
  ## --- 6. predicted probabilities -------------------------------
  p_hat <- drop(predict(cv_fit,                 # <- generic predict()
                      newx = X_mis,
                      s    = lambda_pick,
                      type = "response"))
  
  ## --- 7. Bernoulli draw & insert -------------------------------
  x_imp <- rbinom(length(p_hat), 1, p_hat)
  data_out <- myData
  data_out$X1_ik[idx_miss] <- x_imp
  return(data_out)
}
```


```{r}
# Model forms, least variables and most variables
lower_form <- X1_ik ~ Y_ik * T_k
upper_form <- X1_ik ~ Y_ik + T_k + X2_ik + Z1_k + Z2_k + 
  Y_ik:T_k + Y_ik:X2_ik + Y_ik:Z1_k + Y_ik:Z2_k + 
  T_k:Z1_k + T_k:Z2_k + T_k:X2_ik +
  X2_ik:Z1_k + X2_ik:Z2_k

# Variables needed in the imputation dataset
imp_vars <- c("cluster_id", "Y_ik", "X1_ik", "X2_ik", "T_k", "Z1_k", "Z2_k")

# Dataset to use
modelDat_Ind_impute <- modelDat_Ind[, imp_vars] %>%
  mutate(X1_ik = ifelse(X1_ik == "Yes", 1, ifelse(X1_ik == "No", 0, NA)))

#modelDat_Ind_missing <- filter(modelDat_Ind_impute, is.na(X1_ik))
#modelDat_Ind_complete <- filter(modelDat_Ind_impute, !is.na(X1_ik))

# Create 10 imputed datasets
imp_list <- lapply(1:10, function(j)
  impute_once_ridge(seed = 700 + j,
                    myData = modelDat_Ind_impute,
                    #dat_missing = modelDat_Ind_missing,
                    #dat_complete = modelDat_Ind_complete,
                    bootstrap = TRUE,
                    lambda_sel = "lambda.1se",
                    lambda_factor = 3))   # try 2–5 for more rare cases

# Ridge Regression Imputation Summary (10 datasets)
imp_data <- data.table::rbindlist(imp_list, idcol = "m") %>%
  mutate(X1_ik = ifelse(X1_ik == 1, "Yes", ifelse(X1_ik == 0, "No", NA)),
         Y_ik = ifelse(Y_ik == 1, "Yes", ifelse(Y_ik == 0, "No", NA))) %>%
  dplyr::select(m, X1_ik, Y_ik) %>%
  mutate(Y_ik = paste0("Y_ik = ", Y_ik)) %>%
  mutate(X1_ik = paste0("X1_ik = ", X1_ik)) %>%
  group_by(m, X1_ik, Y_ik) %>%
  summarize(n = n()) %>%
  ungroup() %>%
  pivot_wider(names_from = Y_ik, values_from = n) %>%
  dplyr::select(m, `X1_ik`, `Y_ik = Yes`, `Y_ik = No`) %>%
  arrange(m, desc(`X1_ik`)) %>%
  mutate_if(is.numeric, ~replace_na(., 0))
```

```{r, results = 'asis', echo = FALSE}
print(xtable(imp_data,
             caption = "Counts of HIV Seroconversion (Y) by Male Circumcision (X1) for 10 Imputed Datasets"), 
      type = 'latex', include.rownames = FALSE, comment = FALSE)
```

\underline{Data Characteristics}

```{r, include = FALSE}
var_order_Ind <- c("Gender", "HIV Status at Start", "Treatment Component: MC",
                    "Treatment Component: HTC", "Treatment Component: Full",
                    "Outcome: HIV Seroconversion (3-year period)")
level_order_Ind <- c("Male", "Yes", "No", "Began study circumcised", "Female",
                      "HIV-uninfected", "HIV-infected", "Refused HIV testing",
                      "Began study HIV-infected")

baseline_Ind <- modelDat_Ind %>%
  dplyr::select(`Treatment Group` = random_arm,
                `Cluster Size` = cluster_size,
                `Gender` = gender,
                `HIV Status at Start` = hiv_status_current,
                `Treatment Component: MC` = endpoint_coverage_mc,
                `Treatment Component: HTC` = endpoint_coverage_htc,
                `Treatment Component: Full` = endpoint_coverage_full,
                `Outcome: HIV Seroconversion (3-year period)` = endpoint_seroconvert) %>%
  mutate(across(
    where(~ !is.numeric(.x)),
    ~ ifelse(is.na(.x), "Missing", as.character(.x))
  ))

baseline_missing_Ind <- baseline_Ind %>%
  dplyr::select(-`Cluster Size`) %>%
  filter(if_any(everything(), ~ .x == "Missing")) %>%
  mutate(across(
    .cols = -c(`Treatment Group`),  # replace col1 and col2 with your actual column names
    .fns = ~ if_else(.x == "Missing", 1, 0)
  )) %>%
  group_by(`Treatment Group`) %>%
  summarise(across(
    everything(),  # No need to exclude the grouping var here
    sum,
    .names = "{.col}"
  )) %>%
  dplyr::select(-Gender) %>%
  ungroup() %>%
  pivot_longer(
    cols = -`Treatment Group`,  # gather all variables except the group
    names_to = "Variable",
    values_to = "Missing"
  ) %>%
  pivot_wider(
    names_from = `Treatment Group`,
    values_from = Missing
  ) %>%
  mutate(Overall = Control + Treatment) %>%
  rename(`Missing (Control)` = Control,
         `Missing (Treatment)` = Treatment,
         `Missing (Overall)` = Overall)

cluster_size_Ind <- tibble(Variable = c("Number of Individuals", 
                                    "Number of Clusters", 
                                    "Mean Cluster Size"),
                       Level = c(NA, NA, NA),
                       Control = c(nrow(dplyr::filter(modelDat_Ind, random_arm == "Control")),
                                   length(unique(dplyr::filter(modelDat_Ind, random_arm == "Control")$cluster_id)),
                                   mean(filter(modelDat_Ind, random_arm == "Control")$cluster_size)),
                       Treatment = c(nrow(dplyr::filter(modelDat_Ind, random_arm == "Treatment")),
                                     length(unique(dplyr::filter(modelDat_Ind, random_arm == "Treatment")$cluster_id)),
                                     mean(filter(modelDat_Ind, random_arm == "Treatment")$cluster_size))) %>%
  mutate(Control = as.integer(Control), Treatment = as.integer(Treatment)) %>%
  mutate(Overall = ifelse(Variable != "Mean Cluster Size", Treatment + Control, round((Treatment + Control) / 2, 1)))

baseline_tab_Ind <- baseline_Ind %>%
  dplyr::select(-`Cluster Size`) %>%
  pivot_longer(!`Treatment Group`, 
               names_to = "Variable", values_to = "Level") %>%
  arrange(`Treatment Group`, Variable, Level) %>%
  group_by(`Treatment Group`, Variable, Level) %>%
  summarize(n = n()) %>%
  ungroup() %>%
  filter(Level != "Missing") %>%
  group_by(`Treatment Group`, `Variable`) %>%
  mutate(Overall = sum(n)) %>%
  ungroup() %>%
  rowwise() %>%
  mutate(percentage = paste0("(", round(n/Overall, 2)*100, "%)")) %>%
  mutate(n = paste(n, percentage)) %>%
  dplyr::select(-Overall, -percentage) %>%
  pivot_wider(
    names_from = `Treatment Group`,
    values_from = n
  ) %>%
  mutate(
    Overall = parse_number(Control) + parse_number(Treatment)
  ) %>%
  group_by(Variable) %>%
  mutate(Sum = sum(Overall)) %>%
  mutate(Overall = paste0(Overall, " (", round(Overall/Sum, 2)*100, "%)")) %>%
  dplyr::select(-Sum) %>%
  mutate(Variable = factor(Variable, levels = var_order_full),
         Level = factor(Level, levels = level_order_full)) %>%
  arrange(Variable, Level)

n_treat_Ind <- nrow(filter(modelDat_Ind, random_arm == "Treatment"))
n_control_Ind <- nrow(filter(modelDat_Ind, random_arm == "Control"))
n_overall_Ind <- nrow(modelDat_Ind)

final_baseline_Ind_table <- rbind(cluster_size_Ind, baseline_tab_Ind) %>%
  left_join(baseline_missing_Ind, by = "Variable") %>%
  group_by(Variable) %>%
  mutate(
    Variable = if_else(row_number() == 1, Variable, NA_character_),
    `Missing (Control)` = if_else(row_number() == 1, `Missing (Control)`, NA_integer_),
    `Missing (Treatment)` = if_else(row_number() == 1, `Missing (Treatment)`, NA_integer_),
    `Missing (Overall)` = if_else(row_number() == 1, `Missing (Overall)`, NA_integer_)
  ) %>%
  ungroup() %>%
  mutate(`Missing (Control)` = as.integer(`Missing (Control)`),
         `Missing (Treatment)` = as.integer(`Missing (Treatment)`),
         `Missing (Overall)` = as.integer(`Missing (Overall)`)) %>%
  rowwise() %>%
  mutate(`Missing (Control)` = ifelse(!is.na(`Missing (Control)`), 
                                      paste0(`Missing (Control)`, " (", 
                                             round(`Missing (Control)`/n_control_full, 2)*100, "%)"), NA),
         `Missing (Treatment)` = ifelse(!is.na(`Missing (Treatment)`), 
                                        paste0(`Missing (Treatment)`, " (", 
                                               round(`Missing (Treatment)`/n_treat_full, 2)*100, "%)"), NA),
         `Missing (Overall)` = ifelse(!is.na(`Missing (Overall)`), 
                                      paste0(`Missing (Overall)`, " (", 
                                             round(`Missing (Overall)`/n_overall_full, 2)*100, "%)"), NA)) %>%
  mutate(`Missing (Control)` = ifelse(`Missing (Control)` == "0 (0%)", 
                                      NA, `Missing (Control)`),
         `Missing (Treatment)` = ifelse(`Missing (Treatment)` == "0 (0%)", 
                                      NA, `Missing (Treatment)`),
         `Missing (Overall)` = ifelse(`Missing (Overall)` == "0 (0%)", 
                                      NA, `Missing (Overall)`))

```

```{r, results = 'asis', echo = FALSE}
cat("\\begin{landscape}\n")

print(
  xtable(
    final_baseline_Ind_table,
    caption = "Characteristics of Individual Effects Analysis Data",
  ),
  type = "latex",
  include.rownames = FALSE,
  comment = FALSE
)

cat("\\end{landscape}\n")
```

\newpage

### D. Mediator Model for Individual Effect of Treatment Assignment

"IndM" denotes individual effects, i.e. effects of a male's own treatment assignment on their own outcome. Here, we use the product method to calculate the direct and indirect effects, with the outcome being $Y_{ik}$, treatment being $T_k$, and mediator being $X_{ik}^{(1)}$, whether or not a male was circumcised.. 

The mediator model regresses the mediator on the exposure and confounders. Here, we block the spillover that exists through the proportion circumcised and proportion who received HTC in the cluster by controlling for it in the model (inclusion of $Z_k^{(1)}$ and $Z_k^{(2)}$ in the model). The abbreviation "IndM" refers to the individual effect mediator model, shown below.

$$logit(X_{ik}^{(1)}) = \beta_0^{\text{IndM}} + \beta_1^{\text{IndM}}(T_{k}) + \beta_2^{\text{IndM}}(Z_k^{(1)}) + \beta_3^{\text{IndM}}(Z_k^{(2)})$$

```{r, message = FALSE}
# Mediator Model for Individual Effect of Treatment Assignment

# Model not accounting for clustering

fits_IndM <- lapply(imp_list, function(d)
  glm(X1_ik ~ T_k + Z1_k + Z2_k,
                  family = binomial(link = 'logit'),
                  data = d))
# model_IndM <- glm(X1_ik ~ T_k + Z1_k + Z2_k,
#                   family = binomial(link = 'logit'),
#                   data = modelDat_Ind)

# Model accounting for clustering using GLMM
fits_IndM_glmm <- lapply(imp_list, function(d)
  glmer(X1_ik ~ T_k + Z1_k + Z2_k + (1|cluster_id), # Uses exchangeable
                         data = d, 
                         family = binomial(link = "logit")))
# model_IndM_glmm <- glmer(X1_ik ~ T_k + Z1_k + Z2_k + (1|cluster_id), # Uses exchangeable
#                          data = modelDat_Ind, 
#                          family = binomial(link = "logit"))

# Model accounting for clustering using GEE
fits_IndM_gee <- lapply(imp_list, function(d)
  geeglm(X1_ik ~ T_k + Z1_k + Z2_k,
                         family = binomial(link = "logit"),
                         id = cluster_id,
                         data = d,
                         corstr = "exchangeable"))
# model_IndM_gee <- geeglm(X1_ik ~ T_k + Z1_k + Z2_k,
#                          family = binomial(link = "logit"),
#                          id = cluster_id,
#                          data = modelDat_Ind,
#                          corstr = "exchangeable") # working correlation
```


```{r}
# Pool the estimates by Rubin's rule
pool_rubins <- function(fit_list,
                        coef_fun = coef,          # how to grab betas
                        vcov_fun = vcov,          # how to grab Var(betas)
                        conf.level = 0.95) {
  m <- length(fit_list)
  if (m < 2) stop("Need at least 2 imputations to pool.")

  # 1. Stack coefficient vectors (m × p)
  beta_mat <- do.call(rbind, lapply(fit_list, coef_fun))

  # 2. Within‑imputation variances
  U_list   <- lapply(fit_list, vcov_fun)

  # --- Rubin's rules -------------------------------------------------
  Q_bar <- colMeans(beta_mat)                       # pooled beta
  U_bar <- Reduce(`+`, U_list) / m                  # pooled within‑var
  centered <- sweep(beta_mat, 2, Q_bar)             # beta_j - Q
  B      <- t(centered) %*% centered / (m - 1)      # between‑var
  T_mat  <- U_bar + (1 + 1/m) * B                   # total var
  se     <- sqrt(diag(T_mat))

  z  <- Q_bar / se
  p  <- 2 * pnorm(abs(z), lower.tail = FALSE)
  alpha <- 1 - conf.level
  zcrit <- qnorm(1 - alpha/2)
  ci_l  <- Q_bar - zcrit * se
  ci_u  <- Q_bar + zcrit * se

  tibble(Term     = names(Q_bar),
             Estimate = Q_bar,
             SE       = se,
             `z Value`  = z,
             `p Value`  = p,
             `CI Lower`   = ci_l,
             `CI Upper`  = ci_u,
             row.names = NULL)
}

# GLM Results
pooled_results_IndM <- pool_rubins(fits_IndM) %>%
  mutate(Model = "GLM") %>%
  relocate(Model) %>%
  filter(Term != "(Intercept)") %>%
  mutate(`Mean ICC` = c(NA, NA, NA))

# GLMM Results
icc_IndM_glmm <- sapply(fits_IndM_glmm, function(f){
  out <- performance::icc(f, tolerance = 1e-10000)$ICC_adjusted[[1]]
})
icc_IndM_glmm_mean <- mean(icc_IndM_glmm)
icc_IndM_glmm_range <- range(icc_IndM_glmm)
pooled_results_IndM_glmm <- pool_rubins(fits_IndM_glmm, 
                                        coef_fun = lme4::fixef) %>%
  mutate(Model = "GLMM") %>%
  relocate(Model) %>%
  filter(Term != "(Intercept)") %>%
  mutate(`Mean ICC` = c(icc_IndM_glmm_mean, NA, NA))

# GEE Results
alpha_IndM_gee <- sapply(fits_IndM_gee, function(f) f$geese$alpha[[1]])
alpha_mean_IndM_gee <- mean(alpha_IndM_gee)
alpha_range_IndM_gee <- range(alpha_IndM_gee)
pooled_results_IndM_gee <- pool_rubins(fits_IndM_gee,
                                       coef_fun = coef,
                                       vcov_fun = function(x) vcov(x, 
                                                                   type = "robust")) %>%
  mutate(Model = "GEE") %>%
  relocate(Model) %>%
  filter(Term != "(Intercept)") %>%
  mutate(`Mean ICC` = c(alpha_mean_IndM_gee, NA, NA))

# Final Results Table
final_IndM_results_pooled <- rbind(pooled_results_IndM, 
                                   pooled_results_IndM_glmm) %>%
  rbind(pooled_results_IndM_gee) %>%
  mutate(`OR [95% CI]` = paste0(round(exp(Estimate), 3), 
                                " [", round(exp(`CI Lower`), 3), ", ", 
                                round(exp(`CI Upper`), 3), "]")) %>%
  dplyr::select(Model, Term, `OR [95% CI]`, `p-value` = `p Value`, `Mean ICC`, Estimate)
```

```{r echo = FALSE}
# Assign values to variables
exp_beta_IndM_1 <- exp(filter(final_IndM_results_pooled, 
                          Model == "GLM", Term == "T_k")$Estimate[[1]]) # T_k Coefficient
exp_beta_IndM_2 <- exp(filter(final_IndM_results_pooled, 
                          Model == "GLM", Term == "Z1_k")$Estimate[[1]]) # Z1_k Coefficient
exp_beta_IndM_3 <- exp(filter(final_IndM_results_pooled, 
                          Model == "GLM", Term == "Z2_k")$Estimate[[1]]) # Z2_k Coefficient

exp_beta_IndM_1_glmm <- exp(filter(final_IndM_results_pooled, 
                          Model == "GLMM", Term == "T_k")$Estimate[[1]]) # T_k Coefficient
exp_beta_IndM_2_glmm <- exp(filter(final_IndM_results_pooled, 
                          Model == "GLMM", Term == "Z1_k")$Estimate[[1]]) # Z1_k Coefficient
exp_beta_IndM_3_glmm <- exp(filter(final_IndM_results_pooled, 
                          Model == "GLMM", Term == "Z2_k")$Estimate[[1]]) # Z2_k Coefficient

exp_beta_IndM_1_gee <- exp(filter(final_IndM_results_pooled, 
                          Model == "GEE", Term == "T_k")$Estimate[[1]]) # T_k Coefficient
exp_beta_IndM_2_gee <- exp(filter(final_IndM_results_pooled, 
                          Model == "GEE", Term == "Z1_k")$Estimate[[1]]) # Z1_k Coefficient
exp_beta_IndM_3_gee <- exp(filter(final_IndM_results_pooled, 
                          Model == "GEE", Term == "Z2_k")$Estimate[[1]]) # Z2_k Coefficient
```

```{r, results = 'asis', echo = FALSE}
print(xtable(dplyr::select(final_IndM_results_pooled, -Estimate), 
             caption = "Mediator Models for Individual Effect of Treatment Assignment"), 
      type = 'latex', include.rownames = FALSE, comment = FALSE)
```



```{r, echo = FALSE, eval = FALSE}
# GlM Model
model_IndM_summary <- summary(model_IndM) # Save model summary

exp_beta_IndM_0 <- exp(model_IndM_summary$coefficients[1,1]) # Intercept
exp_beta_IndM_1 <- exp(model_IndM_summary$coefficients[2,1]) # T_k Coefficient
exp_beta_IndM_2 <- exp(model_IndM_summary$coefficients[3,1]) # Z1_k Coefficient
exp_beta_IndM_3 <- exp(model_IndM_summary$coefficients[4,1]) # Z2_k Coefficient

tidy_IndM <- broom::tidy(model_IndM, conf.int = TRUE, exponentiate = TRUE) %>%
  dplyr::select(term, estimate, std.error, p.value, conf.low, conf.high) %>%
  mutate(Model = "GLM",
         Term = term,
         `OR [95% CI]` = paste0(round(estimate, 3), " [", 
                            round(conf.low, 3), ", ", 
                            round(conf.high, 3), "]"),
         `p-value` = round(p.value, 3)) %>%
  dplyr::select(Model, Term, `OR [95% CI]`, `p-value`) %>%
  dplyr::filter(Term != "(Intercept)") %>%
  mutate(ICC = NA)

# GLMM Model
model_IndM_summary_glmm <- summary(model_IndM_glmm) # Save model summary
exp_beta_IndM_0_glmm <- exp(model_IndM_summary_glmm$coefficients[1,1]) # Intercept
exp_beta_IndM_1_glmm <- exp(model_IndM_summary_glmm$coefficients[2,1]) # T_k Coefficient
exp_beta_IndM_2_glmm <- exp(model_IndM_summary_glmm$coefficients[3,1]) # Z1_k Coefficient
exp_beta_IndM_3_glmm <- exp(model_IndM_summary_glmm$coefficients[4,1]) # Z2_k Coefficient

tidy_IndM_glmm <- broom.mixed::tidy(model_IndM_glmm, effects = "fixed", 
                  conf.int = TRUE, exponentiate = TRUE) %>%
  dplyr::select(term, estimate, std.error, p.value, conf.low, conf.high) %>%
  mutate(Model = "GLMM",
         Term = term,
         `OR [95% CI]` = paste0(round(estimate, 3), " [", 
                            round(conf.low, 3), ", ", 
                            round(conf.high, 3), "]"),
         `p-value` = round(p.value, 3)) %>%
  dplyr::select(Model, Term, `OR [95% CI]`, `p-value`) %>%
  dplyr::filter(Term != "(Intercept)") %>%
  mutate(ICC = c(round(performance::icc(model_IndM_glmm, tolerance = 1e-100)$ICC_adjusted[[1]], 3), NA, NA))

# GEE Model
model_IndM_summary_gee <- summary(model_IndM_gee) # Save model summary

exp_beta_IndM_0_gee <- exp(model_IndM_summary_gee$coefficients[1,1]) # Intercept
exp_beta_IndM_1_gee <- exp(model_IndM_summary_gee$coefficients[2,1]) # T_k Coefficient
exp_beta_IndM_2_gee <- exp(model_IndM_summary_gee$coefficients[3,1]) # Z1_k Coefficient
exp_beta_IndM_3_gee <- exp(model_IndM_summary_gee$coefficients[4,1]) # Z2_k Coefficient

tidy_IndM_gee <- broom::tidy(model_IndM_gee, conf.int = TRUE, 
                             exponentiate = TRUE) %>%
  dplyr::select(term, estimate, std.error, p.value, conf.low, conf.high) %>%
  mutate(Model = "GEE",
         Term = term,
         `OR [95% CI]` = paste0(round(estimate, 3), " [", 
                            round(conf.low, 3), ", ", 
                            round(conf.high, 3), "]"),
         `p-value` = round(p.value, 3)) %>%
  dplyr::select(Model, Term, `OR [95% CI]`, `p-value`) %>%
  dplyr::filter(Term != "(Intercept)") %>%
  mutate(ICC = c(round(model_IndM_gee$geese$alpha[[1]], 3), NA, NA))

# Overall Output Table for IndM
IndM_Model_Table <- rbind(tidy_IndM, tidy_IndM_glmm) %>%
  rbind(tidy_IndM_gee)
```

```{r, results = 'asis', echo = FALSE, eval = FALSE}
print(xtable(IndM_Model_Table, 
             caption = "Mediator Model for Individual Effect of Treatment Assignment"), 
      type = 'latex', include.rownames = FALSE, comment = FALSE)
```

### E. Outcome Model for Individual Effect of Treatment Assignment

Now, we regress the outcome, $Y_{ik}$ on the treatment assignment $T_k$ and MC mediator $X_{ik}^{(1)}$. Here, we block the spillover that exists through the proportion circumcised and proportion who received HTC in the cluster by controlling for it in the model (inclusion of $Z_k^{(1)}$ and $Z_k^{(2)}$ in the model). The abbreviation "IndO" refers to the individual effect outcome model, shown below.

$$logit(Y_{ik}) = \beta_0^{\text{IndO}} + \beta_1^{\text{IndO}}(T_{k}) + \beta_2^{\text{IndO}} (X_{ik}^{(1)}) + \beta_3^{\text{IndO}}(Z_k^{(1)}) + \beta_4^{\text{IndO}}(Z_k^{(2)})$$

```{r, warning = FALSE, message = FALSE}
# Outcome Model for Individual Effect of Treatment Assignment

# Model not accounting for clustering
fits_IndO <- lapply(imp_list, function(d)
  glm(Y_ik ~ T_k + X1_ik + Z1_k + Z2_k,
                  family = binomial(link = 'logit'),
                  data = d))
# model_IndO <- glm(Y_ik ~ T_k + X1_ik + Z1_k + Z2_k,
#                   family = binomial(link = 'logit'),
#                   data = modelDat_Ind)

# Model accounting for clustering using GLMM
fits_IndO_glmm <- lapply(imp_list, function(d)
  glmer(Y_ik ~ T_k + X1_ik + Z1_k + Z2_k + (1|cluster_id), # Uses exchangeable
                         data = d, 
                         family = binomial(link = "logit")))
# model_IndO_glmm <- glmer(Y_ik ~ T_k + X1_ik + Z1_k + Z2_k + (1|cluster_id), # Uses exchangeable
#                          data = modelDat_Ind, 
#                          family = binomial(link = "logit"))

# Model accounting for clustering using GEE
fits_IndO_gee <- lapply(imp_list, function(d)
  geeglm(Y_ik ~ T_k + X1_ik + Z1_k + Z2_k,
                         family = binomial(link = "logit"),
                         id = cluster_id,
                         data = d,
                         corstr = "exchangeable"))
# model_IndO_gee <- geeglm(Y_ik ~ T_k + X1_ik + Z1_k + Z2_k,
#                          family = binomial(link = "logit"),
#                          id = cluster_id,
#                          data = dplyr::select(modelDat_Ind, cluster_id, Y_ik, 
#                                               T_k, X1_ik, Z1_k, Z2_k) %>% drop_na(),
#                          corstr = "exchangeable") # working correlation
```

```{r}
# GLM Results
pooled_results_IndO <- pool_rubins(fits_IndO) %>%
  mutate(Model = "GLM") %>%
  relocate(Model) %>%
  filter(Term != "(Intercept)") %>%
  mutate(`Mean ICC` = c(NA, NA, NA, NA))

# GLMM Results
icc_IndO_glmm <- sapply(fits_IndO_glmm, function(f){
  out <- performance::icc(f, tolerance = 1e-10000)$ICC_adjusted[[1]]
})
icc_IndO_glmm_mean <- mean(icc_IndO_glmm)
icc_IndO_glmm_range <- range(icc_IndO_glmm)
pooled_results_IndO_glmm <- pool_rubins(fits_IndO_glmm, 
                                        coef_fun = lme4::fixef) %>%
  mutate(Model = "GLMM") %>%
  relocate(Model) %>%
  filter(Term != "(Intercept)") %>%
  mutate(`Mean ICC` = c(icc_IndO_glmm_mean, NA, NA, NA))

# GEE Results
alpha_IndO_gee <- sapply(fits_IndO_gee, function(f) f$geese$alpha[[1]])
alpha_mean_IndO_gee <- mean(alpha_IndO_gee)
alpha_range_IndO_gee <- range(alpha_IndO_gee)
pooled_results_IndO_gee <- pool_rubins(fits_IndO_gee,
                                       coef_fun = coef,
                                       vcov_fun = function(x) vcov(x, 
                                                                   type = "robust")) %>%
  mutate(Model = "GEE") %>%
  relocate(Model) %>%
  filter(Term != "(Intercept)") %>%
  mutate(`Mean ICC` = c(alpha_mean_IndO_gee, NA, NA, NA))

# Final Results Table
final_IndO_results_pooled <- rbind(pooled_results_IndO, 
                                   pooled_results_IndO_glmm) %>%
  rbind(pooled_results_IndO_gee) %>%
  mutate(`OR [95% CI]` = paste0(round(exp(Estimate), 3), 
                                " [", round(exp(`CI Lower`), 3), ", ", 
                                round(exp(`CI Upper`), 3), "]")) %>%
  dplyr::select(Model, Term, `OR [95% CI]`, `p-value` = `p Value`, `Mean ICC`, Estimate)
```

```{r echo = FALSE}
# Assign values to variables
exp_beta_IndO_1 <- exp(filter(final_IndO_results_pooled, 
                          Model == "GLM", Term == "T_k")$Estimate[[1]]) # T_k Coefficient
exp_beta_IndO_2 <- exp(filter(final_IndO_results_pooled, 
                          Model == "GLM", Term == "X1_ik")$Estimate[[1]]) # X1_ik Coefficient
exp_beta_IndO_3 <- exp(filter(final_IndO_results_pooled, 
                          Model == "GLM", Term == "Z1_k")$Estimate[[1]]) # Z1_k Coefficient
exp_beta_IndO_4 <- exp(filter(final_IndO_results_pooled, 
                          Model == "GLM", Term == "Z2_k")$Estimate[[1]]) # Z2_k Coefficient

exp_beta_IndO_1_glmm <- exp(filter(final_IndO_results_pooled, 
                          Model == "GLMM", Term == "T_k")$Estimate[[1]]) # T_k Coefficient
exp_beta_IndO_2_glmm <- exp(filter(final_IndO_results_pooled, 
                          Model == "GLMM", Term == "X1_ik")$Estimate[[1]]) # X1_ik Coefficient
exp_beta_IndO_3_glmm <- exp(filter(final_IndO_results_pooled, 
                          Model == "GLMM", Term == "Z1_k")$Estimate[[1]]) # Z1_k Coefficient
exp_beta_IndO_4_glmm <- exp(filter(final_IndO_results_pooled, 
                          Model == "GLMM", Term == "Z2_k")$Estimate[[1]]) # Z2_k Coefficient

exp_beta_IndO_1_gee <- exp(filter(final_IndO_results_pooled, 
                          Model == "GEE", Term == "T_k")$Estimate[[1]]) # T_k Coefficient
exp_beta_IndO_2_gee <- exp(filter(final_IndO_results_pooled, 
                          Model == "GEE", Term == "X1_ik")$Estimate[[1]]) # X1_ik Coefficient
exp_beta_IndO_3_gee <- exp(filter(final_IndO_results_pooled, 
                          Model == "GEE", Term == "Z1_k")$Estimate[[1]]) # Z1_k Coefficient
exp_beta_IndO_4_gee <- exp(filter(final_IndO_results_pooled, 
                          Model == "GEE", Term == "Z2_k")$Estimate[[1]]) # Z2_k Coefficient
```

```{r, results = 'asis', echo = FALSE}
print(xtable(dplyr::select(final_IndO_results_pooled, -Estimate), 
             caption = "Mediator Models for Individual Effect of Treatment Assignment"), 
      type = 'latex', include.rownames = FALSE, comment = FALSE)
```

```{r, echo = FALSE, warning = FALSE, eval = FALSE}
# GLM Model
model_IndO_summary <- summary(model_IndO) # Save model summary

exp_beta_IndO_0 <- exp(model_IndO_summary$coefficients[1,1]) # Intercept
exp_beta_IndO_1 <- exp(model_IndO_summary$coefficients[2,1]) # T_k Coefficient
exp_beta_IndO_2 <- exp(model_IndO_summary$coefficients[3,1]) # X1_ik Coefficient
exp_beta_IndO_3 <- exp(model_IndO_summary$coefficients[4,1]) # Z1_k Coefficient
exp_beta_IndO_4 <- exp(model_IndO_summary$coefficients[5,1]) # Z2_k Coefficient

tidy_IndO <- broom::tidy(model_IndO, conf.int = TRUE, exponentiate = TRUE) %>%
  dplyr::select(term, estimate, std.error, p.value, conf.low, conf.high) %>%
  mutate(Model = "GLM",
         Term = term,
         `OR [95% CI]` = paste0(round(estimate, 3), " [", 
                            round(conf.low, 3), ", ", 
                            round(conf.high, 3), "]"),
         `p-value` = round(p.value, 3)) %>%
  dplyr::select(Model, Term, `OR [95% CI]`, `p-value`) %>%
  dplyr::filter(Term != "(Intercept)") %>%
  mutate(ICC = NA)

# GLMM Model
model_IndO_summary_glmm <- summary(model_IndO_glmm) # Save model summary
exp_beta_IndO_0_glmm <- exp(model_IndO_summary_glmm$coefficients[1,1]) # Intercept
exp_beta_IndO_1_glmm <- exp(model_IndO_summary_glmm$coefficients[2,1]) # T_k Coefficient
exp_beta_IndO_2_glmm <- exp(model_IndO_summary_glmm$coefficients[3,1]) # X1_ik Coefficient
exp_beta_IndO_3_glmm <- exp(model_IndO_summary_glmm$coefficients[4,1]) # Z1_k Coefficient
exp_beta_IndO_4_glmm <- exp(model_IndO_summary_glmm$coefficients[5,1]) # Z2_k Coefficient

tidy_IndO_glmm <- broom.mixed::tidy(model_IndO_glmm, effects = "fixed", 
                  conf.int = TRUE, exponentiate = TRUE) %>%
  dplyr::select(term, estimate, std.error, p.value, conf.low, conf.high) %>%
  mutate(Model = "GLMM",
         Term = term,
         `OR [95% CI]` = paste0(round(estimate, 3), " [", 
                            round(conf.low, 3), ", ", 
                            round(conf.high, 3), "]"),
         `p-value` = round(p.value, 3)) %>%
  dplyr::select(Model, Term, `OR [95% CI]`, `p-value`) %>%
  dplyr::filter(Term != "(Intercept)") %>%
  mutate(ICC = c(round(performance::icc(model_IndO_glmm, tolerance = 1e-100)$ICC_adjusted[[1]], 3), NA, NA, NA))

# GEE Model
model_IndO_summary_gee <- summary(model_IndO_gee) # Save model summary

exp_beta_IndO_0_gee <- exp(model_IndO_summary_gee$coefficients[1,1]) # Intercept
exp_beta_IndO_1_gee <- exp(model_IndO_summary_gee$coefficients[2,1]) # T_k Coefficient
exp_beta_IndO_2_gee <- exp(model_IndO_summary_gee$coefficients[3,1]) # X1_ik Coefficient
exp_beta_IndO_3_gee <- exp(model_IndO_summary_gee$coefficients[4,1]) # Z1_k Coefficient
exp_beta_IndO_4_gee <- exp(model_IndO_summary_gee$coefficients[5,1]) # Z2_k Coefficient

tidy_IndO_gee <- broom::tidy(model_IndO_gee, conf.int = TRUE, 
                             exponentiate = TRUE) %>%
  dplyr::select(term, estimate, std.error, p.value, conf.low, conf.high) %>%
  mutate(Model = "GEE",
         Term = term,
         `OR [95% CI]` = paste0(round(estimate, 3), " [", 
                            round(conf.low, 3), ", ", 
                            round(conf.high, 3), "]"),
         `p-value` = round(p.value, 3)) %>%
  dplyr::select(Model, Term, `OR [95% CI]`, `p-value`) %>%
  dplyr::filter(Term != "(Intercept)") %>%
  mutate(ICC = c(round(model_IndO_gee$geese$alpha[[1]], 3), NA, NA, NA))

# Overall Output Table for IndM
IndO_Model_Table <- rbind(tidy_IndO, tidy_IndO_glmm) %>%
  rbind(tidy_IndO_gee)
```

```{r, results = 'asis', echo = FALSE, eval = FALSE}
print(xtable(IndO_Model_Table, 
             caption = "Outcome Model for Individual Effect of Treatment Assignment"), 
      type = 'latex', include.rownames = FALSE, comment = FALSE)
```

### F. Direct and Indirect Individual Effects of Treatment Assignment

The direct individual effect of treatment assignment on HIV seroconversion is $\beta_1^{\text{IndO}}$. The indirect individual effect of treatment assignment on HIV seroconversion is $\beta_1^{\text{IndM}} \times \beta_2^{\text{IndO}}$. Then, the total effect is the sum of these, namely $\beta_1^{\text{IndO}} + \beta_1^{\text{IndM}} \times \beta_2^{\text{IndO}}$.

```{r, echo = FALSE}
Ind_DirectIndirect_Table <- tibble(
  Model = c("GLM", "GLMM", "GEE"),
  `Direct Effect` = c(exp_beta_IndO_1,
                      exp_beta_IndO_1_glmm, 
                      exp_beta_IndO_1_gee),
  `Indirect Effect` = c(exp(log(exp_beta_IndM_1)*log(exp_beta_IndO_2)), 
                        exp(log(exp_beta_IndM_1_glmm)*log(exp_beta_IndO_2_glmm)), 
                        exp(log(exp_beta_IndM_1_gee)*log(exp_beta_IndO_2_gee)))) %>%
  mutate(`Total Effect` = c(exp(log(exp_beta_IndO_1) + log(exp_beta_IndM_1)*log(exp_beta_IndO_2)),
                            exp(log(exp_beta_IndO_1_glmm) + log(exp_beta_IndM_1_glmm)*log(exp_beta_IndO_2_glmm)),
                            exp(log(exp_beta_IndO_1_gee) + log(exp_beta_IndM_1_gee)*log(exp_beta_IndO_2_gee))))
```

```{r, results = 'asis', echo = FALSE}
print(xtable(Ind_DirectIndirect_Table, 
             caption = "Direct, Indirect, and Total Individual Effects of Treatment Assignment (Shown as ORs)"), 
      type = 'latex', include.rownames = FALSE, comment = FALSE)
```


### G. Proportion of Individual Effect of Treatment Assignment Mediated by Circumcision

The proportion of the total individual effect that is mediated by circumcision can be calculated as:

$$\frac{\beta_1^{\text{IndM}} \times \beta_2^{\text{IndO}}}{\beta_1^{\text{IndO}} + \beta_1^{\text{IndM}} \times \beta_2^{\text{IndO}}}$$

This is the indirect effect (i.e. effect of treatment assignment through the MC mediator on the outcome) divided by the total effect of the treatment assignment on the outcome (both through and not through the mediator). 

```{r, include = FALSE}
Ind_PropMediated <- tibble(
  Model = c("GLM", "GLMM", "GEE"),
  `Proportion Mediated` = c((log(exp_beta_IndM_1)*log(exp_beta_IndO_2))/(log(exp_beta_IndO_1) + log(exp_beta_IndM_1)*log(exp_beta_IndO_2)),
                            (log(exp_beta_IndM_1_glmm)*log(exp_beta_IndO_2_glmm))/(log(exp_beta_IndO_1_glmm) + log(exp_beta_IndM_1_glmm)*log(exp_beta_IndO_2_glmm)),
                            (log(exp_beta_IndM_1_gee)*log(exp_beta_IndO_2_gee))/(log(exp_beta_IndO_1_gee) + log(exp_beta_IndM_1_gee)*log(exp_beta_IndO_2_gee))))
```

```{r, results = 'asis', echo = FALSE}
print(xtable(Ind_PropMediated, 
             caption = "Proportion of Individual Effect of Treatment Assignment Mediated by Circumcision"), 
      type = 'latex', include.rownames = FALSE, comment = FALSE)
```

The issue with the data still arises when using the product method. When using the product method, we still need to regress $Y_{ik} \sim X^{(1)}_{ik}$. It seems as if we either need to use a penalty model (like Firth's method that I did before) or potentially impute data to account for the fact that 0 participants have $X^{(1)}_{ik} = 0$ and $Y_{ik} = 1$ (see table below).



\newpage

## Overall Effects

### H. Overall Intervention Village Effect

The overall effect of being in an intervention village can be calculated by just fitting the following model on the overall dataset of HIV-negative individuals (at the start of the study, n = `r nrow(modelDat)`), without controlling for any other causal pathways. 

$$logit(Y_{ik}) = \beta_0^{\text{Overall}} + \beta_1^{\text{Overall}}(T_{k})$$

```{r}
# Overall Effects of T_k on Y_ik

# Model not accounting for clustering
model_overall <- glm(Y_ik ~ T_k,
                     family = binomial(link = 'logit'),
                     data = modelDat) # Everyone

# Model accounting for clustering using GLMM
model_overall_glmm <- glmer(Y_ik ~ T_k + (1|cluster_id),# Uses exchangeable
                            data = modelDat_Ind,
                            family = binomial(link = "logit"))

# Model accounting for clustering using GEE
model_overall_gee <- geeglm(Y_ik ~ T_k,
                            family = binomial(link = "logit"),
                            id = cluster_id,
                            data = modelDat_Ind,
                            corstr = "exchangeable") # working correlation
```

```{r, echo = FALSE}
# GlM Model
model_overall_summary <- summary(model_overall) # Save model summary

exp_beta_overall_0 <- exp(model_overall_summary$coefficients[1,1]) # Intercept
exp_beta_overall_1 <- exp(model_overall_summary$coefficients[2,1]) # T_k Coefficient

tidy_overall <- broom::tidy(model_overall, conf.int = TRUE, exponentiate = TRUE) %>%
  dplyr::select(term, estimate, std.error, p.value, conf.low, conf.high) %>%
  mutate(Model = "GLM",
         Term = term,
         `OR [95% CI]` = paste0(round(estimate, 3), " [", 
                            round(conf.low, 3), ", ", 
                            round(conf.high, 3), "]"),
         `p-value` = round(p.value, 3)) %>%
  dplyr::select(Model, Term, `OR [95% CI]`, `p-value`) %>%
  dplyr::filter(Term != "(Intercept)") %>%
  mutate(ICC = NA)

# GLMM Model
model_overall_summary_glmm <- summary(model_overall_glmm) # Save model summary

exp_beta_overall_0_glmm <- exp(model_overall_summary_glmm$coefficients[1,1]) # Intercept
exp_beta_overall_1_glmm <- exp(model_overall_summary_glmm$coefficients[2,1]) # T_k Coefficient

tidy_overall_glmm <- broom.mixed::tidy(model_overall_glmm, effects = "fixed", 
                  conf.int = TRUE, exponentiate = TRUE) %>%
  dplyr::select(term, estimate, std.error, p.value, conf.low, conf.high) %>%
  mutate(Model = "GLMM",
         Term = term,
         `OR [95% CI]` = paste0(round(estimate, 3), " [", 
                            round(conf.low, 3), ", ", 
                            round(conf.high, 3), "]"),
         `p-value` = round(p.value, 3)) %>%
  dplyr::select(Model, Term, `OR [95% CI]`, `p-value`) %>%
  dplyr::filter(Term != "(Intercept)") %>%
  mutate(ICC = c(round(performance::icc(model_overall_glmm)$ICC_adjusted[[1]], 3)))

# GEE Model
model_overall_summary_gee <- summary(model_overall_gee) # Save model summary

exp_beta_overall_0_gee <- exp(model_overall_summary_gee$coefficients[1,1]) # Intercept
exp_beta_overall_1_gee <- exp(model_overall_summary_gee$coefficients[2,1]) # T_k Coefficient

tidy_overall_gee <- broom::tidy(model_overall_gee, conf.int = TRUE, 
                            exponentiate = TRUE) %>%
  dplyr::select(term, estimate, std.error, p.value, conf.low, conf.high) %>%
  mutate(Model = "GEE",
         Term = term,
         `OR [95% CI]` = paste0(round(estimate, 3), " [", 
                            round(conf.low, 3), ", ", 
                            round(conf.high, 3), "]"),
         `p-value` = round(p.value, 3)) %>%
  dplyr::select(Model, Term, `OR [95% CI]`, `p-value`) %>%
  dplyr::filter(Term != "(Intercept)") %>%
  mutate(ICC = c(round(model_overall_gee$geese$alpha[[1]], 3)))

# Overall Output Table for SpW
overall_Model_Table <- rbind(tidy_overall, tidy_overall_glmm) %>%
  rbind(tidy_overall_gee)
```

```{r, results = 'asis', echo = FALSE}
print(xtable(overall_Model_Table, 
             caption = "Overall Effect of Treatment Assignment on HIV Model Output"), 
      type = 'latex', include.rownames = FALSE, comment = FALSE)
```

Thus, the OR is `r round(exp_beta_overall_1, 2)`, meaning that for HIV-negative individuals at baseline, living in an intervention village is associated with a `r (1 - round(exp_beta_overall_1, 2))*100`% reduction in the odds of seroconversion during follow-up compared with living in a control village. This single odds ratio blends every causal pathway, thus resulting in an overall effect. It is the total impact of the intervention environment on an average resident. 

#### I. Proportion of total effect mediated by male circumcision

The proportion of total effect mediated by male circumcision is

(Total Individual - Direct Individual) + (Total Spillover - Spillover Not Mediated by MC)
/ 
Overall 
(Or Total Individual + Total Spillover)

$$\frac{[(\beta_1^{\text{IndM}}\times \beta_2^{\text{IndO}}) + (\beta_1^{\text{SpW}} - \beta_1^{\text{SpWR}})]}{(\beta_1^{\text{Overall}})}$$

```{r, include = FALSE}
Ind_PropMediated <- tibble(
  Model = c("GLM", "GLMM", "GEE"),
  `Proportion of Overall Effect Mediated by Circumcision` = 
    c(((log(exp_beta_IndM_1)*log(exp_beta_IndO_2)) + (log(exp_beta_SpW_1) - log(exp_beta_SpWR_1)))/(log(exp_beta_overall_1)),
      ((log(exp_beta_IndM_1_glmm)*log(exp_beta_IndO_2_glmm)) + (log(exp_beta_SpW_1_glmm) - log(exp_beta_SpWR_1_glmm)))/(log(exp_beta_overall_1_glmm)),
      ((log(exp_beta_IndM_1_gee)*log(exp_beta_IndO_2_gee)) + (log(exp_beta_SpW_1_gee) - log(exp_beta_SpWR_1_gee)))/(log(exp_beta_overall_1_gee))))
```

```{r, results = 'asis', echo = FALSE}
print(xtable(Ind_PropMediated, 
             caption = "Proportion of Overall Effect of Treatment Assignment Mediated by Circumcision"), 
      type = 'latex', include.rownames = FALSE, comment = FALSE)
```


```{r include = FALSE}
# Proportion of total effect mediated by male circumcision
#((beta_Ind_1 - beta_IndM_1) + (beta_SpW_1 - beta_SpWM_1))/(beta_Ind_1 + beta_SpW_1) 
# Proportion of total effect mediated by male circumcision firth model
# ((log(exp_beta_Ind_1) - log(exp_beta_IndD_1_firth)) + (log(exp_beta_SpW_1) - log(exp_beta_SpWR_1)))/(log(exp_beta_Ind_1) + log(exp_beta_SpW_1))
# 
# exp(((log(exp_beta_Ind_1) - log(exp_beta_IndD_1_firth)) + (log(exp_beta_SpW_1) - log(exp_beta_SpWR_1)))/(log(exp_beta_Ind_1) + log(exp_beta_SpW_1)))
```

```{r include = FALSE}
# ((log(exp_beta_Ind_1) - log(exp_beta_IndD_1_firth)) + (log(exp_beta_SpW_1) - log(exp_beta_SpWR_1)))/(log(exp_beta_overall_1))
# 
# exp(((log(exp_beta_Ind_1) - log(exp_beta_IndD_1_firth)) + (log(exp_beta_SpW_1) - log(exp_beta_SpWR_1)))/(log(exp_beta_overall_1)))
```




```{r include = FALSE, eval = FALSE}
### J. Proportion of intervention village total effect due to spillover within intervention villages

#The proportion of intervention village total effect due to spillover within intervention villages is 

#$$\frac{\beta_1^{\text{SpW}}}{(\beta_1^{\text{Ind}} + \beta_1^{\text{SpW}})}$$
# Proportion of intervention village total effect due to spillover within intervention villages
#log(exp_beta_SpW_1)/(log(exp_beta_Ind_1) + log(exp_beta_SpW_1))
#log(exp_beta_SpW_1)/(log(exp_beta_overall_1))
```

\newpage



```{r, include = FALSE, eval = FALSE}
SummaryTable <- tibble(
  `Model/Estimand Name` = c("SpW - total spillover within intervention clusters", 
                   "SpWR - remaining spillover when meidated spillover path through MC is blocked", 
                   "Proportion of Within-Intervention Village SPillover Effect Mediated by Circumcision", 
                   "Ind - total individual effect of male's own treatment on own outcome",
                   "IndD - individual direct effect of male's own treatment on own outcome, blocking path through mediator (MC)",
                   "Indirect Individual Effect of Treatment Assignment",
                   "Proportion of Individual Effect of Treatment Assignment Mediated by MC",
                   "Overall Intervention Village Effect",
                   "Proportion of Total Effect Mediated by MC",
                   "Proportion of intervention village total effect due to spillover within intervention villages"),
  `Model Equation` = c("$\\text{A. } logit(Y_{ik}) = \\beta_0^{\\text{SpW}} + \\beta_1^{\\text{SpW}}(T_{k})$",
                       "$\\text{B. } logit(Y_{ik}) = \\beta_0^{\\text{SpWR}} + \\beta_1^{\\text{SpWR}}(T_{k}) + \\beta_2^{\\text{SpWR}}(Z_k^{(1)})$",
                       "$\\text{C. } \\frac{\\beta_1^{\\text{SpW}} - \\beta_1^{\\text{SpWR}}}{\\beta_1^{\\text{SpW}}}$",
                       "$\\text{D. } logit(Y_{ik}) = \\beta_0^{\\text{Ind}} + \\beta_1^{\\text{Ind}}(T_{k}) + \\beta_2^{\\text{Ind}}(Z_{k}^{(1)}) + \\beta_3^{\\text{Ind}}(Z_{k}^{(2)})$",
                       "$\\text{E. } logit(Y_{ik}) = \\beta_0^{\\text{IndD}} + \\beta_1^{\\text{IndD}}(T_{k}) + \\beta_2^{\\text{IndD}}(X_{ik}^{(1)}) + \\beta_3^{\\text{IndD}}(Z_k^{(1)}) + \\beta_4^{\\text{IndD}}(Z_k^{(2)})$",
                       "$\\text{F. } \\exp\\left( \\beta_1^{\\text{Ind}} - \\beta_1^{\\text{IndD}} \\right)$",
                       "$\\text{G. } \\frac{\\beta_1^{\\text{Ind}} - \\beta_1^{\\text{IndD}}}{\\beta_1^{\\text{Ind}}}$",
                       "$\\text{H. } logit(Y_{ik}) = \\beta_0^{\\text{Overall}} + \\beta_1^{\\text{Overall}}(T_{k})$",
                       "$\\text{I. } \\frac{[(\\beta_1^{\\text{Ind}} - \\beta_1^{\\text{IndM}}) + (\\beta_1^{\\text{SpW}} - \\beta_1^{\\text{SpWM}})]}{(\\beta_1^{\\text{Ind}} + \\beta_1^{\\text{SpW}})}$",
                       "$\\text{J. } \\frac{\\beta_1^{\\text{SpW}}}{(\\beta_1^{\\text{Ind}} + \\beta_1^{\\text{SpW}})}$"),
  Sample = c(paste0("All HIV- who did not receive any treatment ", "(n = ", nrow(modelDat_SpW), ")"), NA, NA, 
             paste0("All HIV- males ", "(n = ", nrow(modelDat_Ind), ")"), NA, NA, NA, 
             paste0("All HIV- ", "(n = ", nrow(modelDat), ")"), NA, NA),
  `Beta1 Description` = c("$\\beta_1^{\\text{SpW}}$ is the within-village spillover, estimates effect of living in a CP village despite receiving no components oneself",
                  "$\\beta_1^{\\text{SpWR}}$ compares untreated in CP vs. untreated in control villages after holding village's MC proportion fixed",
                  NA,
                  "$\\beta_1^{\\text{Ind}}$ is the total individual effect of male's own treatment on their own outcome",
                  "$\\beta_1^{\\text{InD}}$ is the individual direct effect of a male's treatment on their outcome, not including MC and HTC of others in the village",
                  NA,
                  NA,
                  "$\\beta_1^{\\text{Overall}}$ is the overall effect of being in an intervention village, including all pathways",
                  NA,
                  NA),
  `Beta1` = c(round(log(exp_beta_SpW_1), 2),
              round(log(exp_beta_SpWR_1), 2),
              NA,
              round(log(exp_beta_Ind_1), 2),
              round(log(exp_beta_IndD_1_firth), 2),
              NA,
              NA,
              round(log(exp_beta_overall_1), 2),
              NA,
              NA),
  `exp Beta1` = c(round(exp_beta_SpW_1, 2),
                  round(exp_beta_SpWR_1, 2),
                  NA,
                  round(exp_beta_Ind_1, 2),
                  round(exp_beta_IndD_1_firth, 2),
                  NA,
                  NA,
                  round(exp_beta_overall_1, 2),
                  NA,
                  NA)
)
```

```{r, results = 'asis', echo = FALSE, include = FALSE, eval = FALSE}
print(
  xtable(SummaryTable, caption = "Model Equation Summary", align = c("l", "p{4cm}", "p{3cm}", "p{2.5cm}", "p{4cm}", "p{1.5cm}", "p{1.5cm}")),
  include.rownames = FALSE,
  sanitize.text.function = identity,
  comment = FALSE,
  tabular.environment = "tabularx",
  width = "\\textwidth"
)
```




\newpage

# CURRENT ISSUES AND NOTES

## Ashley's email:

1. It would be helpful to write out the estimands for each effect. Are these the same as Tyler's paper? Does it matter that your mediator is part of the intervention package, while Tyler's is another covariate? https://pmc.ncbi.nlm.nih.gov/articles/PMC3753117/

2. Are the meditators at the individual level, group level or both? If group level, are you using an exposure mapping function? 

3. Can the spillover effect itself be mediated? In the case of just two people in a cluster, I believe the spillover problem can be exactly described as meditation.

4. How are the other package components handled? Could treat as confounders, averaging over them. 

5. For the OR =22, I would check the table of village assignment, VMMC exposure and outcome, probably a zero or small cell. Ke, any other ideas here?

6. Are you concerned about mediator confounding in this case? How is the correlation within cluster modeled? 

7. I think the positivity assumption is OK - as you have a three level exposure (women, male cirm, male unicorn) and fairly sure there are no gender restrictions on the covariates., but the "woman" status is not an intervention like VMMC is. 


## Notes from Laura

1. what we are doing is first estimating the total effect (which is a sum of the direct and indirect effects) by regressing on T.

    a. Laura's response: If regressing on T, this is the overall (total) effect, that is the overall effect of being in an intervention cluster compared to control. It's total because it's regardless of mediation.

2. then we are adjusting for x1 (vmmc) to get the direct effect of CP (assuming perfect compliance) and we can get the indirect effect through vmmc through the usual method we have in the slides.

    a. This is the overall indirect effect, that is the effect of cluster assignment through individual VMMC.

the new suggestion allows for imperfect compliance and this uses X12 in place of T. 

    a. What is the new suggestion?

## Other Notes

1. Circumcision that is done locally, not for medical purposes but for cultural purposes, is incomplete and may not be effective for preventing HIV. So at some point later in the analysis, it would be of interest to assess the effects of circumcision before the study started, with circumcision after.

2. Positivity assumption was mentioned as a possible issue because women can't have VMMC

3. Add a dag for mediation, and a dag for spillover - has anybody ever done this?

4. Do we have data on death? We can combine HIV and death as another outcome to have more events

5. There is a variable called hiv_status_time that gives HIV status by each visit, with status already positive, new positive, negative. Do you see this? And then there is a variable hiv_results_days that is days from enrollment to that test. That could give us 1 year incidence when/if we want that (for survival data analysis for example). These should add up to the number of cases in total.

6. If we want to create a combined variable, death or seroconversion, which could give us more cases and more power, if all or most of the deaths are due to HIV.

7. Time from enrollment to death is death_days. There is also a variable death_cause (can we take a look at this? It might be possible to delete deaths that are obviously not HIV related, such as accidents). And then there is another variable death_primary, which is the primary cause of death.



