---
title: "BCPP Preliminary Analysis"
author: "Melody Owen"
date: "2025-05-30"
output:
  pdf_document:
    latex_engine: pdflatex  # or xelatex/lualatex if you're using those
    includes:
      in_header: preamble.tex
geometry: margin=0.5in
---

# OVERVIEW

## The Botswana Combination Prevention Project (BCPP)

### Motivation

- \underline{Goal}: The primary goal of BCPP was to determine whether implementation of combination prevention package (CP) can significantly reduce population-level, cumulative HIV incidence

- \underline{Population}: Individuals in Botswana aged 16-64 years

- \underline{Timeline}: Study length was approximately 3 years

- \underline{Design}: 30 communities were selected and matched into pairs based on community characteristics thought to be associated with HIV incidence

### Treatment in BCPP

The Combination Prevention (CP) prevention package included the following four components:

1. \underline{VMMC}: Male circumcision (only for HIV-negative males)

2. \underline{HTC}: HIV Testing and Counseling (only for HIV-negative individuals)

3. \underline{ART}: Antiretroviral Therapy (only for HIV-positive individuals)

4. \underline{PMTCT}: Prevention of mother-to-child transmission (only for pregnant HIV-positive females)

Clusters (30 communities) were randomized to either:

- \underline{Treatment}: CP Package

- \underline{Control}: Standard of Care

Our analysis examines the impact of CP for HIV-negative individuals, so we consider the "entire" package components 1 and 2 only.

\newpage

## Questions of Interest

1. What is the direct effect (OR) of the CP intervention?

    a. This is the direct effect among those to intervention villages
    b. Will be a standard mediation analysis
    c. Related: To what extent is the effect mediated by receipt of VMMC? Look at the mediation proportion in a standard mediation analysis.

2. To what extent is the total effect mediated by VMMC (Voluntary Male Medical Circumcision)? 

    a. In this case, "overall" means combining spillover effects with individual effects
    b. Define the mediation proportion
    
4. To what extent is the individual effect of CP mediated by VMMC?

1. What is the overall effect (OR) of CP on HIV incidence?

    a. Use a logistic regression model
    b. Intent to treat (ITT) analysis
  
5. What is the spillover effect (OR) of CP in intervention villages compared to those who did not take up CP?

    a. Spillover effect is among those in intervention villages who did not receive the intervention
    b. Related: To what extent is the spillover effect mediated by villages level VMMC deliver (mediation proportion)? (Look at Tyler's paper)
  
6. What is the total spillover (OR) of the CP intervention?

    a. Total spillover effect is everyone in BCPP who did not receive the intervention in control and intervention villages
    b. Related: To what extent is the total spillover effect mediated by village level of VMMC delivery (mediation proportion)?
    
7. What is the total effect of CP across all villages in the study?

\newpage

# NOTATION

$K$ is the total number of villages in the study, indexed as $k = 1,...,K$

$m_k$ is the total number of individuals in cluster $k$, indexed as $i = 1,...,m_k$

- $m_k^{(\text{male})}$ are the total number of males in cluster $k$
- $m_k^{(\text{female})}$ are the total number of females in cluster $k$
    
$Y_{ik}$ is the outcome of subject $i$ in cluster $k$, and is binary

- In BCPP, $Y_{ik} = 1$ if a subject seroconverted by the end of the study, $Y_{ik} = 0$ otherwise

$T_k$ is the cluster-level binary treatment assignment

- In BCPP, $T_k = 1$ if a cluster has been assigned to receive CP, and $T_k = 0$ otherwise

$X_{ik}^{(1)}$, $X_{ik}^{(2)}$ denotes each of the two components of the treatment, $T_k$. 

- In BCPP, the Combination Prevention (CP) package included the following:

    1. MC: Male Circumcision (available only for HIV-negative males)
    2. HTC: HIV Testing and Counseling (available only for HIV-negative individuals)
    3. ART: Antiretroviral Therapy (available only for HIV-positive individuals)
    4. PMTCT: Prevention of Mother-to-Child Transmission (available only for HIV-positive females)
    
- We are only considering the first two components as the entire treatment package, since the last two apply to HIV-positive individuals only.
- $X_{ik}^{(1)} = \text{"Yes"}$ if individual $i$ in cluster $k$ was circumcised before or during the study, $X_{ik}^{(1)} = \text{"No"}$ if they are male and not circumcised, and $X_{ik}^{(1)} = \text{"Female"}$ if they are female (three levels are included as to not exclude females)
- $X_{ik}^{(2)} = 1$ if individual $i$ in cluster $k$ received HTC at enrollment or thereafter, and $X_{ik}^{(2)} = 0$ otherwise

$X_{ik}^{(12)}$ denotes whether individual $i$ in cluster $k$ received the entire treatment

- For males in BCPP, $X_{ik}^{(12)} = X_{ik}^{(1)} \times X_{ik}^{(2)} = 1$ if they received both MC and HTC, $X_{ik}^{(12)} = 0$ otherwise
- For females in BCPP, $X_{ik}^{(12)} = X_{ik}^{(2)} = 1$ if they received HTC, $X_{ik}^{(12)} = 0$ otherwise

$Z_k^{(1)}$, $Z_k^{(2)}$ is the proportion of indivividuals in village $k$ who received the first component and second component of the treatment, respectively

- For males in BCPP, $Z_k^{(1)} = \sum_{i=1}^{m_k^{(\text{male})}} \frac{X_{ik}^{(1)}}{m_k^{(\text{male})}}$ is the proportion of males in village $k$ who are circumcised before or during the study

- For all individuals in BCPP, $Z_k^{(2)} = \sum_{i=1}^{m_k} \frac{X_{ik}^{(2)}}{m_k}$ is the proportion of all individuals in village $k$ who received HTC

$Z_{ik}^{(12)}$ is the proportion of individuals who received the full treatment

- For males in BCPP, $Z_{ik}^{(12)} = \sum_{i=1}^{m_k^{(\text{male})}} \frac{X_{ik}^{(1)} \times X_{ik}^{(2)}}{m_k^{(\text{male})}}$ is the proportion of males who are both circumcised and received HTC
- For females in BCPP, $Z_{ik}^{(12)} = Z_{ik}^{(2)} = \sum_{i=1}^{m_k^{(\text{female})}} \frac{X_{ik}^{(2)}}{m_k^{(\text{female})}}$ is the proprtion of females who received HTC

$\mathbf{C}_{ik} = (C_{1k}^{(1)}, ..., C_{m_k k}^{(1)}, C_{1k}^{(2)}, ..., C_{m_k k}^{(2)})$ are the individual level covariates

$\mathbf{V}_k = (V_k^{(1)}, ..., V_k^{(v)})$ are the cluster-level covariates

\newpage

```{r setup, include = FALSE}
# Package names
packages <- c("tidyverse", "lme4", "MASS", "Matrix", "matrixcalc", "latex2exp",
              "ICC", "nlme", "bindata", "gee", "crt2power", "mosaic", "haven",
              "tmvtnorm", "ggplot2", "latex2exp", "reshape2", "gridExtra",
              "table1", "broom", "xtable", "logistf", "kableExtra",
              "elrm", "broom", "dplyr", "tibble")

# Install packages not yet installed
installed_packages <- packages %in% rownames(installed.packages())
if (any(installed_packages == FALSE)) {
  install.packages(packages[!installed_packages])
}

# Packages loading
invisible(lapply(packages, library, character.only = TRUE))
```


```{r load_data, include = FALSE}
# Loading in original datasets
dat1 <- read_sas("~/Desktop/3. Causal Inference Mediation/BCPP data/BCPP data/longyr1_20samp_open.sas7bdat")
dat2 <- read_sas("~/Desktop/3. Causal Inference Mediation/BCPP data/BCPP data/longyr2_20samp_open.sas7bdat")
dat3 <- read_sas("~/Desktop/3. Causal Inference Mediation/BCPP data/BCPP data/longyr3_20samp_open.sas7bdat")
```


```{r column_names, include = FALSE}
# Create a dataframe for each set of column names
names1 <- tibble(colname = sort(colnames(dat1)), dataset = "dat1")
names2 <- tibble(colname = sort(colnames(dat2)), dataset = "dat2")
names3 <- tibble(colname = sort(colnames(dat3)), dataset = "dat3")

# Bind and pivot to wide
all_names <- bind_rows(names1, names2, names3) %>%
  mutate(present = colname) %>%
  pivot_wider(names_from = dataset, values_from = present) %>%
  arrange(colname)

all_names_filtered <- bind_rows(names1, names2, names3) %>%
  mutate(present = colname) %>%
  pivot_wider(names_from = dataset, values_from = present) %>%
  arrange(colname) %>%
  dplyr::filter(colname %in% c("de_subj_idC", # Subject identifier
                               "community", # Community identifier
                               
                               "random_arm", # Randomization arm (Treatment Assignment)
                               "gender", # Gender
                               
                               # At start of study? Unclear
                               "hiv_status_current", # Current HIV status
                               "circumcised", # Male circumcision
                               
                               # "Coverage Endpoint"
                               "endpoint_coverage_htc", # Coverage endpoint: HIV-tested or diagnosed HIV+
                               "endpoint_coverage_mc", # Coverage endpoint: male circumcision
                               
                               
                               # Outcome
                               "endpoint_seroconvert") # Incidence endpoint: seroconverted by study completion
  )

# Keeping subject ID the same name so I can match the data
dat1_renamed <- dat1 %>% rename_with(~ paste0(., "_dat1"), -de_subj_idC)
dat2_renamed <- dat2 %>% rename_with(~ paste0(., "_dat2"), -de_subj_idC)
dat3_renamed <- dat3 %>% rename_with(~ paste0(., "_dat3"), -de_subj_idC)
```


```{r merging_datasets, include = FALSE}
# Circumcision in all three datasets
combinedDat <- full_join(dat1_renamed, dat2_renamed, by = "de_subj_idC") %>%
  full_join(dat3_renamed, by = "de_subj_idC") %>%
  dplyr::select(de_subj_idC, starts_with("random_arm_dat"), 
                contains("community_dat"),
                starts_with("Gender_dat"), hiv_status_current_dat1,
                starts_with("circumcised_dat"), contains("endpoint_coverage_mc"),
                contains("endpoint_coverage_htc"), contains("seroconvert")) %>%
  mutate(random_arm = ifelse(!is.na(random_arm_dat1), random_arm_dat1,
                             ifelse(!is.na(random_arm_dat2), random_arm_dat2,
                                    random_arm_dat3))) %>%
  mutate(gender = ifelse(!is.na(gender_dat1), gender_dat1,
                         ifelse(!is.na(gender_dat2), gender_dat2,
                                gender_dat3))) %>%
  mutate(community = ifelse(!is.na(community_dat1), community_dat1,
                            ifelse(!is.na(community_dat2), community_dat2,
                                   community_dat3))) %>%
  dplyr::select(subject_ID = de_subj_idC, community, gender,
                random_arm, hiv_status_current = hiv_status_current_dat1,
                starts_with("circumcised"),
                contains("endpoint_coverage_mc"), 
                contains("endpoint_coverage_htc"),
                contains("seroconvert")) %>%
  mutate(gender = case_when(gender == "F" ~ "Female",
                            gender == "M" ~ "Male",
                            TRUE ~ NA_character_
  )) %>%
  mutate(circumcised_dat1 = ifelse(gender == "Female",
                                   "Female", circumcised_dat1),
         circumcised_dat2 = ifelse(gender == "Female",
                                   "Female", circumcised_dat2),
         circumcised_dat3 = ifelse(gender == "Female",
                                   "Female", circumcised_dat3)) %>%
  mutate(circumcised_dat2 = ifelse(circumcised_dat1 == "Yes", "Yes",
                                   circumcised_dat2)) %>%
  mutate(circumcised_dat3 = ifelse(circumcised_dat2 == "Yes", "Yes",
                                   ifelse(circumcised_dat1 == "Yes", "Yes",
                                          circumcised_dat3))) %>%
  mutate(across(everything(), ~ na_if(., ""))) %>%
  mutate(across(where(is.character), str_trim)) %>%
  mutate(endpoint_coverage_mc_dat1 = ifelse(gender == "Female", "Female", endpoint_coverage_mc_dat1),
         endpoint_coverage_mc_dat2 = ifelse(gender == "Female", "Female", endpoint_coverage_mc_dat2),
         endpoint_coverage_mc_dat3 = ifelse(gender == "Female", "Female", endpoint_coverage_mc_dat3)) %>%
  mutate(endpoint_coverage_mc = ifelse(circumcised_dat1 == "Yes",
                                       "Began study circumcised", NA)) %>%
  mutate(endpoint_coverage_mc = ifelse(gender == "Female", "Female",
                                       endpoint_coverage_mc)) %>%
  mutate(endpoint_coverage_mc = ifelse(is.na(endpoint_coverage_mc) & endpoint_coverage_mc_dat3 == "Yes",
                                       "Yes", endpoint_coverage_mc)) %>%
  mutate(endpoint_coverage_mc = ifelse(is.na(endpoint_coverage_mc) & endpoint_coverage_mc_dat2 == "Yes",
                                       "Yes", endpoint_coverage_mc)) %>%
  mutate(endpoint_coverage_mc = ifelse(is.na(endpoint_coverage_mc) & endpoint_coverage_mc_dat1 == "Yes",
                                       "Yes", endpoint_coverage_mc)) %>%
  mutate(endpoint_coverage_mc = ifelse(is.na(endpoint_coverage_mc) & circumcised_dat3 == "Yes",
                                       "Yes", endpoint_coverage_mc)) %>%
  mutate(endpoint_coverage_mc = ifelse(is.na(endpoint_coverage_mc) & circumcised_dat2 == "Yes",
                                       "Yes", endpoint_coverage_mc)) %>%
  mutate(endpoint_coverage_mc = ifelse(is.na(endpoint_coverage_mc) &
                                         rowSums(across(contains("dat"), ~ replace_na(. == "No", FALSE))) > 0 &
                                         rowSums(across(contains("dat"), ~ replace_na(. == "Yes", FALSE))) == 0,
                                       "No", endpoint_coverage_mc))
```


```{r cleaning_data, include = FALSE}
# This dataset is a cleaned version of the original dataset with NO ONE EXCLUDED YET
cleanDat <- combinedDat %>%
  dplyr::select(original_subject_id = subject_ID, 
                original_cluster_id = community, 
                random_arm, gender, 
                hiv_status_current,
                endpoint_coverage_htc = endpoint_coverage_htc_dat1, 
                endpoint_coverage_mc, 
                endpoint_seroconvert = endpoint_seroconvert_dat1) %>%
  mutate(endpoint_coverage_full = ifelse(gender == "Male" & (endpoint_coverage_mc == "Yes" | endpoint_coverage_mc == "Began study circumcised") & endpoint_coverage_htc == "Yes", "Yes", 
                         ifelse(gender == "Female" & endpoint_coverage_htc == "Yes", "Yes", "No"))) %>%
  arrange(original_cluster_id, original_subject_id) %>%
  mutate_if(is.character, list(~na_if(., ""))) %>% # change any blanks to NAs
  rowid_to_column("subject_id") %>%
  group_by(original_cluster_id) %>%
  mutate(cluster_id = cur_group_id()) %>%
  mutate(subj_cluster_id = row_number()) %>%
  ungroup() %>%
  add_count(cluster_id, name = "cluster_size") %>%
  relocate(subject_id, subj_cluster_id, cluster_id, cluster_size) %>%
  ungroup() %>%
  dplyr::select(-original_subject_id, -original_cluster_id) %>%
  mutate(random_arm = ifelse(random_arm == "Standard of Care", "Control",
                             ifelse(random_arm == "Intervention", "Treatment", NA))) %>%
  mutate(endpoint_seroconvert = ifelse(hiv_status_current == "HIV-infected",
                                       "Began study HIV-infected", endpoint_seroconvert))
```

```{r create_model_dat, include = FALSE}
# ModelDat is the clean dataset but with people excluded
# Only exclude people who already have HIV or refused testing
modelDat_full <- cleanDat %>%
  # Calculate proportions first
  mutate(T_k = ifelse(random_arm == "Treatment", 1, 
                      ifelse(random_arm == "Control", 0, NA))) %>%
  # 1 if circumcised before or during study, 0 if no, "Female" if female
  mutate(X1_ik = ifelse(endpoint_coverage_mc == "Yes" | endpoint_coverage_mc == "Began study circumcised", "Yes",
                        ifelse(endpoint_coverage_mc == "No", "No", endpoint_coverage_mc))) %>%
  # 1 if HTC yes, 0 if HTC no
  mutate(X2_ik = ifelse(endpoint_coverage_htc == "Yes", 1,
                        ifelse(endpoint_coverage_htc == "No", 0, NA))) %>%
  # 1 if Male, circumcised, and got HTC | 1 if female and got HTC, 0 otherwise
  mutate(X12_ik = ifelse(gender == "Male" & X1_ik == "Yes" & X2_ik == 1, 1, 
                         ifelse(gender == "Female" & X2_ik == 1, 1, 0))) %>%
  # Gender characteristic, 1 if Male, 0 if female
  mutate(C1_ik = ifelse(gender == "Male", 1, 
                        ifelse(gender == "Female", 0, NA))) %>%
  group_by(cluster_id) %>%
  # Count of all men in each cluster
  mutate(male_count = sum(gender == "Male", na.rm = TRUE)) %>%
  # Count of all male circumcised men in each cluster
  mutate(mc_count = sum(X1_ik == "Yes", na.rm = TRUE)) %>%
  # Count of those who received HTC in each cluster
  mutate(htc_count = sum(X2_ik == 1, na.rm = TRUE)) %>%
  # Count of those who received their full treatment in each cluster
  mutate(full_trt_count = sum(X12_ik == 1, na.rm = TRUE)) %>%
  # Count of those who started study HIV positive in each cluster
  mutate(hiv_infected_count = sum(hiv_status_current == "HIV-infected", na.rm = TRUE)) %>%
  mutate(hiv_refused_testing_count = sum(hiv_status_current == "Refused HIV testing", na.rm = TRUE)) %>%
  ungroup() %>%
  # Treatment related proportions
  mutate(Z1_k = mc_count/male_count, # Prop males circumcised
         Z2_k = htc_count/cluster_size,
         Z12_k = full_trt_count/cluster_size) %>%
  # Characteristic related proportions
  mutate(hiv_infected_prop = hiv_infected_count/cluster_size) %>%
  mutate(hiv_refused_testing_prop = hiv_refused_testing_count/cluster_size) %>%
  mutate(Y_ik = ifelse(endpoint_seroconvert == "Yes", 1,
                       ifelse(endpoint_seroconvert == "No", 0, NA)))

# Then filter out people who already have HIV or refused testing
modelDat <- modelDat_full %>% 
  dplyr::filter(hiv_status_current == "HIV-uninfected")

excludedDat <- modelDat_full %>%
  dplyr::filter(hiv_status_current != "HIV-uninfected")
```

# BASELINE CHARACTERISTICS

## Characteristics Before Exclusions

The original dataset has `r nrow(cleanDat)` total individuals in the study; `r nrow(dplyr::filter(cleanDat, random_arm == "Treatment"))` in the treatment group, and `r nrow(dplyr::filter(cleanDat, random_arm == "Control"))` in the control arm. 


```{r include = FALSE}
baseline_full <- cleanDat %>%
  dplyr::select(`Treatment Group` = random_arm,
                `Cluster Size` = cluster_size,
                `Gender` = gender,
                `HIV Status at Start` = hiv_status_current,
                `Treatment Component: MC` = endpoint_coverage_mc,
                `Treatment Component: HTC` = endpoint_coverage_htc,
                `Treatment Component: Full` = endpoint_coverage_full,
                `Outcome: Seroconvert` = endpoint_seroconvert) %>%
  mutate(across(
    where(~ !is.numeric(.x)),
    ~ ifelse(is.na(.x), "Missing", as.character(.x))
  ))

baseline_missing <- baseline_full %>%
  dplyr::select(-`Cluster Size`) %>%
  filter(if_any(everything(), ~ .x == "Missing")) %>%
  mutate(across(
    .cols = -c(`Treatment Group`),  # replace col1 and col2 with your actual column names
    .fns = ~ if_else(.x == "Missing", 1, 0)
  )) %>%
  group_by(`Treatment Group`) %>%
  summarise(across(
    everything(),  # No need to exclude the grouping var here
    sum,
    .names = "{.col}"
  )) %>%
  dplyr::select(-Gender) %>%
  ungroup() %>%
  pivot_longer(
    cols = -`Treatment Group`,  # gather all variables except the group
    names_to = "Variable",
    values_to = "Missing"
  ) %>%
  pivot_wider(
    names_from = `Treatment Group`,
    values_from = Missing
  ) %>%
  mutate(Overall = Control + Treatment) %>%
  rename(`Missing (Control)` = Control,
         `Missing (Treatment)` = Treatment,
         `Missing (Overall)` = Overall)

cluster_size <- tibble(Variable = c("Number of Individuals", 
                                    "Number of Clusters", 
                                    "Mean Cluster Size"),
                       Level = c(NA, NA, NA),
                       Control = c(nrow(dplyr::filter(cleanDat, random_arm == "Control")),
                                   length(unique(dplyr::filter(cleanDat, random_arm == "Control")$cluster_id)),
                                   mean(filter(cleanDat, random_arm == "Control")$cluster_size)),
                       Treatment = c(nrow(dplyr::filter(cleanDat, random_arm == "Treatment")),
                                     length(unique(dplyr::filter(cleanDat, random_arm == "Treatment")$cluster_id)),
                                     mean(filter(cleanDat, random_arm == "Treatment")$cluster_size))) %>%
  mutate(Control = as.integer(Control), Treatment = as.integer(Treatment)) %>%
  mutate(Overall = ifelse(Variable == "Number of Individuals", Treatment + Control, round((Treatment + Control) / 2, 1)))

baseline_tab <- baseline_full %>%
  dplyr::select(-`Cluster Size`) %>%
  pivot_longer(!`Treatment Group`, 
               names_to = "Variable", values_to = "Level") %>%
  arrange(`Treatment Group`, Variable, Level) %>%
  group_by(`Treatment Group`, Variable, Level) %>%
  summarize(n = n()) %>%
  ungroup() %>%
  pivot_wider(
    names_from = `Treatment Group`,
    values_from = n
  ) %>%
  filter(Level != "Missing") %>%
  mutate(Overall = Treatment + Control)
  
final_baseline_full_table <- rbind(cluster_size, baseline_tab) %>%
  left_join(baseline_missing, by = "Variable") %>%
  group_by(Variable) %>%
  mutate(
    Variable = if_else(row_number() == 1, Variable, NA_character_),
    `Missing (Control)` = if_else(row_number() == 1, `Missing (Control)`, NA_integer_),
    `Missing (Treatment)` = if_else(row_number() == 1, `Missing (Treatment)`, NA_integer_),
    `Missing (Overall)` = if_else(row_number() == 1, `Missing (Overall)`, NA_integer_)
  ) %>%
  ungroup() %>%
  mutate(Overall = as.integer(Overall),
         `Missing (Control)` = as.integer(`Missing (Control)`),
         `Missing (Treatment)` = as.integer(`Missing (Treatment)`),
         `Missing (Overall)` = as.integer(`Missing (Overall)`))
```


```{r, results = 'asis', echo = FALSE}
cat("\\begin{landscape}\n")

print(
  xtable(
    final_baseline_full_table,
    caption = "Characteristics by treatment group before exclusions",
    label = "tab:cluster_summary"
  ),
  type = "latex",
  include.rownames = FALSE,
  comment = FALSE
)

cat("\\end{landscape}\n")
```


Table below displays the mean proportion, per cluster, of various characteristics, including mean proportion of HIV infected individuals per cluster at baseline, etc. These are calculated before any exclusions. 

```{r include = FALSE}
proportion_dat <- modelDat %>%
  mutate(`Proportion of Males in Cluster` = male_count/cluster_size) %>%
  dplyr::select(cluster_id, 
                `Treatment Group` = random_arm,
                `Proportion of HIV Infected in Cluster` = hiv_infected_prop,
                #`Proportion of Refused HIV Testing in Cluster` = hiv_refused_testing_prop,
                `Proportion of Males in Cluster`,
                `Proportion of Males Circumcised in Cluster` = Z1_k, 
                `Proportion HTC in Cluster` = Z2_k,
                `Proportion Fully Treated in Cluster` = Z12_k) %>%
  distinct()

# Compute summary with Mean and SD
proportion_table_final <- proportion_dat %>%
  group_by(`Treatment Group`) %>%
  dplyr::select(-cluster_id) %>%
  summarize(across(
    everything(),
    list(
      Mean = ~mean(.x, na.rm = TRUE),
      SD = ~sd(.x, na.rm = TRUE)
    ),
    .names = "{.fn} | {.col}"
  )) %>%
  mutate(across(where(is.numeric), round, 2)) %>%
  pivot_longer(
    -`Treatment Group`,
    names_to = "Stat_Var",
    values_to = "Value"
  ) %>%
  separate(Stat_Var, into = c("Stat", "Variable"), sep = " \\| ") %>%
  pivot_wider(
    names_from = Stat,
    values_from = Value
  ) %>%
  mutate(
    Value = paste0(Mean, " (", SD, ")"),
    Variable = paste0(Variable, " (Mean, SD)")
  ) %>%
  dplyr::select(-Mean, -SD) %>%
  pivot_wider(
    names_from = `Treatment Group`,
    values_from = Value
  )

# View result
#proportion_table_final
#View(proportion_table_final)
```

```{r, results = 'asis', echo = FALSE}
print(
  xtable(
    proportion_table_final,
    caption = "Cluster-level proportions by treatment group before exclusions",
    label = "tab:cluster_summary"
  ),
  type = "latex",
  include.rownames = FALSE,
  comment = FALSE
)
```

## Characteristics After Exclusions

A total of `r nrow(excludedDat)` individuals were excluded from the analysis dataset. This is because these individuals either began the study as HIV-positive (n = `r nrow(filter(excludedDat, hiv_status_current == "HIV-infected"))`), or refused HIV testing (n = `r nrow(filter(excludedDat, hiv_status_current == "Refused HIV testing"))`). 

Note that in our analyses, we evaluated whether the intervention reduced HIV incidence by modeling seroconversion among individuals who were HIV-negative at baseline (n = `r nrow(modelDat)`). Although the analysis was restricted to this at-risk subset, all cluster-level characteristics (e.g., proportion HIV-positive at baseline, proportion of men circumcised, etc.) were calculated using the full study population. This approach ensures that the covariates reflect the overall context and implementation environment of each cluster, rather than being limited to the analytic subset.


```{r include = FALSE}
baseline_excluded <- excludedDat %>%
  dplyr::select(`Treatment Group` = random_arm,
                `Cluster Size` = cluster_size,
                `Gender` = gender,
                `HIV Status at Start` = hiv_status_current,
                `Treatment Component: MC` = endpoint_coverage_mc,
                `Treatment Component: HTC` = endpoint_coverage_htc,
                `Treatment Component: Full` = endpoint_coverage_full,
                `Outcome: Seroconvert` = endpoint_seroconvert) %>%
  mutate(across(
    where(~ !is.numeric(.x)),
    ~ ifelse(is.na(.x), "Missing", as.character(.x))
  ))

baseline_missing_excluded <- baseline_excluded %>%
  dplyr::select(-`Cluster Size`) %>%
  filter(if_any(everything(), ~ .x == "Missing")) %>%
  mutate(across(
    .cols = -c(`Treatment Group`),  # replace col1 and col2 with your actual column names
    .fns = ~ if_else(.x == "Missing", 1, 0)
  )) %>%
  group_by(`Treatment Group`) %>%
  summarise(across(
    everything(),  # No need to exclude the grouping var here
    sum,
    .names = "{.col}"
  )) %>%
  dplyr::select(-Gender) %>%
  ungroup() %>%
  pivot_longer(
    cols = -`Treatment Group`,  # gather all variables except the group
    names_to = "Variable",
    values_to = "Missing"
  ) %>%
  pivot_wider(
    names_from = `Treatment Group`,
    values_from = Missing
  ) %>%
  mutate(Overall = Control + Treatment) %>%
  rename(`Missing (Control)` = Control,
         `Missing (Treatment)` = Treatment,
         `Missing (Overall)` = Overall)

cluster_size_excluded <- tibble(Variable = c("Number of Individuals"),
                       Level = c(NA),
                       Control = c(nrow(dplyr::filter(baseline_excluded, `Treatment Group` == "Control"))),
                       Treatment = c(nrow(dplyr::filter(baseline_excluded, `Treatment Group` == "Treatment")))) %>%
  mutate(Control = as.integer(Control), Treatment = as.integer(Treatment)) %>%
  mutate(Overall = Treatment + Control)

baseline_tab_excluded <- baseline_excluded %>%
  dplyr::select(-`Cluster Size`) %>%
  pivot_longer(!`Treatment Group`, 
               names_to = "Variable", values_to = "Level") %>%
  arrange(`Treatment Group`, Variable, Level) %>%
  group_by(`Treatment Group`, Variable, Level) %>%
  summarize(n = n()) %>%
  ungroup() %>%
  pivot_wider(
    names_from = `Treatment Group`,
    values_from = n
  ) %>%
  filter(Level != "Missing") %>%
  mutate(Overall = Treatment + Control)
  
final_baseline_excluded_table <- rbind(cluster_size_excluded, baseline_tab_excluded) %>%
  left_join(baseline_missing, by = "Variable") %>%
  group_by(Variable) %>%
  mutate(
    Variable = if_else(row_number() == 1, Variable, NA_character_),
    `Missing (Control)` = if_else(row_number() == 1, `Missing (Control)`, NA_integer_),
    `Missing (Treatment)` = if_else(row_number() == 1, `Missing (Treatment)`, NA_integer_),
    `Missing (Overall)` = if_else(row_number() == 1, `Missing (Overall)`, NA_integer_)
  ) %>%
  ungroup() %>%
  mutate(Overall = as.integer(Overall),
         `Missing (Control)` = as.integer(`Missing (Control)`),
         `Missing (Treatment)` = as.integer(`Missing (Treatment)`),
         `Missing (Overall)` = as.integer(`Missing (Overall)`))
```


```{r, results = 'asis', echo = FALSE}
cat("\\begin{landscape}\n")

print(
  xtable(
    final_baseline_excluded_table,
    caption = "Characteristics by treatment group of the excluded individuals",
    label = "tab:cluster_summary"
  ),
  type = "latex",
  include.rownames = FALSE,
  comment = FALSE
)

cat("\\end{landscape}\n")
```

\newpage 

# MODELING RESULTS

## Within-Village Spillover


\underline{Setup}

- In this analysis, we include:

    a. Everyone in the treatment group who DID NOT receive *any* part of the treatment (For $T_k = 1$, $X_{ik}^{(1)} = "\text{Yes}" \text{ or } "\text{Female}"$ and $X_{ik}^{(2)} = 0$)
    b. Everyone in the control group who DID NOT receive *any* part of the treatment (For $T_k = 0$, $X_{ik}^{(1)} = "\text{Yes}" \text{ or } "\text{Female}"$ and $X_{ik}^{(2)} = 0$)

- This setup will allow us to estimate

    a. Spillover Within Intervention Clusters
    b. Spillover Mediated by Male Circumcision
    c. Proportion of Within-Intervention Village Spillover Effect Mediated by Male Circumcision

\underline{Dataset}

```{r}
# Only include those in treatment group who DID NOT receive any part of the treatment
# Only include those in control group who DID NOT receive any part of treatment
modelDat_SpW <- modelDat %>%
  filter(X1_ik != "Yes", X2_ik == 0) # Exclude anyone who got any part of the treatment
```


\underline{Summary counts of individuals per treatment group}

```{r, echo = FALSE, comment = ""}
# Summary Table
print(tally(T_k ~ X1_ik, data = modelDat_SpW))
print(tally(T_k ~ X2_ik, data = modelDat_SpW))
print(tally(Y_ik ~ X1_ik, data = modelDat_SpW))
print(tally(Y_ik ~ X2_ik, data = modelDat_SpW))
```
\newpage

### A. Total Within-Cluster Spillover Effect of Treatment Assignment

"SpW" denotes total spillover within intervention clusters. This compares participants in intervention villages who received neither relevant intervention component to people in the control villages (who also did not receive any part of the intervention component)

Then, under certain assumptions, the only way for an intervention village participant to have lower HIV risk is by association with others in the village with lower HIV risk because of their exposure to the intervention. 

$$logit(Y_{ik}) = \beta_0^{\text{SpW}} + \beta_1^{\text{SpW}}(T_{k})$$

Then $\exp\left( \beta_1^{\text{SpW}} \right)$ is a within-village spillover OR, and estimates the causal effect of living in a CP village, despite receiving no components oneself, on the odds of seroconversion. This is total within-village spillover effect. 

```{r}
# Spillover Within Intervention Clusters
model_SpW <- glm(Y_ik ~ T_k,
                 family = binomial(link = 'logit'),
                 data = modelDat_SpW) # Exclude those who received full trt

model_SpW_summary <- summary(model_SpW) # Save model summary

exp_beta_SpW_0 <- exp(model_SpW_summary$coefficients[1,1]) # Intercept
exp_beta_SpW_1 <- exp(model_SpW_summary$coefficients[2,1]) # T_k Coefficient

#model_SpW_summary 
#tidy(model_SpW, exponentiate = TRUE, conf.int = TRUE) # Print output

tidy_SpW <- tidy(model_SpW, conf.int = TRUE, exponentiate = TRUE) %>%
  dplyr::select(term, estimate, std.error, p.value, conf.low, conf.high) %>%
  rename(
    Term = term,
    OR = estimate,
    SE = std.error,
    `p-value` = p.value,
    `95% CI (lower)` = conf.low,
    `95% CI (upper)` = conf.high
  )
# tidy_SpW
```

```{r, results = 'asis', echo = FALSE}
print(xtable(tidy_SpW, digits = c(0, 0, 3, 3, 3, 3, 3),
             caption = "Spillover Within Intervention Clusters Model Output"), 
      type = 'latex', include.rownames = FALSE, comment = FALSE)
```

Thus, among people who received none of the intervention components, those living in CP villages had `r (1-round(exp_beta_SpW_1, 2))*100`% lower odds of HIV seroconversion than otherwise comparable untreated people in control villages. Since every individual in this analytic set is personally untreated, any difference in their HIV risk can only arise from indirect protection, and thus, `r round(exp_beta_SpW_1, 2)` is interpreted as the within-village spillover effect of CP.

\newpage

### B. Within-Cluster Spillover Treatment Assignment Effect Not through Male Circumcision

"SpWR" denotes all the remaining spillover that affects one's outcome that exists when we block the mediated spillover path that exists through male circumcision. 

$$logit(Y_{ik}) = \beta_0^{\text{SpWR}} + \beta_1^{\text{SpWR}}(T_{k}) + \beta_2^{\text{SpWR}}(Z_k^{(1)})$$

Here, $\exp\left(\beta_1^{\text{SpWR}} \right)$ compares untreated individuals in CP villages with untreated individuals in control villages after we hold the village's male-circumcision coverage fixed at the same value for both groups. So, it's the OR for the remaining within-village spillover - whatever protection (or risk) is left once the male-circumcision pathway has been accounted for. 

```{r}
# Spillover Mediated by Male Circumcision
model_SpWR <- glm(Y_ik ~ T_k + Z1_k,
                  family = binomial(link = 'logit'),
                  data = modelDat_SpW)

model_SpWR_summary <- summary(model_SpWR) # Save model summary

exp_beta_SpWR_0 <- exp(model_SpWR_summary$coefficients[1,1]) # Intercept
exp_beta_SpWR_1 <- exp(model_SpWR_summary$coefficients[2,1]) # T_k Coefficient
exp_beta_SpWR_2 <- exp(model_SpWR_summary$coefficients[3,1]) # Z1_k Coefficient

tidy_SpWR <- tidy(model_SpWR, conf.int = TRUE, exponentiate = TRUE) %>%
  dplyr::select(term, estimate, std.error, p.value, conf.low, conf.high) %>%
  rename(
    Term = term,
    OR = estimate,
    SE = std.error,
    `p-value` = p.value,
    `95% CI (lower)` = conf.low,
    `95% CI (upper)` = conf.high
  )
```

```{r, results = 'asis', echo = FALSE}
print(xtable(tidy_SpWR, digits = c(0, 0, 3, 3, 3, 3, 3),
             caption = "Spillover Mediated by Male Circumcision Model Output"), 
      type = 'latex', include.rownames = FALSE, comment = FALSE)
```

After we hold village circumcision coverage fixed, untreated residence of CP villages will still have a `r (1 - round(exp_beta_SpWR_1, 2))*100`% lower odds of seroconversion than untreated residence of control villages. This is spillover that operates through pathways other than male-circumcision coverage (e.g. HTC uptake, general behavior change, program outreach). 

Then, moving from a 0% to 100% male circumcised coverage in a village multiplies an untreated person's odds of seroconversion by `r round(exp_beta_SpWR_2, 2)`. This means `r (1 - round(exp_beta_SpWR_2, 2))*100`% lower odds of HIV acquisition for an untreated person when their village goes from zero to complete male-circumcision coverage.  

\newpage

### C. Proportion of Within-Intervention Village Spillover Treatment Assignment Effect Mediated by Circumcision

Then, $\frac{\beta_1^{\text{SpW}} - \beta_1^{\text{SpWR}}}{\beta_1^{\text{SpW}}}$ is the proportion of within-intervention village spillover effect mediated by circumcision.

```{r, comment = ""}
# Proportion of within-intervention village spillover effect mediated by MC
(log(exp_beta_SpW_1) - log(exp_beta_SpWR_1)) / log(exp_beta_SpW_1)
```

Thus, about `r round((log(exp_beta_SpW_1) - log(exp_beta_SpWR_1)) / log(exp_beta_SpW_1), 2)*100`% of within-village spillover protection experienced by untreated people in CP villages is explained by the higher male-circumcision coverage in those villages. The reamining spillover benefit must come through other village-level channels (e.g. HTC uptake, community health behavior change, program outreach, etc.)

```{r, include = FALSE}
# Extract beta1 (SpWM and SpW) on log-odds scale
b1_SpWR <- coef(model_SpWR)["T_k"]
b1_SpW  <- coef(model_SpW)["T_k"]

# Extract their standard errors
se1_SpWR <- sqrt(vcov(model_SpWR)["T_k", "T_k"])
se1_SpW  <- sqrt(vcov(model_SpW)["T_k", "T_k"])

# Calculate difference on log-odds scale and its SE
diff_logOR <- b1_SpWR - b1_SpW
se_diff <- sqrt(se1_SpWR^2 + se1_SpW^2)  # assuming independence

# CI on log scale
lower <- diff_logOR - 1.96 * se_diff
upper <- diff_logOR + 1.96 * se_diff

# Exponentiate everything
point_estimate <- exp(diff_logOR)
ci_lower <- exp(lower)
ci_upper <- exp(upper)

# Output results
tibble(
  `Proportion Mediated` = point_estimate,
  `95% CI Lower` = ci_lower,
  `95% CI Upper` = ci_upper
)
```


\newpage

## Individual Effects

\underline{Setup}

- In this analysis, we include:

    a. All males in the treatment group
    b. All males in the control group

- In this analysis, we will estimate the effects of the intervention assignment on the outcome. In the mediation model, we will account for if they actually received the circumcision component or not.

- This setup will allow us to estimate

    a. Direct Effects of Treatment Assignment
    b. Mediated Effects of Circumcision
    c. Proportion of Individual Effect due to Circumcision

```{r}
# Alternative to fix data availability
  # Include only those who were circumcised in the treatment
  # Include everyone in the control
modelDat_Ind <- modelDat %>%
  filter(C1_ik == 1)
```

\underline{Summary counts of individuals per treatment group}

```{r, echo = FALSE, comment = ""}
# Quick summary statistics
print(tally(T_k ~ X1_ik, data = modelDat_Ind))
print(tally(Y_ik ~ X1_ik, data = modelDat_Ind))
print(tally(T_k ~ Y_ik, data = modelDat_Ind))
```

\newpage

### D. Total Individual Effect of Treatment Assignment

"Ind" denotes individual effects, i.e. effects of a male's own treatment assignment on their own outcome. Here, we also block the spillover that exists through the proportion circumcised and proportion who received HTC in the cluster by controlling for it in the model. 

$$logit(Y_{ik}) = \beta_0^{\text{Ind}} + \beta_1^{\text{Ind}}(T_{k}) + \beta_2^{\text{Ind}}(Z_{k}^{(1)}) + \beta_3^{\text{Ind}}(Z_{k}^{(2)})$$

The total individual effect of a male's own treatment assignment on their own outcome is $\beta_1^{\text{Ind}}$, and the corresponding OR is $\exp \left(\beta_1^{\text{Ind}} \right)$.

```{r}
# Individual Effects
model_Ind <- glm(Y_ik ~ T_k + Z1_k + Z2_k,
                 family = binomial(link = 'logit'),
                 data = modelDat_Ind)

model_Ind_summary <- summary(model_Ind) # Save model summary

exp_beta_Ind_0 <- exp(model_Ind_summary$coefficients[1,1]) # Intercept
exp_beta_Ind_1 <- exp(model_Ind_summary$coefficients[2,1]) # T_k Coefficient, 
                                                       # total Ind effect
exp_beta_Ind_3 <- exp(model_Ind_summary$coefficients[3,1]) # Z1 coeff
exp_beta_Ind_4 <- exp(model_Ind_summary$coefficients[4,1]) # Z2 coeff

#model_Ind_summary # Print summary
#tidy(model_Ind, exponentiate = TRUE, conf.int = TRUE) # Print output

tidy_Ind <- tidy(model_Ind, conf.int = TRUE, exponentiate = TRUE) %>%
  dplyr::select(term, estimate, std.error, p.value, conf.low, conf.high) %>%
  rename(
    Term = term,
    OR = estimate,
    SE = std.error,
    `p-value` = p.value,
    `95% CI (lower)` = conf.low,
    `95% CI (upper)` = conf.high
  )
#tidy_Ind
```

```{r, results = 'asis', include = FALSE}
print(xtable(tidy_Ind, digits = c(0, 0, 3, 3, 3, 3, 3),
             caption = "Individual Effects of Circumcision Model"), 
      type = 'latex', include.rownames = FALSE, comment = FALSE)
```

Since $\exp\left( \beta_1^{\text{Ind}} \right) =$ `r round(exp_beta_Ind_1, 2)`, then the odds of seroconverting for a man in a CP village are `r round(exp_beta_Ind_1, 2)` $\times$ the odds for a man in a control village. This is a `r (1-round(exp_beta_Ind_1, 2))*100`% reduction in the odds. Thus, among men, being in a village randomized to the CP package is associated with substantially lower odds of acquiring HIV during the study.

\newpage

### E. Individual Direct Effects of Treatment Assignment

"IndD" denotes individual direct effects, i.e. effects of a male's own treatment assignment on their own outcome, blocking the path through the "mediator" (circumcision treatment component) by controlling for it in the model. Here, we also block the spillover that exists through the proportion circumcised and proportion who received HTC in the cluster by controlling for it in the model. 

$$logit(Y_{ik}) = \beta_0^{\text{IndD}} + \beta_1^{\text{IndD}}(T_{k}) + \beta_2^{\text{IndD}}(X_{ik}^{(1)}) + \beta_3^{\text{IndD}}(Z_k^{(1)}) + \beta_4^{\text{IndD}}(Z_k^{(2)})$$

The individual direct effect of a male's treatment assignment on their outcome is thus $\beta_1^{\text{IndD}}$, since we are blocking the pathway from the treatment assignment to the outcome that goes through the circumcision component by controlling for it in the model.

The odds ratio of comparing CP-assignemnt vs. control for a male whose own circumcision status is held fixed is $\exp \left( \beta_1^{\text{IndD}}(T_{k}) \right)$.

The odds ratio comparing circumcised vs. not, given village assignment is $\exp \left( \beta_2^{\text{IndD}}(X_{ik}^{(1)}) \right)$.

```{r, eval = FALSE, include = FALSE}
# Individual Direct Effect
model_IndD <- glm(Y_ik ~ T_k + X1_ik + Z1_k + Z2_k,
                  family = binomial(link = 'logit'),
                  data = modelDat_Ind)

model_IndD_summary <- summary(model_IndD)

exp_beta_IndD_0 <- exp(model_IndD_summary$coefficients[1,1]) # Intercept
exp_beta_IndD_1 <- exp(model_IndD_summary$coefficients[2,1]) # T_k Coefficient, 
                                                    # direct individual effect
exp_beta_IndD_2 <- exp(model_IndD_summary$coefficients[3,1]) # X1_k Coefficient

tidy_IndD <- tidy(model_IndD, conf.int = TRUE, exponentiate = TRUE) %>%
  dplyr::select(term, estimate, std.error, p.value, conf.low, conf.high) %>%
  rename(
    Term = term,
    OR = estimate,
    SE = std.error,
    `p-value` = p.value,
    `95% CI (lower)` = conf.low,
    `95% CI (upper)` = conf.high
  )
#tidy_IndD
```

```{r, results = 'asis', include = FALSE, eval = FALSE}
print(xtable(tidy_IndD, digits = c(0, 0, 3, 3, 3, 3, 3),
             caption = "Individual Mediated Effects of Circumcision Model"), 
      type = 'latex', include.rownames = FALSE, comment = FALSE)
```


```{r, echo = FALSE, comment = ""}
print(tally(T_k ~ Y_ik, data = modelDat_Ind))
print(tally(X1_ik ~ Y_ik, data = modelDat_Ind)) # try exact logistic regression
                                         # Could also look at the product method
print(tally(T_k ~ X1_ik, data = modelDat_Ind))
```

Because every uncircumcised man in our dataset had zero HIV-seroconversions, the data display complete separation. In other words, one predictor level (“No circumcision”) perfectly predicts the outcome (“did not seroconvert”). Ordinary or exact logistic regression depends on being able to compare many hypothetical re-arrangements of the data in which the pattern is not perfect; when a column or row is all 0’s or all 1’s, those hypothetical tables don’t exist. As a result, the likelihood tries to push the corresponding coefficient toward negative infinity, and the exact algorithm has nothing to sum over, so it simply cannot return an estimate.

Firth’s bias-reduced logistic regression fixes the problem by adding a small penalty to the likelihood. The penalty keeps the estimates finite even when a predictor perfectly separates the outcome, and it also reduces small-sample bias. In practice, Firth’s method produces odds-ratio estimates and profile-likelihood confidence intervals that coincide with exact (conditional) results whenever exact logistic can run, and it remains reliable when exact logistic cannot. Therefore we used the Firth-penalised model for the individual-direct-effect analysis; it is the standard remedy for separation and is widely accepted in epidemiology and biostatistics.

```{r}
# Using Firth's model instead:
# Helpful when we have complete or quasi-complete separation
# It applies a penalty to the likelihood function that 
# reduces small-sample bias in MLE
# Naturally prevents infinite estimates when separation occurs
# It uses Jeffreys invariant prior to modify the score function

model_IndD_firth <- logistf(Y_ik ~ T_k + X1_ik + Z1_k + Z2_k, 
                            data = modelDat_Ind)

exp_beta_IndD_0_firth <- exp(model_IndD_firth$coefficients[[1]]) # Intercept
exp_beta_IndD_1_firth <- exp(model_IndD_firth$coefficients[[2]]) # T_k Coefficient, 
                                                    # direct individual effect
exp_beta_IndD_2_firth <- exp(model_IndD_firth$coefficients[[3]]) # X1_ik Coefficient

exp_beta_IndD_3_firth <- exp(model_IndD_firth$coefficients[[4]]) # Z1_k Coefficient
exp_beta_IndD_4_firth <- exp(model_IndD_firth$coefficients[[5]]) # Z2_k Coefficient

# Pull directly from the model
coef_table_firth <- model_IndD_firth$coefficients      # log-odds estimates (named vector)
se_table_firth   <- sqrt(diag(model_IndD_firth$var))   # standard errors
pval_table_firth <- model_IndD_firth$prob              # p-values
ci_lower_firth   <- model_IndD_firth$ci.lower          # lower bound on log-odds
ci_upper_firth   <- model_IndD_firth$ci.upper          # upper bound on log-odds

tidy_IndD_firth <- tibble(
  Term = names(coef_table_firth),
  OR = exp(coef_table_firth),
  SE = se_table_firth,
  `p-value` = pval_table_firth,
  `95% CI (lower)` = exp(ci_lower_firth),
  `95% CI (upper)` = exp(ci_upper_firth)
)
#tidy_IndM_firth
```

```{r, results = 'asis', include = FALSE}
print(xtable(tidy_IndD_firth, digits = c(0, 0, 3, 3, 3, 3, 3),
             caption = "Individual Mediated Effects of Circumcision Model (Firth's Model Adjustment)"), 
      type = 'latex', include.rownames = FALSE, comment = FALSE)
```

Holding a male's own circumcision status fixed, being in a village randomized to CP is associated with about `r (1-round(exp_beta_IndD_1_firth, 2))*100`% reduction in the odds of seroconversion compared with control villages. This is the individual controlled direct effect of assignment. 

After accounting for village assignment, the model estimates that men who were circumcised have far higher observed odds of seroconversion than uncircumcised men (OR is `r round(exp_beta_IndD_2_firth, 2)`). This very large odds-ratio arises because no seroconversions occurred among the uncircumcised group (complete separation); the Firth penalty keeps the estimate finite but it remains unstable and imprecise. Hence, the direction and size of this effect should be interpreted with caution - it is driven by sparse data rather than clear evidence that circumcision increases risk. 

\newpage

### F. Indirect Individual Effect of Treatment Assignment

Then, the controlled indirect OR can be calculated as $\exp\left( \beta_1^{\text{Ind}} - \beta_1^{\text{IndD}} \right)$

```{r}
exp(log(exp_beta_Ind_1) - log(exp_beta_IndD_1_firth)) # Controlled indirect individual effect
```

This captures the cluster assignment's effect on a man's seroconversion odds that operates through his own circumcision status (while all other pathways are held constant).

An odds-ratio of `r round(exp(log(exp_beta_Ind_1) - log(exp_beta_IndD_1_firth)), 2)` means that, after we remove the "direct" pathway (OR `r round(exp_beta_IndD_1_firth, 2)`), the remaining pathway that goes via a man's own circumcision increases his odds of seroconversion by roughly `r round((exp(log(exp_beta_Ind_1) - log(exp_beta_IndD_1_firth))-1)*100, 2)`.

Overall, among men, the component of CP assignment that works through circumcision is associated with higher observed odds of HIV acquisition, offsetting some of the strong direct protection of being in a CP village.

Some caveats:
    - Since no uncircumcised men seroconverted, the circumcision coefficient (and therefore this ratio) is based on very little information and may be highly imprecise.
    
    - The sign reversal (indirect pathway harmful while direct pathway protective) likely reflects residual confounding or selection into circumcision rather than a true causal increase in risk from circumcision itself.
    
    - So 1.54 tells us that, within the current model, the circumcision pathway moves the total effect closer to the null rather than adding to the protection conferred directly by the CP assignment.

### G. Proportion of Individual Effect of Treatment Assignment Mediated by Circumcision

The proportion of total individual effect of a male's treatment assignment, mediated by him receiving circumcision is $\frac{\beta_1^{\text{Ind}} - \beta_1^{\text{IndD}}}{\beta_1^{\text{Ind}}}$

```{r}
(log(exp_beta_Ind_1) - log(exp_beta_IndD_1_firth))/(log(exp_beta_Ind_1))
```

From this value, it seems that the mediator (one's own circumcision) works in the opposite direction to the total effect. Circumcision uptake appears to offset about 47% of the benefit that CP villages otherwise confer. 

\newpage

## Overall Effects

### H. Overall Intervention Village Effect

The overall effect of being in an intervention village can be calculated by just fitting the following model on the overall dataset of HIV-negative individuals (at the start of the study), without controlling for any other causal pathways. 

$$logit(Y_{ik}) = \beta_0^{\text{Overall}} + \beta_1^{\text{Overall}}(T_{k})$$

```{r}
# Overall Effect of being in an Intervention Cluster
model_overall <- glm(Y_ik ~ T_k,
                     family = binomial(link = 'logit'),
                     data = modelDat) # Everyone

model_overall_summary <- summary(model_overall) # Save model summary

exp_beta_overall_0 <- exp(model_overall_summary$coefficients[1,1]) # Intercept
exp_beta_overall_1 <- exp(model_overall_summary$coefficients[2,1]) # T_k Coefficient

tidy_overall <- tidy(model_overall, conf.int = TRUE, exponentiate = TRUE) %>%
  dplyr::select(term, estimate, std.error, p.value, conf.low, conf.high) %>%
  rename(
    Term = term,
    OR = estimate,
    SE = std.error,
    `p-value` = p.value,
    `95% CI (lower)` = conf.low,
    `95% CI (upper)` = conf.high
  )
```

```{r, results = 'asis', echo = FALSE}
print(xtable(tidy_overall, digits = c(0, 0, 3, 3, 3, 3, 3),
             caption = "Overall Effect of being in an Intervention Cluster"), 
      type = 'latex', include.rownames = FALSE, comment = FALSE)
```

Thus, the OR is `r round(exp_beta_overall_1, 2)`, meaning that for HIV-negative individuals at baseline, living in an intervention village is associated with a `r (1 - round(exp_beta_overall_1, 2))*100`% reduction in the odds of seroconversion during follow-up compared with living in a control village. This single odds ratio blends every causal pathway, thus resulting in an overall effect. It is the total impact of the intervention environment on an average resident. 

#### I. Proportion of total effect mediated by male circumcision

The proportion of total effect mediated by male circumcision is

$$\frac{[(\beta_1^{\text{Ind}} - \beta_1^{\text{IndM}}) + (\beta_1^{\text{SpW}} - \beta_1^{\text{SpWM}})]}{(\beta_1^{\text{Ind}} + \beta_1^{\text{SpW}})}$$

```{r}
# Proportion of total effect mediated by male circumcision
#((beta_Ind_1 - beta_IndM_1) + (beta_SpW_1 - beta_SpWM_1))/(beta_Ind_1 + beta_SpW_1) 
# Proportion of total effect mediated by male circumcision firth model
exp(((log(exp_beta_Ind_1) - log(exp_beta_IndD_1_firth)) + (log(exp_beta_SpW_1) - log(exp_beta_SpWR_1)))/(log(exp_beta_Ind_1) + log(exp_beta_SpW_1)))
```


### J. Proportion of intervention village total effect due to spillover within intervention villages

The proportion of intervention village total effect due to spillover within intervention villages is 

$$\frac{\beta_1^{\text{SpW}}}{(\beta_1^{\text{Ind}} - \beta_1^{\text{SpW}})}$$

```{r}
# Proportion of intervention village total effect due to spillover within intervention villages
log(exp_beta_SpW_1)/(log(exp_beta_Ind_1) + log(exp_beta_SpW_1))
```

\newpage

# Note to Donna

I'm worried that this approach doesn't let us decompose the effects - if we want to be able to decompose the overall effect using estimands from the individual models and spillover models, we need to use the same population for all models, so that the models are truly nested. 

Here's a summary of what we've done:

| Model Name | Model equation                                                                                                                           | Analytic sample                  | Extra covariates                   | What $\beta\_1$ estimates                                                                                 |
| ------------ | ------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------- | ---------------------------------- | ----------------------------------------------------------------------------------------------------------- |
| **Overall**  | $\displaystyle \operatorname{logit}(Y_{ik})=\beta_0+\beta_1T_k$                                                             | All HIV-negative participants    | none                               | Total impact of CP village assignment (own uptake + *all* spillover)                                        |
| **Ind**      | $\displaystyle \operatorname{logit}(Y_{ik})=\beta_0+\beta_1 T_k+\beta_2 Z_k^{(1)}+\beta_3 Z_k^{(2)}$                       | Males Only                | village MC & HTC coverage          | Assignment effect after measured spillover is held fixed (still contains own-uptake + unmeasured spillover) |
| **IndD**     | $\displaystyle \operatorname{logit}(Y_{ik})=\beta_0+\beta_1 T_k+\beta_2X_{ik}^{(1)}+\beta_3 Z_k^{(1)}+\beta_4 Z_k^{(2)}$ | Males Only                | own MC $X_{ik}^{(1)}$ + $Z$’s | Controlled-direct effect (paths via own MC **and** measured spillover blocked)                              |
| **SpW**      | $\displaystyle \operatorname{logit}(Y_{ik})=\beta_0+\beta_1 T_k$                                                             | Untreated Individuals | none                               | Total spillover for untreated people                                                                        |
| **SpWR**     | $\displaystyle \operatorname{logit}(Y_{ik})=\beta_0+\beta_1T_k+\beta_2 Z_k^{(1)}$                                          | Untreated Individuals            | village MC coverage                | Remaining spillover after MC-coverage path is held fixed                                                    |


And here's a proposal of how to maybe redo this so that the models are nested, and thus we can get valid results for important estimands such as "proportion of the total effect explained by spillover". 

Steps: 

1. Work on a single dataset (e.g. all HIV-negative participants at start of study)

2. Fit nested lgoistic models so that each new model adds only one class of pathways:

| Label                           | Model equation                                                                                                                                                  | $\beta_1$ contains             |
| ------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------- |
| **A.  Total effect**             | $\displaystyle \operatorname{logit}\bigl(P(Y_{ik}=1)\bigr)=\beta_0+\beta_1T_k$                                                                                   | Own uptake + **all** spillover    |
| **B.  Minus own uptake**         | $\displaystyle \operatorname{logit}\bigl(P(Y_{ik}=1)\bigr)=\beta_0+\beta_1T_k+\beta_2X_{ik}^{(1)}+\beta_3X_{ik}^{(2)}$                                       | **All spillover**                 |
| **C.  Minus measured spillover** | $\displaystyle \operatorname{logit}\bigl(P(Y_{ik}=1)\bigr)=\beta_0+\beta_1T_k+\beta_2X_{ik}^{(1)}+\beta_3X_{ik}^{(2)}+\beta_4Z_k^{(1)}+\beta_5Z_k^{(2)}$ | Residual (*unmeasured*) spillover |


3. On the log-odds scale, the proportion of the total effect explained by spillover is then

$$\frac{\beta_1^A - \beta_1^B}{\beta_1^A}$$

4. All decompositions: 

    - Own uptake contribution is $\beta_1^A - \beta_1^B$
    - Measured spillover = $\beta_1^B - \beta_1^C$
    - Unmeasured spillover = $\beta_1^C$
    - These three pieces add up exactly: $\beta_1^A = (\beta_1^A - \beta_1^B) + (\beta_1^B - \beta_1^C) + \beta_1^C$



All quantities come from the same population, so the algebra and interpretation is valid.
